{
    "sourceFile": "src/components/SignatureCanvas.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1760252111480,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1760252191616,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,180 @@\n+import React, { useRef, useEffect, useState } from 'react';\n+import styled from 'styled-components';\n+\n+const SignatureContainer = styled.div`\n+  position: relative;\n+  border: 2px solid #ddd;\n+  border-radius: 8px;\n+  background: white;\n+`;\n+\n+const Canvas = styled.canvas`\n+  display: block;\n+  cursor: crosshair;\n+  \n+  &:hover {\n+    border-color: #007bff;\n+  }\n+`;\n+\n+const ClearButton = styled.button`\n+  position: absolute;\n+  top: 8px;\n+  right: 8px;\n+  width: 24px;\n+  height: 24px;\n+  border: none;\n+  border-radius: 50%;\n+  background: #dc3545;\n+  color: white;\n+  cursor: pointer;\n+  display: flex;\n+  align-items: center;\n+  justify-content: center;\n+  font-size: 14px;\n+  font-weight: bold;\n+  opacity: 0.7;\n+  transition: opacity 0.2s;\n+  \n+  &:hover {\n+    opacity: 1;\n+  }\n+  \n+  &:disabled {\n+    opacity: 0.3;\n+    cursor: not-allowed;\n+  }\n+`;\n+\n+interface SignatureCanvasProps {\n+  width?: number;\n+  height?: number;\n+  onSignatureChange: (dataUrl: string) => void;\n+  initialSignature?: string;\n+}\n+\n+const SignatureCanvas: React.FC<SignatureCanvasProps> = ({\n+  width = 300,\n+  height = 150,\n+  onSignatureChange,\n+  initialSignature\n+}) => {\n+  const canvasRef = useRef<HTMLCanvasElement>(null);\n+  const [isDrawing, setIsDrawing] = useState(false);\n+  const [isEmpty, setIsEmpty] = useState(true);\n+\n+  useEffect(() => {\n+    const canvas = canvasRef.current;\n+    if (!canvas) return;\n+\n+    const ctx = canvas.getContext('2d');\n+    if (!ctx) return;\n+\n+    // 캔버스 설정\n+    ctx.strokeStyle = '#000';\n+    ctx.lineWidth = 2;\n+    ctx.lineCap = 'round';\n+    ctx.lineJoin = 'round';\n+\n+    // 초기 서명이 있다면 로드\n+    if (initialSignature) {\n+      const img = new Image();\n+      img.onload = () => {\n+        ctx.clearRect(0, 0, canvas.width, canvas.height);\n+        ctx.drawImage(img, 0, 0);\n+        setIsEmpty(false);\n+      };\n+      img.src = initialSignature;\n+    }\n+  }, [initialSignature]);\n+\n+  const startDrawing = (e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {\n+    e.preventDefault();\n+    const canvas = canvasRef.current;\n+    if (!canvas) return;\n+\n+    const rect = canvas.getBoundingClientRect();\n+    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;\n+    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;\n+    \n+    const x = clientX - rect.left;\n+    const y = clientY - rect.top;\n+\n+    const ctx = canvas.getContext('2d');\n+    if (!ctx) return;\n+\n+    setIsDrawing(true);\n+    ctx.beginPath();\n+    ctx.moveTo(x, y);\n+  };\n+\n+  const draw = (e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {\n+    if (!isDrawing) return;\n+    e.preventDefault();\n+\n+    const canvas = canvasRef.current;\n+    if (!canvas) return;\n+\n+    const rect = canvas.getBoundingClientRect();\n+    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;\n+    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;\n+    \n+    const x = clientX - rect.left;\n+    const y = clientY - rect.top;\n+\n+    const ctx = canvas.getContext('2d');\n+    if (!ctx) return;\n+\n+    ctx.lineTo(x, y);\n+    ctx.stroke();\n+    setIsEmpty(false);\n+  };\n+\n+  const stopDrawing = () => {\n+    if (!isDrawing) return;\n+    \n+    setIsDrawing(false);\n+    const canvas = canvasRef.current;\n+    if (!canvas) return;\n+\n+    // 서명 데이터를 base64로 변환하여 콜백 호출\n+    const dataUrl = canvas.toDataURL('image/png');\n+    onSignatureChange(dataUrl);\n+  };\n+\n+  const clearSignature = () => {\n+    const canvas = canvasRef.current;\n+    if (!canvas) return;\n+\n+    const ctx = canvas.getContext('2d');\n+    if (!ctx) return;\n+\n+    ctx.clearRect(0, 0, canvas.width, canvas.height);\n+    setIsEmpty(true);\n+    onSignatureChange('');\n+  };\n+\n+  return (\n+    <SignatureContainer>\n+      <Canvas\n+        ref={canvasRef}\n+        width={width}\n+        height={height}\n+        onMouseDown={startDrawing}\n+        onMouseMove={draw}\n+        onMouseUp={stopDrawing}\n+        onMouseLeave={stopDrawing}\n+        onTouchStart={startDrawing}\n+        onTouchMove={draw}\n+        onTouchEnd={stopDrawing}\n+      />\n+      {!isEmpty && (\n+        <ClearButton onClick={clearSignature} title=\"지우기\">\n+          ×\n+        </ClearButton>\n+      )}\n+    </SignatureContainer>\n+  );\n+};\n+\n+export default SignatureCanvas;\n"
                },
                {
                    "date": 1761464324877,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,202 @@\n+import React, { useRef, useEffect, useState } from 'react';\n+import styled from 'styled-components';\n+\n+const SignatureContainer = styled.div<{ readonly?: boolean }>`\n+  position: relative;\n+  border: 2px solid ${props => props.readonly ? '#ccc' : '#ddd'};\n+  border-radius: 8px;\n+  background: ${props => props.readonly ? '#f8f9fa' : 'white'};\n+  ${props => props.readonly && `\n+    &::after {\n+      content: '서명 완료';\n+      position: absolute;\n+      top: 8px;\n+      left: 8px;\n+      background: #28a745;\n+      color: white;\n+      padding: 4px 8px;\n+      border-radius: 4px;\n+      font-size: 12px;\n+      font-weight: bold;\n+      z-index: 10;\n+    }\n+  `}\n+`;\n+\n+const Canvas = styled.canvas<{ readonly?: boolean }>`\n+  display: block;\n+  cursor: ${props => props.readonly ? 'default' : 'crosshair'};\n+  \n+  &:hover {\n+    border-color: ${props => props.readonly ? '#ccc' : '#007bff'};\n+  }\n+`;\n+\n+const ClearButton = styled.button`\n+  position: absolute;\n+  top: 8px;\n+  right: 8px;\n+  width: 24px;\n+  height: 24px;\n+  border: none;\n+  border-radius: 50%;\n+  background: #dc3545;\n+  color: white;\n+  cursor: pointer;\n+  display: flex;\n+  align-items: center;\n+  justify-content: center;\n+  font-size: 14px;\n+  font-weight: bold;\n+  opacity: 0.7;\n+  transition: opacity 0.2s;\n+  \n+  &:hover {\n+    opacity: 1;\n+  }\n+  \n+  &:disabled {\n+    opacity: 0.3;\n+    cursor: not-allowed;\n+  }\n+`;\n+\n+interface SignatureCanvasProps {\n+  width?: number;\n+  height?: number;\n+  onSignatureChange: (dataUrl: string) => void;\n+  initialSignature?: string;\n+  readonly?: boolean; // 읽기 전용 모드\n+}\n+\n+const SignatureCanvas: React.FC<SignatureCanvasProps> = ({\n+  width = 300,\n+  height = 150,\n+  onSignatureChange,\n+  initialSignature,\n+  readonly = false\n+}) => {\n+  const canvasRef = useRef<HTMLCanvasElement>(null);\n+  const [isDrawing, setIsDrawing] = useState(false);\n+  const [isEmpty, setIsEmpty] = useState(true);\n+\n+  useEffect(() => {\n+    const canvas = canvasRef.current;\n+    if (!canvas) return;\n+\n+    const ctx = canvas.getContext('2d');\n+    if (!ctx) return;\n+\n+    // 캔버스 설정\n+    ctx.strokeStyle = '#000';\n+    ctx.lineWidth = 2;\n+    ctx.lineCap = 'round';\n+    ctx.lineJoin = 'round';\n+\n+    // 초기 서명이 있다면 로드\n+    if (initialSignature) {\n+      const img = new Image();\n+      img.onload = () => {\n+        ctx.clearRect(0, 0, canvas.width, canvas.height);\n+        ctx.drawImage(img, 0, 0);\n+        setIsEmpty(false);\n+      };\n+      img.src = initialSignature;\n+    }\n+  }, [initialSignature]);\n+\n+  const startDrawing = (e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {\n+    if (readonly) return; // 읽기 전용 모드에서는 그리기 불가\n+    \n+    e.preventDefault();\n+    const canvas = canvasRef.current;\n+    if (!canvas) return;\n+\n+    const rect = canvas.getBoundingClientRect();\n+    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;\n+    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;\n+    \n+    const x = clientX - rect.left;\n+    const y = clientY - rect.top;\n+\n+    const ctx = canvas.getContext('2d');\n+    if (!ctx) return;\n+\n+    setIsDrawing(true);\n+    ctx.beginPath();\n+    ctx.moveTo(x, y);\n+  };\n+\n+  const draw = (e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {\n+    if (!isDrawing || readonly) return; // 읽기 전용 모드에서는 그리기 불가\n+    e.preventDefault();\n+\n+    const canvas = canvasRef.current;\n+    if (!canvas) return;\n+\n+    const rect = canvas.getBoundingClientRect();\n+    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;\n+    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;\n+    \n+    const x = clientX - rect.left;\n+    const y = clientY - rect.top;\n+\n+    const ctx = canvas.getContext('2d');\n+    if (!ctx) return;\n+\n+    ctx.lineTo(x, y);\n+    ctx.stroke();\n+    setIsEmpty(false);\n+  };\n+\n+  const stopDrawing = () => {\n+    if (!isDrawing || readonly) return; // 읽기 전용 모드에서는 그리기 불가\n+    \n+    setIsDrawing(false);\n+    const canvas = canvasRef.current;\n+    if (!canvas) return;\n+\n+    // 서명 데이터를 base64로 변환하여 콜백 호출\n+    const dataUrl = canvas.toDataURL('image/png');\n+    onSignatureChange(dataUrl);\n+  };\n+\n+  const clearSignature = () => {\n+    if (readonly) return; // 읽기 전용 모드에서는 삭제 불가\n+    \n+    const canvas = canvasRef.current;\n+    if (!canvas) return;\n+\n+    const ctx = canvas.getContext('2d');\n+    if (!ctx) return;\n+\n+    ctx.clearRect(0, 0, canvas.width, canvas.height);\n+    setIsEmpty(true);\n+    onSignatureChange('');\n+  };\n+\n+  return (\n+    <SignatureContainer readonly={readonly}>\n+      <Canvas\n+        ref={canvasRef}\n+        width={width}\n+        height={height}\n+        readonly={readonly}\n+        onMouseDown={startDrawing}\n+        onMouseMove={draw}\n+        onMouseUp={stopDrawing}\n+        onMouseLeave={stopDrawing}\n+        onTouchStart={startDrawing}\n+        onTouchMove={draw}\n+        onTouchEnd={stopDrawing}\n+      />\n+      {!isEmpty && !readonly && (\n+        <ClearButton onClick={clearSignature} title=\"지우기\">\n+          ×\n+        </ClearButton>\n+      )}\n+    </SignatureContainer>\n+  );\n+};\n+\n+export default SignatureCanvas;\n"
                },
                {
                    "date": 1761464477267,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -92,19 +92,29 @@\n     ctx.lineWidth = 2;\n     ctx.lineCap = 'round';\n     ctx.lineJoin = 'round';\n \n+    // 캔버스 초기화\n+    ctx.clearRect(0, 0, canvas.width, canvas.height);\n+\n     // 초기 서명이 있다면 로드\n-    if (initialSignature) {\n+    if (initialSignature && initialSignature.trim() !== '') {\n       const img = new Image();\n       img.onload = () => {\n         ctx.clearRect(0, 0, canvas.width, canvas.height);\n         ctx.drawImage(img, 0, 0);\n         setIsEmpty(false);\n       };\n+      img.onerror = () => {\n+        console.error('서명 이미지 로드 실패');\n+        setIsEmpty(true);\n+      };\n       img.src = initialSignature;\n+    } else {\n+      // 초기 서명이 없으면 빈 상태로 설정\n+      setIsEmpty(true);\n     }\n-  }, [initialSignature]);\n+  }, [initialSignature]); // initialSignature가 변경될 때마다 실행\n \n   const startDrawing = (e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {\n     if (readonly) return; // 읽기 전용 모드에서는 그리기 불가\n     \n@@ -199,377 +209,4 @@\n   );\n };\n \n export default SignatureCanvas;\n-import React, { useRef, useEffect, useState } from 'react';\n-import styled from 'styled-components';\n-\n-const SignatureContainer = styled.div`\n-  position: relative;\n-  border: 2px solid #ddd;\n-  border-radius: 8px;\n-  background: white;\n-`;\n-\n-const Canvas = styled.canvas`\n-  display: block;\n-  cursor: crosshair;\n-  \n-  &:hover {\n-    border-color: #007bff;\n-  }\n-`;\n-\n-const ClearButton = styled.button`\n-  position: absolute;\n-  top: 8px;\n-  right: 8px;\n-  width: 24px;\n-  height: 24px;\n-  border: none;\n-  border-radius: 50%;\n-  background: #dc3545;\n-  color: white;\n-  cursor: pointer;\n-  display: flex;\n-  align-items: center;\n-  justify-content: center;\n-  font-size: 14px;\n-  font-weight: bold;\n-  opacity: 0.7;\n-  transition: opacity 0.2s;\n-  \n-  &:hover {\n-    opacity: 1;\n-  }\n-  \n-  &:disabled {\n-    opacity: 0.3;\n-    cursor: not-allowed;\n-  }\n-`;\n-\n-interface SignatureCanvasProps {\n-  width?: number;\n-  height?: number;\n-  onSignatureChange: (dataUrl: string) => void;\n-  initialSignature?: string;\n-}\n-\n-const SignatureCanvas: React.FC<SignatureCanvasProps> = ({\n-  width = 300,\n-  height = 150,\n-  onSignatureChange,\n-  initialSignature\n-}) => {\n-  const canvasRef = useRef<HTMLCanvasElement>(null);\n-  const [isDrawing, setIsDrawing] = useState(false);\n-  const [isEmpty, setIsEmpty] = useState(true);\n-\n-  useEffect(() => {\n-    const canvas = canvasRef.current;\n-    if (!canvas) return;\n-\n-    const ctx = canvas.getContext('2d');\n-    if (!ctx) return;\n-\n-    // 캔버스 설정\n-    ctx.strokeStyle = '#000';\n-    ctx.lineWidth = 2;\n-    ctx.lineCap = 'round';\n-    ctx.lineJoin = 'round';\n-\n-    // 초기 서명이 있다면 로드\n-    if (initialSignature) {\n-      const img = new Image();\n-      img.onload = () => {\n-        ctx.clearRect(0, 0, canvas.width, canvas.height);\n-        ctx.drawImage(img, 0, 0);\n-        setIsEmpty(false);\n-      };\n-      img.src = initialSignature;\n-    }\n-  }, [initialSignature]);\n-\n-  const startDrawing = (e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {\n-    e.preventDefault();\n-    const canvas = canvasRef.current;\n-    if (!canvas) return;\n-\n-    const rect = canvas.getBoundingClientRect();\n-    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;\n-    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;\n-    \n-    const x = clientX - rect.left;\n-    const y = clientY - rect.top;\n-\n-    const ctx = canvas.getContext('2d');\n-    if (!ctx) return;\n-\n-    setIsDrawing(true);\n-    ctx.beginPath();\n-    ctx.moveTo(x, y);\n-  };\n-\n-  const draw = (e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {\n-    if (!isDrawing) return;\n-    e.preventDefault();\n-\n-    const canvas = canvasRef.current;\n-    if (!canvas) return;\n-\n-    const rect = canvas.getBoundingClientRect();\n-    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;\n-    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;\n-    \n-    const x = clientX - rect.left;\n-    const y = clientY - rect.top;\n-\n-    const ctx = canvas.getContext('2d');\n-    if (!ctx) return;\n-\n-    ctx.lineTo(x, y);\n-    ctx.stroke();\n-    setIsEmpty(false);\n-  };\n-\n-  const stopDrawing = () => {\n-    if (!isDrawing) return;\n-    \n-    setIsDrawing(false);\n-    const canvas = canvasRef.current;\n-    if (!canvas) return;\n-\n-    // 서명 데이터를 base64로 변환하여 콜백 호출\n-    const dataUrl = canvas.toDataURL('image/png');\n-    onSignatureChange(dataUrl);\n-  };\n-\n-  const clearSignature = () => {\n-    const canvas = canvasRef.current;\n-    if (!canvas) return;\n-\n-    const ctx = canvas.getContext('2d');\n-    if (!ctx) return;\n-\n-    ctx.clearRect(0, 0, canvas.width, canvas.height);\n-    setIsEmpty(true);\n-    onSignatureChange('');\n-  };\n-\n-  return (\n-    <SignatureContainer>\n-      <Canvas\n-        ref={canvasRef}\n-        width={width}\n-        height={height}\n-        onMouseDown={startDrawing}\n-        onMouseMove={draw}\n-        onMouseUp={stopDrawing}\n-        onMouseLeave={stopDrawing}\n-        onTouchStart={startDrawing}\n-        onTouchMove={draw}\n-        onTouchEnd={stopDrawing}\n-      />\n-      {!isEmpty && (\n-        <ClearButton onClick={clearSignature} title=\"지우기\">\n-          ×\n-        </ClearButton>\n-      )}\n-    </SignatureContainer>\n-  );\n-};\n-\n-export default SignatureCanvas;\n-import React, { useRef, useEffect, useState } from 'react';\n-import styled from 'styled-components';\n-\n-const SignatureContainer = styled.div`\n-  position: relative;\n-  border: 2px solid #ddd;\n-  border-radius: 8px;\n-  background: white;\n-`;\n-\n-const Canvas = styled.canvas`\n-  display: block;\n-  cursor: crosshair;\n-  \n-  &:hover {\n-    border-color: #007bff;\n-  }\n-`;\n-\n-const ButtonContainer = styled.div`\n-  display: flex;\n-  gap: 8px;\n-  margin-top: 8px;\n-`;\n-\n-const Button = styled.button`\n-  padding: 6px 12px;\n-  border: 1px solid #ddd;\n-  border-radius: 4px;\n-  background: white;\n-  cursor: pointer;\n-  font-size: 12px;\n-  \n-  &:hover {\n-    background: #f5f5f5;\n-  }\n-  \n-  &.clear {\n-    color: #dc3545;\n-    border-color: #dc3545;\n-    \n-    &:hover {\n-      background: #f8d7da;\n-    }\n-  }\n-`;\n-\n-interface SignatureCanvasProps {\n-  width?: number;\n-  height?: number;\n-  onSignatureChange: (dataUrl: string) => void;\n-  initialSignature?: string;\n-}\n-\n-const SignatureCanvas: React.FC<SignatureCanvasProps> = ({\n-  width = 300,\n-  height = 150,\n-  onSignatureChange,\n-  initialSignature\n-}) => {\n-  const canvasRef = useRef<HTMLCanvasElement>(null);\n-  const [isDrawing, setIsDrawing] = useState(false);\n-  const [isEmpty, setIsEmpty] = useState(true);\n-\n-  useEffect(() => {\n-    const canvas = canvasRef.current;\n-    if (!canvas) return;\n-\n-    const ctx = canvas.getContext('2d');\n-    if (!ctx) return;\n-\n-    // 캔버스 설정\n-    ctx.strokeStyle = '#000';\n-    ctx.lineWidth = 2;\n-    ctx.lineCap = 'round';\n-    ctx.lineJoin = 'round';\n-\n-    // 초기 서명이 있다면 로드\n-    if (initialSignature) {\n-      const img = new Image();\n-      img.onload = () => {\n-        ctx.clearRect(0, 0, canvas.width, canvas.height);\n-        ctx.drawImage(img, 0, 0);\n-        setIsEmpty(false);\n-      };\n-      img.src = initialSignature;\n-    }\n-  }, [initialSignature]);\n-\n-  const startDrawing = (e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {\n-    e.preventDefault();\n-    const canvas = canvasRef.current;\n-    if (!canvas) return;\n-\n-    const rect = canvas.getBoundingClientRect();\n-    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;\n-    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;\n-    \n-    const x = clientX - rect.left;\n-    const y = clientY - rect.top;\n-\n-    const ctx = canvas.getContext('2d');\n-    if (!ctx) return;\n-\n-    setIsDrawing(true);\n-    ctx.beginPath();\n-    ctx.moveTo(x, y);\n-  };\n-\n-  const draw = (e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {\n-    if (!isDrawing) return;\n-    e.preventDefault();\n-\n-    const canvas = canvasRef.current;\n-    if (!canvas) return;\n-\n-    const rect = canvas.getBoundingClientRect();\n-    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;\n-    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;\n-    \n-    const x = clientX - rect.left;\n-    const y = clientY - rect.top;\n-\n-    const ctx = canvas.getContext('2d');\n-    if (!ctx) return;\n-\n-    ctx.lineTo(x, y);\n-    ctx.stroke();\n-    setIsEmpty(false);\n-  };\n-\n-  const stopDrawing = () => {\n-    if (!isDrawing) return;\n-    \n-    setIsDrawing(false);\n-    const canvas = canvasRef.current;\n-    if (!canvas) return;\n-\n-    // 서명 데이터를 base64로 변환하여 콜백 호출\n-    const dataUrl = canvas.toDataURL('image/png');\n-    onSignatureChange(dataUrl);\n-  };\n-\n-  const clearSignature = () => {\n-    const canvas = canvasRef.current;\n-    if (!canvas) return;\n-\n-    const ctx = canvas.getContext('2d');\n-    if (!ctx) return;\n-\n-    ctx.clearRect(0, 0, canvas.width, canvas.height);\n-    setIsEmpty(true);\n-    onSignatureChange('');\n-  };\n-\n-  const downloadSignature = () => {\n-    const canvas = canvasRef.current;\n-    if (!canvas || isEmpty) return;\n-\n-    const dataUrl = canvas.toDataURL('image/png');\n-    const link = document.createElement('a');\n-    link.download = 'signature.png';\n-    link.href = dataUrl;\n-    link.click();\n-  };\n-\n-  return (\n-    <SignatureContainer>\n-      <Canvas\n-        ref={canvasRef}\n-        width={width}\n-        height={height}\n-        onMouseDown={startDrawing}\n-        onMouseMove={draw}\n-        onMouseUp={stopDrawing}\n-        onMouseLeave={stopDrawing}\n-        onTouchStart={startDrawing}\n-        onTouchMove={draw}\n-        onTouchEnd={stopDrawing}\n-      />\n-      <ButtonContainer>\n-        <Button onClick={clearSignature} className=\"clear\">\n-          지우기\n-        </Button>\n-        <Button onClick={downloadSignature} disabled={isEmpty}>\n-          다운로드\n-        </Button>\n-      </ButtonContainer>\n-    </SignatureContainer>\n-  );\n-};\n-\n-export default SignatureCanvas;\n"
                }
            ],
            "date": 1760252111480,
            "name": "Commit-0",
            "content": "import React, { useRef, useEffect, useState } from 'react';\nimport styled from 'styled-components';\n\nconst SignatureContainer = styled.div`\n  position: relative;\n  border: 2px solid #ddd;\n  border-radius: 8px;\n  background: white;\n`;\n\nconst Canvas = styled.canvas`\n  display: block;\n  cursor: crosshair;\n  \n  &:hover {\n    border-color: #007bff;\n  }\n`;\n\nconst ButtonContainer = styled.div`\n  display: flex;\n  gap: 8px;\n  margin-top: 8px;\n`;\n\nconst Button = styled.button`\n  padding: 6px 12px;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  background: white;\n  cursor: pointer;\n  font-size: 12px;\n  \n  &:hover {\n    background: #f5f5f5;\n  }\n  \n  &.clear {\n    color: #dc3545;\n    border-color: #dc3545;\n    \n    &:hover {\n      background: #f8d7da;\n    }\n  }\n`;\n\ninterface SignatureCanvasProps {\n  width?: number;\n  height?: number;\n  onSignatureChange: (dataUrl: string) => void;\n  initialSignature?: string;\n}\n\nconst SignatureCanvas: React.FC<SignatureCanvasProps> = ({\n  width = 300,\n  height = 150,\n  onSignatureChange,\n  initialSignature\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [isEmpty, setIsEmpty] = useState(true);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // 캔버스 설정\n    ctx.strokeStyle = '#000';\n    ctx.lineWidth = 2;\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n\n    // 초기 서명이 있다면 로드\n    if (initialSignature) {\n      const img = new Image();\n      img.onload = () => {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.drawImage(img, 0, 0);\n        setIsEmpty(false);\n      };\n      img.src = initialSignature;\n    }\n  }, [initialSignature]);\n\n  const startDrawing = (e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {\n    e.preventDefault();\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const rect = canvas.getBoundingClientRect();\n    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;\n    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;\n    \n    const x = clientX - rect.left;\n    const y = clientY - rect.top;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    setIsDrawing(true);\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n  };\n\n  const draw = (e: React.MouseEvent<HTMLCanvasElement> | React.TouchEvent<HTMLCanvasElement>) => {\n    if (!isDrawing) return;\n    e.preventDefault();\n\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const rect = canvas.getBoundingClientRect();\n    const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;\n    const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;\n    \n    const x = clientX - rect.left;\n    const y = clientY - rect.top;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    ctx.lineTo(x, y);\n    ctx.stroke();\n    setIsEmpty(false);\n  };\n\n  const stopDrawing = () => {\n    if (!isDrawing) return;\n    \n    setIsDrawing(false);\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    // 서명 데이터를 base64로 변환하여 콜백 호출\n    const dataUrl = canvas.toDataURL('image/png');\n    onSignatureChange(dataUrl);\n  };\n\n  const clearSignature = () => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    setIsEmpty(true);\n    onSignatureChange('');\n  };\n\n  const downloadSignature = () => {\n    const canvas = canvasRef.current;\n    if (!canvas || isEmpty) return;\n\n    const dataUrl = canvas.toDataURL('image/png');\n    const link = document.createElement('a');\n    link.download = 'signature.png';\n    link.href = dataUrl;\n    link.click();\n  };\n\n  return (\n    <SignatureContainer>\n      <Canvas\n        ref={canvasRef}\n        width={width}\n        height={height}\n        onMouseDown={startDrawing}\n        onMouseMove={draw}\n        onMouseUp={stopDrawing}\n        onMouseLeave={stopDrawing}\n        onTouchStart={startDrawing}\n        onTouchMove={draw}\n        onTouchEnd={stopDrawing}\n      />\n      <ButtonContainer>\n        <Button onClick={clearSignature} className=\"clear\">\n          지우기\n        </Button>\n        <Button onClick={downloadSignature} disabled={isEmpty}>\n          다운로드\n        </Button>\n      </ButtonContainer>\n    </SignatureContainer>\n  );\n};\n\nexport default SignatureCanvas;\n"
        }
    ]
}