{
    "sourceFile": "src/components/Editor/CustomTiptapEditor.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1757743518514,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1757743518514,
            "name": "Commit-0",
            "content": "import { useEditor, EditorContent, Editor } from \"@tiptap/react\";\n\nimport StarterKit from \"@tiptap/starter-kit\";\nimport Highlight from \"@tiptap/extension-highlight\";\nimport TextAlign from \"@tiptap/extension-text-align\";\nimport { TextStyle } from \"@tiptap/extension-text-style\";\nimport { FontFamily } from \"@tiptap/extension-font-family\";\nimport Link from \"@tiptap/extension-link\";\nimport Image from \"@tiptap/extension-image\";\nimport ImageResize from \"tiptap-extension-resize-image\";\nimport GapCursor from \"@tiptap/extension-gapcursor\";\nimport { Extension } from \"@tiptap/core\";\nimport { Node } from \"@tiptap/core\";\nimport Underline from \"@tiptap/extension-underline\";\n\nimport { Plugin, PluginKey } from \"prosemirror-state\";\nimport React, { useCallback, useEffect, useState } from \"react\";\nimport { useFloating, autoUpdate, offset, flip, shift } from '@floating-ui/react';\nimport {\n  MdFormatBold,\n  MdFormatItalic,\n  MdFormatUnderlined,\n  MdStrikethroughS,\n  MdHighlight,\n  MdLink,\n  MdFormatAlignLeft,\n  MdFormatAlignCenter,\n  MdFormatAlignRight,\n} from \"react-icons/md\";\n\nimport \"./Tiptap.css\";\nimport \"./BubbleMenu.css\";\nimport MenuBar from \"./MenuBar\";\n\n// 폰트 크기 확장을 위한 커스텀 설정\nconst FontSize = TextStyle.extend({\n  addAttributes() {\n    return {\n      fontSize: {\n        default: null,\n        parseHTML: (element: HTMLElement) => element.style.fontSize.replace(/['\"]+/g, \"\"),\n        renderHTML: (attributes: any) => {\n          if (!attributes.fontSize) {\n            return {};\n          }\n          return {\n            style: `font-size: ${attributes.fontSize}`,\n          };\n        },\n      },\n      lineHeight: {\n        default: null,\n        parseHTML: (element: HTMLElement) => element.style.lineHeight || null,\n        renderHTML: (attributes: any) => {\n          if (!attributes.lineHeight) return {};\n          return { style: `line-height: ${attributes.lineHeight}` };\n        },\n      },\n\n      letterSpacing: {\n        default: \"0\",\n        parseHTML: (element: HTMLElement) => element.style.letterSpacing,\n        renderHTML: (attributes: any) => {\n          if (!attributes.letterSpacing) {\n            return {};\n          }\n          return {\n            style: `letter-spacing: ${attributes.letterSpacing}`,\n          };\n        },\n      },\n    };\n  },\n\n  addCommands() {\n    return {\n      setFontSize:\n        (fontSize: string) =>\n        ({ commands }: any) => {\n          return commands.setMark(this.name, { fontSize: fontSize });\n        },\n      unsetFontSize:\n        () =>\n        ({ commands }: any) => {\n          return commands.unsetMark(this.name);\n        },\n      setLineHeight:\n        (lineHeight: string) =>\n        ({ commands }: any) => {\n          return commands.setMark(this.name, { lineHeight: lineHeight });\n        },\n      setLetterSpacing:\n        (letterSpacing: string) =>\n        ({ commands }: any) => {\n          return commands.setMark(this.name, { letterSpacing: letterSpacing });\n        },\n    };\n  },\n});\n\nconst uploadImage = async (file: File) => {\n  const reader = new FileReader();\n  reader.readAsDataURL(file);\n\n  return new Promise<string>((resolve, reject) => {\n    reader.onloadend = () => {\n      resolve(reader.result as string);\n    };\n    reader.onerror = reject;\n  });\n};\n\n// 이미지 노드 확장 설정\nconst CustomImage = Image.extend({\n  renderHTML({ HTMLAttributes }: { HTMLAttributes: any }) {\n    return [\"div\", { class: \"image-container\" }, [\"img\", HTMLAttributes]];\n  },\n});\n\n// YouTube 노드 정의\nconst YouTube = Node.create({\n  name: \"youtube\",\n  group: \"block\",\n  atom: true,\n\n  addAttributes() {\n    return {\n      src: {\n        default: null,\n      },\n      width: {\n        default: 640,\n      },\n      height: {\n        default: 360,\n      },\n    };\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'iframe[src*=\"youtube.com\"]',\n      },\n    ];\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      \"div\",\n      { class: \"youtube-video-container\" },\n      [\n        \"iframe\",\n        {\n          ...HTMLAttributes,\n          frameborder: \"0\",\n          allowfullscreen: \"true\",\n          allow: \"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\",\n        },\n      ],\n    ];\n  },\n});\n\n// YouTube 링크 감지 및 변환 확장\nconst YouTubeExtension = Extension.create({\n  name: \"youtubeExtension\",\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey(\"youtube-extension\"),\n        props: {\n          handlePaste: (view, event) => {\n            if (!event.clipboardData) return false;\n\n            const text = event.clipboardData.getData(\"text/plain\");\n            const youtubeRegex = /(?:https?:\\/\\/)?(?:www\\.)?(?:youtube\\.com\\/watch\\?v=|youtu\\.be\\/)([^&\\s]+)/;\n            const match = text.match(youtubeRegex);\n\n            if (match) {\n              const videoId = match[1];\n              const embedUrl = `https://www.youtube.com/embed/${videoId}`;\n\n              view.dispatch(\n                view.state.tr.replaceSelectionWith(view.state.schema.nodes.youtube.create({ src: embedUrl }))\n              );\n\n              return true;\n            }\n\n            return false;\n          },\n        },\n      }),\n    ];\n  },\n});\n\ninterface CustomTiptapEditorProps {\n  content?: string;\n  initialContent?: string;\n  onChange?: (content: string) => void;\n  onEditorReady?: (editor: Editor) => void;\n  placeholder?: string;\n  onEditorUpdate?: (newContent: string) => void;\n  showMenuBar?: boolean; // 메뉴바 표시 여부 (기본값: true)\n  readOnly?: boolean; // 읽기 전용 모드 (기본값: false)\n  enableImageUpload?: boolean; // 이미지 업로드 기능 활성화 여부 (기본값: true)\n  height?: string | number; // 에디터 높이 (기본값: 300px)\n  hideBorder?: boolean; // 보더 숨김 여부 (기본값: false)\n}\n\nconst CustomTiptapEditor = ({\n  content,\n  initialContent = \"\",\n  onChange,\n  onEditorReady,\n  placeholder,\n  onEditorUpdate,\n  showMenuBar = true,\n  readOnly = false,\n  enableImageUpload = true,\n  height = 300,\n  hideBorder = false,\n}: CustomTiptapEditorProps) => {\n  const editor = useEditor({\n    extensions: [\n      StarterKit.configure({\n        // StarterKit의 기본 Heading, Bold 등 외 추가/제외 설정 가능\n        // 예: heading: { levels: [1, 2, 3] }\n        // 기본적으로 Bold, Italic, Strike, Code, Paragraph, Blockquote, BulletList, OrderedList 등 포함\n        gapcursor: false,\n        // Underline과 Link는 별도로 추가하므로 StarterKit에서 제외\n        link: false, // Link extension을 StarterKit에서 제외\n        underline: false, // Underline extension을 StarterKit에서 제외\n      }),\n      Highlight,\n      TextAlign.configure({\n        types: [\"heading\", \"paragraph\"], // 정렬을 적용할 노드 타입 지정\n      }),\n      // TextStyle, // FontFamily, FontSize 사용을 위해 필요\n      FontFamily,\n      FontSize, // 커스텀 FontSize 확장 사용\n      Link.configure({\n        openOnClick: true, // 링크 클릭 시 새 탭에서 열기\n        autolink: true, // URL 자동 링크 변환\n        HTMLAttributes: {\n          rel: \"noopener noreferrer\",\n          target: \"_blank\",\n        },\n      }),\n      Underline,\n      GapCursor,\n      CustomImage.configure({\n        inline: true,\n        allowBase64: true,\n      }),\n      ImageResize.configure({\n        // 이미지 크기 제한 해제 - 사용자가 자유롭게 조절할 수 있도록\n        // minWidth: 100, // 최소 너비 제한 해제\n        // maxWidth: 200, // 최대 너비 제한 해제  \n        // autoHeight: true, // 높이는 자동으로 맞춰주기\n      }),\n      YouTube,\n      YouTubeExtension,\n    ],\n    content: content || initialContent,\n    immediatelyRender: false,\n    editable: !readOnly, // 읽기 전용 모드 설정\n    onUpdate: ({ editor }) => {\n      if (!readOnly) { // 읽기 전용이 아닐 때만 onChange 실행\n        const html = editor.getHTML();\n        if (onChange) {\n          onChange(html);\n        }\n        if (onEditorUpdate) {\n          onEditorUpdate(html);\n        }\n      }\n    },\n    editorProps: {\n      attributes: {\n        // 에디터 자체에 클래스 추가 가능\n        class: \"prose prose-sm sm:prose lg:prose-lg xl:prose-2xl mx-auto focus:outline-none\",\n      },\n      handleDrop: (view, event, slice, moved) => {\n        // 이미지 업로드가 비활성화된 경우 드래그앤드롭 처리하지 않음\n        if (!enableImageUpload) {\n          return false;\n        }\n\n        event.preventDefault();\n        const files = event.dataTransfer?.files;\n\n        if (files && files.length) {\n          // 여러 이미지 파일을 처리하기 위해 Array.from(files)를 사용\n          const imageFiles = Array.from(files).filter((file) => file.type.startsWith(\"image/\"));\n\n          imageFiles.forEach((imageFile) => {\n            // 각 이미지를 Base64로 변환하여 URL 가져오기\n            uploadImage(imageFile).then((imageUrl) => {\n              // URL로 이미지를 에디터에 삽입\n              view.dispatch(\n                view.state.tr.replaceSelectionWith(view.state.schema.nodes.image.create({ src: imageUrl }))\n              );\n            });\n          });\n        }\n\n        return true; // 드롭 처리 완료\n      },\n    },\n  });\n\n  // setLink 함수 (MenuBar와 BubbleMenu에서 사용)\n  const setLink = useCallback(() => {\n    if (!editor) return;\n    const previousUrl = editor.getAttributes(\"link\").href;\n    const url = window.prompt(\"URL을 입력하세요\", previousUrl);\n    if (url === null) return;\n    if (url === \"\") {\n      editor.chain().focus().extendMarkRange(\"link\").unsetLink().run();\n      return;\n    }\n    editor.chain().focus().extendMarkRange(\"link\").setLink({ href: url }).run();\n  }, [editor]);\n\n  // 커스텀 BubbleMenu 컴포넌트\n  const CustomBubbleMenu = () => {\n    const [showBubbleMenu, setShowBubbleMenu] = useState(false);\n    const { refs, floatingStyles } = useFloating({\n      middleware: [offset(10), flip(), shift()],\n      whileElementsMounted: autoUpdate,\n    });\n\n    useEffect(() => {\n      if (!editor) return;\n\n      const updateBubbleMenu = () => {\n        const { selection } = editor.state;\n        const { from, to } = selection;\n        \n        if (from === to) {\n          setShowBubbleMenu(false);\n          return;\n        }\n\n        setShowBubbleMenu(true);\n        \n        // selection의 DOM 위치를 참조로 설정\n        const domSelection = window.getSelection();\n        if (domSelection && domSelection.rangeCount > 0) {\n          const range = domSelection.getRangeAt(0);\n          const rect = range.getBoundingClientRect();\n          \n          // 가상 참조 엘리먼트 생성\n          refs.setReference({\n            getBoundingClientRect: () => rect,\n          });\n        }\n      };\n\n      editor.on('selectionUpdate', updateBubbleMenu);\n      editor.on('update', updateBubbleMenu);\n\n      return () => {\n        editor.off('selectionUpdate', updateBubbleMenu);\n        editor.off('update', updateBubbleMenu);\n      };\n    }, [refs]);\n\n    if (!showBubbleMenu || !editor) return null;\n\n    return (\n      <div\n        ref={refs.setFloating}\n        style={floatingStyles}\n        className=\"tiptap-bubble-menu\"\n      >\n        <button\n          onClick={() => editor.chain().focus().toggleBold().run()}\n          className={editor.isActive(\"bold\") ? \"is-active\" : \"\"}\n        >\n          <MdFormatBold />\n        </button>\n        <button\n          onClick={() => editor.chain().focus().toggleItalic().run()}\n          className={editor.isActive(\"italic\") ? \"is-active\" : \"\"}\n        >\n          <MdFormatItalic />\n        </button>\n        <button\n          onClick={() => editor.chain().focus().toggleUnderline().run()}\n          className={editor.isActive(\"underline\") ? \"is-active\" : \"\"}\n        >\n          <MdFormatUnderlined />\n        </button>\n        <button\n          onClick={() => editor.chain().focus().toggleStrike().run()}\n          className={editor.isActive(\"strike\") ? \"is-active\" : \"\"}\n        >\n          <MdStrikethroughS />\n        </button>\n        <button onClick={setLink} className={editor.isActive(\"link\") ? \"is-active\" : \"\"}>\n          <MdLink />\n        </button>\n        <button\n          onClick={() => editor.chain().focus().toggleHighlight().run()}\n          className={editor.isActive(\"highlight\") ? \"is-active\" : \"\"}\n        >\n          <MdHighlight />\n        </button>\n        <button\n          onClick={() => editor.chain().focus().setTextAlign(\"left\").run()}\n          className={editor.isActive({ textAlign: \"left\" }) ? \"is-active\" : \"\"}\n        >\n          <MdFormatAlignLeft />\n        </button>\n        <button\n          onClick={() => editor.chain().focus().setTextAlign(\"center\").run()}\n          className={editor.isActive({ textAlign: \"center\" }) ? \"is-active\" : \"\"}\n        >\n          <MdFormatAlignCenter />\n        </button>\n        <button\n          onClick={() => editor.chain().focus().setTextAlign(\"right\").run()}\n          className={editor.isActive({ textAlign: \"right\" }) ? \"is-active\" : \"\"}\n        >\n          <MdFormatAlignRight />\n        </button>\n      </div>\n    );\n  };\n\n  // 에디터가 준비되면 콜백 호출\n  useEffect(() => {\n    if (editor && onEditorReady) {\n      onEditorReady(editor);\n    }\n  }, [editor, onEditorReady]);\n\n  // 에디터 컨테이너 클릭 시 포커스 핸들러\n  const handleContainerClick = useCallback((e: React.MouseEvent) => {\n    // 에디터 영역이 아닌 컨테이너 빈 공간을 클릭했을 때만 포커스\n    const target = e.target as HTMLElement;\n    if (target.classList.contains('editor-container') || \n        target.classList.contains('tiptap-editor-content') ||\n        target.closest('.tiptap-editor-content')) {\n      editor?.commands.focus();\n    }\n  }, [editor]);\n\n  if (!editor) {\n    return null;\n  }\n\n  // 높이 값 처리 (문자열이면 그대로, 숫자면 px 추가)\n  const editorHeight = typeof height === 'number' ? `${height}px` : height;\n  const editorContentHeight = typeof height === 'number' ? `${height - 50}px` : `calc(${height} - 50px)`;\n\n  return (\n    <div \n      className={`editor-container ${hideBorder ? 'hide-border' : ''}`}\n      onClick={handleContainerClick}\n      style={{ \n        minHeight: editorHeight, \n        height: editorHeight,\n        border: hideBorder ? 'none' : undefined,\n        outline: hideBorder ? 'none' : undefined\n      }}\n    >\n      {showMenuBar && <MenuBar editor={editor} enableImageUpload={enableImageUpload} />}\n      <CustomBubbleMenu />\n      <EditorContent \n        editor={editor} \n        className={`tiptap-editor-content ${hideBorder ? 'hide-border' : ''}`}\n        style={{ \n          minHeight: editorContentHeight, \n          height: editorContentHeight,\n          border: hideBorder ? 'none' : undefined,\n          outline: hideBorder ? 'none' : undefined\n        }}\n      />\n    </div>\n  );\n};\n\nexport default CustomTiptapEditor;\n"
        }
    ]
}