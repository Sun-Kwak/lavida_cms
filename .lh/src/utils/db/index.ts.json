{
    "sourceFile": "src/utils/db/index.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 14,
            "patches": [
                {
                    "date": 1761368450696,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1761368896107,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -197,8 +197,318 @@\n    */\n   get dbVersion(): number {\n     return this.version;\n   }\n+\n+  // ===============================\n+  // Backward Compatibility Layer\n+  // 기존 API 호환성을 위한 메서드들\n+  // ===============================\n+\n+  // Branch 관련 호환성 메서드\n+  async getAllBranches() {\n+    return await this.branch.getAllBranches();\n+  }\n+\n+  async addBranch(branchData: Omit<import('./types').Branch, 'id' | 'createdAt' | 'updatedAt'>) {\n+    return await this.branch.addBranch(branchData);\n+  }\n+\n+  async updateBranch(id: string, updates: Partial<import('./types').Branch>) {\n+    return await this.branch.updateBranch(id, updates);\n+  }\n+\n+  async deleteBranch(id: string) {\n+    return await this.branch.deleteBranch(id);\n+  }\n+\n+  async getBranchById(id: string) {\n+    return await this.branch.getBranchById(id);\n+  }\n+\n+  async getOrCreateBranchByName(name: string) {\n+    return await this.branch.getOrCreateBranchByName(name);\n+  }\n+\n+  // Staff 관련 호환성 메서드\n+  async getAllStaff() {\n+    return await this.staff.getAllStaff();\n+  }\n+\n+  async addStaff(staffData: Omit<import('./types').Staff, 'id' | 'createdAt' | 'updatedAt'>) {\n+    return await this.staff.addStaff(staffData);\n+  }\n+\n+  async updateStaff(id: string, updates: Partial<import('./types').Staff>) {\n+    return await this.staff.updateStaff(id, updates);\n+  }\n+\n+  async deleteStaff(id: string) {\n+    return await this.staff.deleteStaff(id);\n+  }\n+\n+  async getStaffById(id: string) {\n+    return await this.staff.getStaffById(id);\n+  }\n+\n+  async getStaffByLoginId(loginId: string) {\n+    return await this.staff.getStaffByLoginId(loginId);\n+  }\n+\n+  // Member 관련 호환성 메서드\n+  async getAllMembers() {\n+    return await this.member.getAllMembers();\n+  }\n+\n+  async addMember(memberData: Omit<import('./types').Member, 'id' | 'createdAt' | 'updatedAt'>) {\n+    return await this.member.addMember(memberData);\n+  }\n+\n+  async updateMember(id: string, updates: Partial<import('./types').Member>) {\n+    return await this.member.updateMember(id, updates);\n+  }\n+\n+  async deleteMember(id: string) {\n+    return await this.member.deleteMember(id);\n+  }\n+\n+  async getMemberById(id: string) {\n+    return await this.member.getMemberById(id);\n+  }\n+\n+  async searchMembers(searchTerm: string) {\n+    return await this.member.searchMembers(searchTerm);\n+  }\n+\n+  async checkMemberDuplicate(phone: string, email?: string) {\n+    return await this.member.checkMemberDuplicate(phone, email);\n+  }\n+\n+  // Product 관련 호환성 메서드\n+  async getAllProducts() {\n+    return await this.product.getAllProducts();\n+  }\n+\n+  async addProduct(productData: Omit<import('./types').Product, 'id' | 'createdAt' | 'updatedAt'>) {\n+    return await this.product.addProduct(productData);\n+  }\n+\n+  async updateProduct(id: string, updates: Partial<import('./types').Product>) {\n+    return await this.product.updateProduct(id, updates);\n+  }\n+\n+  async deleteProduct(id: string) {\n+    return await this.product.deleteProduct(id);\n+  }\n+\n+  async getProductById(id: string) {\n+    return await this.product.getProductById(id);\n+  }\n+\n+  async getProductsByBranch(branchId: string) {\n+    return await this.product.getProductsByBranch(branchId);\n+  }\n+\n+  async getProductsByProgram(programId: string) {\n+    return await this.product.getProductsByProgram(programId);\n+  }\n+\n+  // Program 관련 호환성 메서드\n+  async getAllPrograms() {\n+    return await this.program.getAllPrograms();\n+  }\n+\n+  async addProgram(programData: Omit<import('./types').Program, 'id' | 'createdAt' | 'updatedAt'>) {\n+    return await this.program.addProgram(programData);\n+  }\n+\n+  async updateProgram(id: string, updates: Partial<import('./types').Program>) {\n+    return await this.program.updateProgram(id, updates);\n+  }\n+\n+  async deleteProgram(id: string) {\n+    return await this.program.deleteProgram(id);\n+  }\n+\n+  async getProgramById(id: string) {\n+    const programs = await this.program.getAllPrograms();\n+    return programs.find(p => p.id === id) || null;\n+  }\n+\n+  async getProgramsByBranch(branchId: string) {\n+    const products = await this.product.getAllProducts();\n+    const programIds = Array.from(new Set(products.filter(p => p.branchId === branchId).map(p => p.programId)));\n+    const programs = await this.program.getAllPrograms();\n+    return programs.filter(p => programIds.includes(p.id));\n+  }\n+\n+  // Payment 관련 호환성 메서드\n+  async getAllPayments() {\n+    return await this.payment.getAllPayments();\n+  }\n+\n+  async addPayment(paymentData: Omit<import('./types').Payment, 'id' | 'createdAt' | 'updatedAt'>) {\n+    return await this.payment.addPayment(paymentData);\n+  }\n+\n+  async updatePayment(id: string, updates: Partial<import('./types').Payment>) {\n+    return await this.payment.updatePayment(id, updates);\n+  }\n+\n+  async deletePayment(id: string) {\n+    return await this.payment.deletePayment(id);\n+  }\n+\n+  async getPaymentById(id: string) {\n+    return await this.payment.getPaymentById(id);\n+  }\n+\n+  async getPaymentsByMember(memberId: string) {\n+    return await this.payment.getPaymentsByMember(memberId);\n+  }\n+\n+  async getPaymentsByBranch(branchId: string) {\n+    const payments = await this.payment.getAllPayments();\n+    return payments.filter(p => p.branchId === branchId);\n+  }\n+\n+  // Point 관련 호환성 메서드\n+  async getAllPoints() {\n+    return await this.point.getAllPoints();\n+  }\n+\n+  async addPoint(pointData: import('./types').Point) {\n+    return await this.point.addPoint(pointData);\n+  }\n+\n+  async updatePoint(id: string, updates: Partial<import('./types').Point>) {\n+    const points = await this.point.getAllPoints();\n+    const point = points.find(p => p.id === id);\n+    if (!point) {\n+      throw new Error('포인트를 찾을 수 없습니다.');\n+    }\n+    // Point 업데이트 로직을 대체 구현\n+    const updatedPoint = { ...point, ...updates, updatedAt: new Date() };\n+    return await this.point.addPoint(updatedPoint);\n+  }\n+\n+  async deletePoint(id: string) {\n+    // Point 삭제는 직접 구현 필요 (서비스에 없음)\n+    console.warn('Point 삭제는 지원되지 않습니다.');\n+    return false;\n+  }\n+\n+  async getPointById(id: string) {\n+    const points = await this.point.getAllPoints();\n+    return points.find(p => p.id === id) || null;\n+  }\n+\n+  async getPointsByMember(memberId: string) {\n+    return await this.point.getPointsByMember(memberId);\n+  }\n+\n+  // Course 관련 호환성 메서드\n+  async getAllCourseEnrollments() {\n+    return await this.course.getAllCourseEnrollments();\n+  }\n+\n+  async addCourseEnrollment(enrollmentData: Omit<import('./types').CourseEnrollment, 'id' | 'createdAt' | 'updatedAt'>) {\n+    return await this.course.addCourseEnrollment(enrollmentData);\n+  }\n+\n+  async updateCourseEnrollment(id: string, updates: Partial<import('./types').CourseEnrollment>) {\n+    return await this.course.updateCourseEnrollment(id, updates);\n+  }\n+\n+  async deleteCourseEnrollment(id: string) {\n+    return await this.course.deleteCourseEnrollment(id);\n+  }\n+\n+  async getCourseEnrollmentById(id: string) {\n+    return await this.course.getCourseEnrollmentById(id);\n+  }\n+\n+  async getCourseEnrollmentsByMember(memberId: string) {\n+    return await this.course.getCourseEnrollmentsByMember(memberId);\n+  }\n+\n+  async getCourseEnrollmentsByBranch(branchId: string) {\n+    return await this.course.getCourseEnrollmentsByBranch(branchId);\n+  }\n+\n+  // Terms 관련 호환성 메서드\n+  async getAllTermsDocuments() {\n+    return await this.terms.getAllTermsDocuments();\n+  }\n+\n+  async addTermsDocument(termsData: Omit<import('./types').TermsDocument, 'id' | 'createdAt' | 'updatedAt'>) {\n+    return await this.terms.addTermsDocument(termsData);\n+  }\n+\n+  async updateTermsDocument(id: string, updates: Partial<import('./types').TermsDocument>) {\n+    return await this.terms.updateTermsDocument(id, updates);\n+  }\n+\n+  async deleteTermsDocument(id: string) {\n+    return await this.terms.deleteTermsDocument(id);\n+  }\n+\n+  async getTermsDocumentById(id: string) {\n+    return await this.terms.getTermsDocumentById(id);\n+  }\n+\n+  async getLatestTermsDocument(type: string) {\n+    // 타입을 명시적으로 캐스팅\n+    const validType = type as \"privacy_policy\" | \"terms_of_service\" | \"business_info\" | \"marketing_consent\" | \"member_terms\" | \"contract\";\n+    return await this.terms.getActiveTermsDocument(validType);\n+  }\n+\n+  // Holiday 관련 호환성 메서드 (HolidaySettings로 대체)\n+  async getAllHolidays() {\n+    // HolidayService에는 전체 조회가 없으므로 최근 1년 범위로 조회\n+    const now = new Date();\n+    const startDate = new Date(now.getFullYear() - 1, 0, 1).toISOString().split('T')[0];\n+    const endDate = new Date(now.getFullYear() + 1, 11, 31).toISOString().split('T')[0];\n+    return await this.holiday.getHolidaySettingsByDateRange(startDate, endDate);\n+  }\n+\n+  async addHoliday(holidayData: import('./types').HolidaySettings) {\n+    return await this.holiday.saveHolidaySettings([holidayData]);\n+  }\n+\n+  async updateHoliday(id: string, updates: Partial<import('./types').HolidaySettings>) {\n+    // HolidayService는 개별 업데이트가 없으므로 조회 후 전체 저장\n+    const allHolidays = await this.getAllHolidays();\n+    const target = allHolidays.find(h => h.id === id);\n+    if (!target) {\n+      throw new Error('휴일 설정을 찾을 수 없습니다.');\n+    }\n+    const updated = { ...target, ...updates, updatedAt: new Date() };\n+    return await this.holiday.saveHolidaySettings([updated]);\n+  }\n+\n+  async deleteHoliday(id: string) {\n+    // HolidayService에는 삭제 메서드가 없음\n+    console.warn('Holiday 삭제는 직접 지원되지 않습니다.');\n+    return false;\n+  }\n+\n+  async getHolidayById(id: string) {\n+    const allHolidays = await this.getAllHolidays();\n+    return allHolidays.find(h => h.id === id) || null;\n+  }\n+\n+  async getHolidaysByYear(year: number) {\n+    const startDate = new Date(year, 0, 1).toISOString().split('T')[0];\n+    const endDate = new Date(year, 11, 31).toISOString().split('T')[0];\n+    return await this.holiday.getHolidaySettingsByDateRange(startDate, endDate);\n+  }\n+\n+  async isHoliday(date: Date) {\n+    const dateString = date.toISOString().split('T')[0];\n+    const holidays = await this.holiday.getHolidaySettingsByDate(dateString);\n+    return holidays.length > 0;\n+  }\n }\n \n // 싱글톤 인스턴스 생성 및 export\n export const dbManager = new IndexedDBManager();\n"
                },
                {
                    "date": 1761369527636,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -507,8 +507,13 @@\n     const dateString = date.toISOString().split('T')[0];\n     const holidays = await this.holiday.getHolidaySettingsByDate(dateString);\n     return holidays.length > 0;\n   }\n+\n+  // Staff migration 관련 호환성 메서드\n+  async migrateStaffActiveStatus() {\n+    return await this.staff.migrateStaffActiveStatus();\n+  }\n }\n \n // 싱글톤 인스턴스 생성 및 export\n export const dbManager = new IndexedDBManager();\n"
                },
                {
                    "date": 1761369747758,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -253,8 +253,12 @@\n   async getStaffByLoginId(loginId: string) {\n     return await this.staff.getStaffByLoginId(loginId);\n   }\n \n+  async toggleStaffStatus(id: string) {\n+    return await this.staff.toggleStaffStatus(id);\n+  }\n+\n   // Member 관련 호환성 메서드\n   async getAllMembers() {\n     return await this.member.getAllMembers();\n   }\n@@ -434,8 +438,16 @@\n   async getCourseEnrollmentsByBranch(branchId: string) {\n     return await this.course.getCourseEnrollmentsByBranch(branchId);\n   }\n \n+  async getUnpaidMetaInfo() {\n+    return await this.course.getUnpaidMetaInfo();\n+  }\n+\n+  async getMemberUnpaidTotal(memberId: string) {\n+    return await this.course.getMemberUnpaidTotal(memberId);\n+  }\n+\n   // Terms 관련 호환성 메서드\n   async getAllTermsDocuments() {\n     return await this.terms.getAllTermsDocuments();\n   }\n"
                },
                {
                    "date": 1761371100658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -379,8 +379,17 @@\n   async getAllPoints() {\n     return await this.point.getAllPoints();\n   }\n \n+  // 새로운 포인트 시스템에서만 포인트 내역 조회\n+  async getAllPointsUnified() {\n+    return await this.point.getAllPointsFromTransactions();\n+  }\n+\n+  async getMemberPointStats(memberId: string) {\n+    return await this.point.getMemberPointStatsUnified(memberId);\n+  }\n+\n   async addPoint(pointData: import('./types').Point) {\n     return await this.point.addPoint(pointData);\n   }\n \n"
                },
                {
                    "date": 1761376552548,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -228,8 +228,17 @@\n   async getOrCreateBranchByName(name: string) {\n     return await this.branch.getOrCreateBranchByName(name);\n   }\n \n+  // 라커 가격 관련 메서드\n+  async getLockerPrice(branchId: string) {\n+    return await this.branch.getLockerPrice(branchId);\n+  }\n+\n+  async updateLockerPrice(branchId: string, price: number) {\n+    return await this.branch.updateLockerPrice(branchId, price);\n+  }\n+\n   // Staff 관련 호환성 메서드\n   async getAllStaff() {\n     return await this.staff.getAllStaff();\n   }\n"
                },
                {
                    "date": 1761377685381,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,8 +11,9 @@\n import { PaymentService, OrderService } from './PaymentService';\n import { PointService } from './PointService';\n import { CourseService } from './CourseService';\n import { TermsService } from './TermsService';\n+import { LockerService } from './LockerService';\n import { BaseDBManager } from './BaseDBManager';\n \n // 타입 정의 export\n export * from './types';\n@@ -28,8 +29,9 @@\n export { PaymentService, OrderService } from './PaymentService';\n export { PointService } from './PointService';\n export { CourseService } from './CourseService';\n export { TermsService } from './TermsService';\n+export { LockerService } from './LockerService';\n \n /**\n  * 통합 데이터베이스 매니저\n  * 모든 서비스들을 하나의 인스턴스에서 접근할 수 있도록 제공\n@@ -45,8 +47,9 @@\n   public order: OrderService;\n   public point: PointService;\n   public course: CourseService;\n   public terms: TermsService;\n+  public locker: LockerService;\n \n   constructor() {\n     super();\n     \n@@ -61,8 +64,9 @@\n     this.order = new OrderService();\n     this.point = new PointService();\n     this.course = new CourseService();\n     this.terms = new TermsService();\n+    this.locker = new LockerService();\n \n     // 데이터 마이그레이션 실행\n     this.runMigrations();\n   }\n@@ -542,8 +546,57 @@\n   // Staff migration 관련 호환성 메서드\n   async migrateStaffActiveStatus() {\n     return await this.staff.migrateStaffActiveStatus();\n   }\n+\n+  // Locker 관련 호환성 메서드\n+  async getAllLockers() {\n+    return await this.locker.getAllLockers();\n+  }\n+\n+  async getLockersByBranch(branchId: string) {\n+    return await this.locker.getLockersByBranch(branchId);\n+  }\n+\n+  async addLocker(lockerData: Omit<import('./types').Locker, 'id' | 'createdAt' | 'updatedAt'>) {\n+    return await this.locker.addLocker(lockerData);\n+  }\n+\n+  async addMultipleLockers(lockersData: Omit<import('./types').Locker, 'id' | 'createdAt' | 'updatedAt'>[]) {\n+    return await this.locker.addMultipleLockers(lockersData);\n+  }\n+\n+  async updateLocker(id: string, updates: Partial<import('./types').Locker>) {\n+    return await this.locker.updateLocker(id, updates);\n+  }\n+\n+  async deleteLocker(id: string) {\n+    return await this.locker.deleteLocker(id);\n+  }\n+\n+  async getLockerById(id: string) {\n+    return await this.locker.getLockerById(id);\n+  }\n+\n+  async getLockersByUser(userId: string) {\n+    return await this.locker.getLockersByUser(userId);\n+  }\n+\n+  async assignLockerToUser(lockerId: string, userId: string, userName: string, months: number, paymentId?: string) {\n+    return await this.locker.assignLockerToUser(lockerId, userId, userName, months, paymentId);\n+  }\n+\n+  async unassignLocker(lockerId: string) {\n+    return await this.locker.unassignLocker(lockerId);\n+  }\n+\n+  async getExpiredLockers() {\n+    return await this.locker.getExpiredLockers();\n+  }\n+\n+  async checkLockerNumberDuplicate(branchId: string, number: string, excludeId?: string) {\n+    return await this.locker.checkLockerNumberDuplicate(branchId, number, excludeId);\n+  }\n }\n \n // 싱글톤 인스턴스 생성 및 export\n export const dbManager = new IndexedDBManager();\n"
                },
                {
                    "date": 1761378612752,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -581,13 +581,13 @@\n     return await this.locker.getLockersByUser(userId);\n   }\n \n   async assignLockerToUser(lockerId: string, userId: string, userName: string, months: number, paymentId?: string) {\n-    return await this.locker.assignLockerToUser(lockerId, userId, userName, months, paymentId);\n+    return await this.locker.assignLockerToUser(lockerId, userId, userName, months, paymentId, this.member);\n   }\n \n   async unassignLocker(lockerId: string) {\n-    return await this.locker.unassignLocker(lockerId);\n+    return await this.locker.unassignLocker(lockerId, this.member);\n   }\n \n   async getExpiredLockers() {\n     return await this.locker.getExpiredLockers();\n"
                },
                {
                    "date": 1761450291608,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -547,8 +547,12 @@\n   async migrateStaffActiveStatus() {\n     return await this.staff.migrateStaffActiveStatus();\n   }\n \n+  async checkDuplicateStaff(loginId: string, email: string, phone: string) {\n+    return await this.staff.checkDuplicateStaff(loginId, email, phone);\n+  }\n+\n   // Locker 관련 호환성 메서드\n   async getAllLockers() {\n     return await this.locker.getAllLockers();\n   }\n"
                },
                {
                    "date": 1761450556373,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -542,8 +542,16 @@\n     const holidays = await this.holiday.getHolidaySettingsByDate(dateString);\n     return holidays.length > 0;\n   }\n \n+  async getHolidaySettingsByDateRange(startDate: string, endDate: string) {\n+    return await this.holiday.getHolidaySettingsByDateRange(startDate, endDate);\n+  }\n+\n+  async saveHolidaySettings(settings: Omit<import('./types').HolidaySettings, 'id' | 'createdAt' | 'updatedAt'>[]) {\n+    return await this.holiday.saveHolidaySettings(settings);\n+  }\n+\n   // Staff migration 관련 호환성 메서드\n   async migrateStaffActiveStatus() {\n     return await this.staff.migrateStaffActiveStatus();\n   }\n"
                },
                {
                    "date": 1761451696597,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,9 @@\n \n // 필요한 imports를 먼저 선언\n import { BranchService } from './BranchService';\n import { StaffService } from './StaffService';\n-import { ProgramService, ProductService, HolidayService } from './ProgramService';\n+import { ProgramService, ProductService, HolidayService, WeeklyHolidayService } from './ProgramService';\n import { MemberService } from './MemberService';\n import { PaymentService, OrderService } from './PaymentService';\n import { PointService } from './PointService';\n import { CourseService } from './CourseService';\n@@ -41,8 +41,9 @@\n   public staff: StaffService;\n   public program: ProgramService;\n   public product: ProductService;\n   public holiday: HolidayService;\n+  public weeklyHoliday: WeeklyHolidayService;\n   public member: MemberService;\n   public payment: PaymentService;\n   public order: OrderService;\n   public point: PointService;\n@@ -58,8 +59,9 @@\n     this.staff = new StaffService();\n     this.program = new ProgramService();\n     this.product = new ProductService();\n     this.holiday = new HolidayService();\n+    this.weeklyHoliday = new WeeklyHolidayService();\n     this.member = new MemberService();\n     this.payment = new PaymentService();\n     this.order = new OrderService();\n     this.point = new PointService();\n@@ -550,8 +552,45 @@\n   async saveHolidaySettings(settings: Omit<import('./types').HolidaySettings, 'id' | 'createdAt' | 'updatedAt'>[]) {\n     return await this.holiday.saveHolidaySettings(settings);\n   }\n \n+  // 주별 휴일설정 관련 메서드\n+  async saveWeeklyHolidaySettings(settings: Omit<import('./types').WeeklyHolidaySettings, 'id' | 'createdAt' | 'updatedAt'>[]) {\n+    return await this.weeklyHoliday.saveWeeklyHolidaySettings(settings);\n+  }\n+\n+  async getWeeklyHolidaySettingsByStaff(staffId: string) {\n+    return await this.weeklyHoliday.getWeeklyHolidaySettingsByStaff(staffId);\n+  }\n+\n+  async getWeeklyHolidaySettingsByStaffAndWeek(staffId: string, weekStartDate: string) {\n+    return await this.weeklyHoliday.getWeeklyHolidaySettingsByStaffAndWeek(staffId, weekStartDate);\n+  }\n+\n+  async getWeeklyHolidaySettingsByWeek(weekStartDate: string) {\n+    return await this.weeklyHoliday.getWeeklyHolidaySettingsByWeek(weekStartDate);\n+  }\n+\n+  async deleteWeeklyHolidaySettings(id: string) {\n+    return await this.weeklyHoliday.deleteWeeklyHolidaySettings(id);\n+  }\n+\n+  async deleteWeeklyHolidaySettingsByStaff(staffId: string) {\n+    return await this.weeklyHoliday.deleteWeeklyHolidaySettingsByStaff(staffId);\n+  }\n+\n+  async isHolidayByDate(staffId: string, date: string) {\n+    return await this.weeklyHoliday.isHolidayByDate(staffId, date);\n+  }\n+\n+  getNextMondayDate() {\n+    return this.weeklyHoliday.getNextMondayDate();\n+  }\n+\n+  getCurrentMondayDate() {\n+    return this.weeklyHoliday.getCurrentMondayDate();\n+  }\n+\n   // Staff migration 관련 호환성 메서드\n   async migrateStaffActiveStatus() {\n     return await this.staff.migrateStaffActiveStatus();\n   }\n"
                },
                {
                    "date": 1761455802437,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,9 @@\n \n // 필요한 imports를 먼저 선언\n import { BranchService } from './BranchService';\n import { StaffService } from './StaffService';\n-import { ProgramService, ProductService, HolidayService, WeeklyHolidayService } from './ProgramService';\n+import { ProgramService, ProductService, HolidayService, WeeklyHolidayService, ScheduleEventService } from './ProgramService';\n import { MemberService } from './MemberService';\n import { PaymentService, OrderService } from './PaymentService';\n import { PointService } from './PointService';\n import { CourseService } from './CourseService';\n@@ -23,9 +23,9 @@\n \n // 개별 서비스 클래스들 export\n export { BranchService } from './BranchService';\n export { StaffService } from './StaffService';\n-export { ProgramService, ProductService, HolidayService } from './ProgramService';\n+export { ProgramService, ProductService, HolidayService, ScheduleEventService } from './ProgramService';\n export { MemberService } from './MemberService';\n export { PaymentService, OrderService } from './PaymentService';\n export { PointService } from './PointService';\n export { CourseService } from './CourseService';\n@@ -42,8 +42,9 @@\n   public program: ProgramService;\n   public product: ProductService;\n   public holiday: HolidayService;\n   public weeklyHoliday: WeeklyHolidayService;\n+  public scheduleEvent: ScheduleEventService;\n   public member: MemberService;\n   public payment: PaymentService;\n   public order: OrderService;\n   public point: PointService;\n@@ -60,8 +61,9 @@\n     this.program = new ProgramService();\n     this.product = new ProductService();\n     this.holiday = new HolidayService();\n     this.weeklyHoliday = new WeeklyHolidayService();\n+    this.scheduleEvent = new ScheduleEventService();\n     this.member = new MemberService();\n     this.payment = new PaymentService();\n     this.order = new OrderService();\n     this.point = new PointService();\n@@ -646,8 +648,29 @@\n \n   async checkLockerNumberDuplicate(branchId: string, number: string, excludeId?: string) {\n     return await this.locker.checkLockerNumberDuplicate(branchId, number, excludeId);\n   }\n+\n+  // ScheduleEvent 관련 호환성 메서드\n+  async saveScheduleEvents(events: Omit<import('./types').ScheduleEvent, 'id' | 'createdAt' | 'updatedAt'>[]) {\n+    return await this.scheduleEvent.saveScheduleEvents(events);\n+  }\n+\n+  async deleteScheduleEventsBySource(sourceType: string, sourceId?: string) {\n+    return await this.scheduleEvent.deleteScheduleEventsBySource(sourceType, sourceId);\n+  }\n+\n+  async getScheduleEventsByStaff(staffId: string, startDate?: Date, endDate?: Date) {\n+    return await this.scheduleEvent.getScheduleEventsByStaff(staffId, startDate, endDate);\n+  }\n+\n+  async getAllScheduleEvents(startDate?: Date, endDate?: Date) {\n+    return await this.scheduleEvent.getAllScheduleEvents(startDate, endDate);\n+  }\n+\n+  async deleteScheduleEvent(eventId: string) {\n+    return await this.scheduleEvent.deleteScheduleEvent(eventId);\n+  }\n }\n \n // 싱글톤 인스턴스 생성 및 export\n export const dbManager = new IndexedDBManager();\n"
                },
                {
                    "date": 1761456678687,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,684 @@\n+/**\n+ * IndexedDB 통합 매니저\n+ * 모든 개별 서비스들을 통합하여 하나의 인터페이스로 제공\n+ */\n+\n+// 필요한 imports를 먼저 선언\n+import { BranchService } from './BranchService';\n+import { StaffService } from './StaffService';\n+import { ProgramService, ProductService, HolidayService, WeeklyHolidayService, ScheduleEventService } from './ProgramService';\n+import { MemberService } from './MemberService';\n+import { PaymentService, OrderService } from './PaymentService';\n+import { PointService } from './PointService';\n+import { CourseService } from './CourseService';\n+import { TermsService } from './TermsService';\n+import { LockerService } from './LockerService';\n+import { BaseDBManager } from './BaseDBManager';\n+\n+// 타입 정의 export\n+export * from './types';\n+\n+// 기본 클래스 export\n+export { BaseDBManager } from './BaseDBManager';\n+\n+// 개별 서비스 클래스들 export\n+export { BranchService } from './BranchService';\n+export { StaffService } from './StaffService';\n+export { ProgramService, ProductService, HolidayService, ScheduleEventService } from './ProgramService';\n+export { MemberService } from './MemberService';\n+export { PaymentService, OrderService } from './PaymentService';\n+export { PointService } from './PointService';\n+export { CourseService } from './CourseService';\n+export { TermsService } from './TermsService';\n+export { LockerService } from './LockerService';\n+\n+/**\n+ * 통합 데이터베이스 매니저\n+ * 모든 서비스들을 하나의 인스턴스에서 접근할 수 있도록 제공\n+ */\n+export class IndexedDBManager extends BaseDBManager {\n+  public branch: BranchService;\n+  public staff: StaffService;\n+  public program: ProgramService;\n+  public product: ProductService;\n+  public holiday: HolidayService;\n+  public weeklyHoliday: WeeklyHolidayService;\n+  public scheduleEvent: ScheduleEventService;\n+  public member: MemberService;\n+  public payment: PaymentService;\n+  public order: OrderService;\n+  public point: PointService;\n+  public course: CourseService;\n+  public terms: TermsService;\n+  public locker: LockerService;\n+\n+  constructor() {\n+    super();\n+    \n+    // 각 서비스 인스턴스 생성\n+    this.branch = new BranchService();\n+    this.staff = new StaffService();\n+    this.program = new ProgramService();\n+    this.product = new ProductService();\n+    this.holiday = new HolidayService();\n+    this.weeklyHoliday = new WeeklyHolidayService();\n+    this.scheduleEvent = new ScheduleEventService();\n+    this.member = new MemberService();\n+    this.payment = new PaymentService();\n+    this.order = new OrderService();\n+    this.point = new PointService();\n+    this.course = new CourseService();\n+    this.terms = new TermsService();\n+    this.locker = new LockerService();\n+\n+    // 데이터 마이그레이션 실행\n+    this.runMigrations();\n+  }\n+\n+  /**\n+   * 통합 주문 처리 (서비스 간 협력이 필요한 복합 기능)\n+   */\n+  async processOrderWithPayments(orderData: import('./types').OrderProcessingData): Promise<string> {\n+    return await this.order.processOrderWithPayments(orderData, {\n+      productService: this.product,\n+      paymentService: this.payment,\n+      pointService: this.point,\n+      courseService: this.course\n+    });\n+  }\n+\n+  /**\n+   * 로그인 ID 중복 체크 (직원과 회원 모두 확인)\n+   */\n+  async checkLoginIdDuplicate(loginId: string): Promise<import('./types').LoginIdDuplicateCheckResult> {\n+    return await this.member.checkLoginIdDuplicate(\n+      loginId, \n+      (id: string) => this.staff.getStaffByLoginId(id)\n+    );\n+  }\n+\n+  /**\n+   * 회원 포인트 잔액 조회 (호환성 유지)\n+   */\n+  async getMemberPointBalance(memberId: string): Promise<number> {\n+    return await this.point.getMemberPointBalanceV2(memberId);\n+  }\n+\n+  /**\n+   * 전체 데이터 마이그레이션 실행\n+   */\n+  private async runMigrations(): Promise<void> {\n+    try {\n+      console.log('=== 데이터 마이그레이션 시작 ===');\n+      \n+      // 1. 직원 isActive 필드 마이그레이션\n+      await this.staff.migrateStaffActiveStatus();\n+      \n+      // 2. 포인트 데이터 마이그레이션\n+      await this.point.migratePointsToTransactions();\n+      \n+      // 3. 결제 데이터에 주문 ID 추가\n+      await this.migratePaymentsWithOrderId();\n+      \n+      console.log('=== 데이터 마이그레이션 완료 ===');\n+    } catch (error) {\n+      console.error('데이터 마이그레이션 실패:', error);\n+    }\n+  }\n+\n+  /**\n+   * 기존 결제 데이터에 orderId 추가 (역호환성)\n+   */\n+  private async migratePaymentsWithOrderId(): Promise<void> {\n+    try {\n+      console.log('결제 데이터 주문 ID 마이그레이션 시작...');\n+      \n+      const payments = await this.payment.getAllPayments();\n+      const paymentsWithoutOrderId = payments.filter(p => !p.orderId);\n+      \n+      if (paymentsWithoutOrderId.length === 0) {\n+        console.log('마이그레이션이 필요한 결제 데이터가 없습니다.');\n+        return;\n+      }\n+      \n+      // 각 결제에 대해 가상의 주문 생성\n+      for (const payment of paymentsWithoutOrderId) {\n+        // 1. 기존 결제를 위한 주문 생성\n+        const orderId = await this.order.createOrder({\n+          memberId: payment.memberId,\n+          memberName: payment.memberName,\n+          branchId: payment.branchId,\n+          branchName: payment.branchName,\n+          coach: payment.coach,\n+          coachName: payment.coachName,\n+          orderItems: payment.products.map(p => ({\n+            productId: p.id,\n+            productName: p.name,\n+            programId: p.programId || '',\n+            programName: p.programName || '',\n+            programType: p.programType || '',\n+            price: p.price,\n+            quantity: p.quantity\n+          })),\n+          totalAmount: payment.totalAmount,\n+          paidAmount: payment.paidAmount,\n+          unpaidAmount: payment.unpaidAmount,\n+          pointsUsed: 0, // 기존 데이터에서는 포인트 사용 정보 없음\n+          pointsEarned: 0,\n+          orderStatus: payment.paymentStatus === 'completed' ? 'completed' : \n+                      payment.paymentStatus === 'unpaid' ? 'partially_paid' : 'pending',\n+          orderType: payment.paymentType === 'course' ? 'course_enrollment' : 'product_purchase',\n+          memo: `마이그레이션된 기존 결제 (원본 결제 ID: ${payment.id.slice(-8)})`\n+        });\n+        \n+        // 2. 결제에 주문 ID 추가\n+        await this.payment.updatePayment(payment.id, { orderId });\n+        \n+        // 3. 관련 수강 등록에도 주문 ID 추가\n+        if (payment.relatedCourseId) {\n+          await this.course.updateCourseEnrollment(payment.relatedCourseId, { orderId });\n+        }\n+      }\n+      \n+      console.log(`결제 데이터 주문 ID 마이그레이션 완료: ${paymentsWithoutOrderId.length}건 처리`);\n+    } catch (error) {\n+      console.error('결제 데이터 주문 ID 마이그레이션 실패:', error);\n+    }\n+  }\n+\n+  /**\n+   * 전체 데이터베이스 초기화 (개발/테스트용)\n+   */\n+  async clearAllData(): Promise<void> {\n+    await super.clearAllData();\n+  }\n+\n+  /**\n+   * 데이터베이스 연결 상태 확인\n+   */\n+  get isConnected(): boolean {\n+    return this.db !== null;\n+  }\n+\n+  /**\n+   * 데이터베이스 버전 정보\n+   */\n+  get dbVersion(): number {\n+    return this.version;\n+  }\n+\n+  // ===============================\n+  // Backward Compatibility Layer\n+  // 기존 API 호환성을 위한 메서드들\n+  // ===============================\n+\n+  // Branch 관련 호환성 메서드\n+  async getAllBranches() {\n+    return await this.branch.getAllBranches();\n+  }\n+\n+  async addBranch(branchData: Omit<import('./types').Branch, 'id' | 'createdAt' | 'updatedAt'>) {\n+    return await this.branch.addBranch(branchData);\n+  }\n+\n+  async updateBranch(id: string, updates: Partial<import('./types').Branch>) {\n+    return await this.branch.updateBranch(id, updates);\n+  }\n+\n+  async deleteBranch(id: string) {\n+    return await this.branch.deleteBranch(id);\n+  }\n+\n+  async getBranchById(id: string) {\n+    return await this.branch.getBranchById(id);\n+  }\n+\n+  async getOrCreateBranchByName(name: string) {\n+    return await this.branch.getOrCreateBranchByName(name);\n+  }\n+\n+  // 라커 가격 관련 메서드\n+  async getLockerPrice(branchId: string) {\n+    return await this.branch.getLockerPrice(branchId);\n+  }\n+\n+  async updateLockerPrice(branchId: string, price: number) {\n+    return await this.branch.updateLockerPrice(branchId, price);\n+  }\n+\n+  // Staff 관련 호환성 메서드\n+  async getAllStaff() {\n+    return await this.staff.getAllStaff();\n+  }\n+\n+  async addStaff(staffData: Omit<import('./types').Staff, 'id' | 'createdAt' | 'updatedAt'>) {\n+    return await this.staff.addStaff(staffData);\n+  }\n+\n+  async updateStaff(id: string, updates: Partial<import('./types').Staff>) {\n+    return await this.staff.updateStaff(id, updates);\n+  }\n+\n+  async deleteStaff(id: string) {\n+    return await this.staff.deleteStaff(id);\n+  }\n+\n+  async getStaffById(id: string) {\n+    return await this.staff.getStaffById(id);\n+  }\n+\n+  async getStaffByLoginId(loginId: string) {\n+    return await this.staff.getStaffByLoginId(loginId);\n+  }\n+\n+  async toggleStaffStatus(id: string) {\n+    return await this.staff.toggleStaffStatus(id);\n+  }\n+\n+  // Member 관련 호환성 메서드\n+  async getAllMembers() {\n+    return await this.member.getAllMembers();\n+  }\n+\n+  async addMember(memberData: Omit<import('./types').Member, 'id' | 'createdAt' | 'updatedAt'>) {\n+    return await this.member.addMember(memberData);\n+  }\n+\n+  async updateMember(id: string, updates: Partial<import('./types').Member>) {\n+    return await this.member.updateMember(id, updates);\n+  }\n+\n+  async deleteMember(id: string) {\n+    return await this.member.deleteMember(id);\n+  }\n+\n+  async getMemberById(id: string) {\n+    return await this.member.getMemberById(id);\n+  }\n+\n+  async searchMembers(searchTerm: string) {\n+    return await this.member.searchMembers(searchTerm);\n+  }\n+\n+  async checkMemberDuplicate(phone: string, email?: string) {\n+    return await this.member.checkMemberDuplicate(phone, email);\n+  }\n+\n+  // Product 관련 호환성 메서드\n+  async getAllProducts() {\n+    return await this.product.getAllProducts();\n+  }\n+\n+  async addProduct(productData: Omit<import('./types').Product, 'id' | 'createdAt' | 'updatedAt'>) {\n+    return await this.product.addProduct(productData);\n+  }\n+\n+  async updateProduct(id: string, updates: Partial<import('./types').Product>) {\n+    return await this.product.updateProduct(id, updates);\n+  }\n+\n+  async deleteProduct(id: string) {\n+    return await this.product.deleteProduct(id);\n+  }\n+\n+  async getProductById(id: string) {\n+    return await this.product.getProductById(id);\n+  }\n+\n+  async getProductsByBranch(branchId: string) {\n+    return await this.product.getProductsByBranch(branchId);\n+  }\n+\n+  async getProductsByProgram(programId: string) {\n+    return await this.product.getProductsByProgram(programId);\n+  }\n+\n+  // Program 관련 호환성 메서드\n+  async getAllPrograms() {\n+    return await this.program.getAllPrograms();\n+  }\n+\n+  async addProgram(programData: Omit<import('./types').Program, 'id' | 'createdAt' | 'updatedAt'>) {\n+    return await this.program.addProgram(programData);\n+  }\n+\n+  async updateProgram(id: string, updates: Partial<import('./types').Program>) {\n+    return await this.program.updateProgram(id, updates);\n+  }\n+\n+  async deleteProgram(id: string) {\n+    return await this.program.deleteProgram(id);\n+  }\n+\n+  async getProgramById(id: string) {\n+    const programs = await this.program.getAllPrograms();\n+    return programs.find(p => p.id === id) || null;\n+  }\n+\n+  async getProgramsByBranch(branchId: string) {\n+    const products = await this.product.getAllProducts();\n+    const programIds = Array.from(new Set(products.filter(p => p.branchId === branchId).map(p => p.programId)));\n+    const programs = await this.program.getAllPrograms();\n+    return programs.filter(p => programIds.includes(p.id));\n+  }\n+\n+  // Payment 관련 호환성 메서드\n+  async getAllPayments() {\n+    return await this.payment.getAllPayments();\n+  }\n+\n+  async addPayment(paymentData: Omit<import('./types').Payment, 'id' | 'createdAt' | 'updatedAt'>) {\n+    return await this.payment.addPayment(paymentData);\n+  }\n+\n+  async updatePayment(id: string, updates: Partial<import('./types').Payment>) {\n+    return await this.payment.updatePayment(id, updates);\n+  }\n+\n+  async deletePayment(id: string) {\n+    return await this.payment.deletePayment(id);\n+  }\n+\n+  async getPaymentById(id: string) {\n+    return await this.payment.getPaymentById(id);\n+  }\n+\n+  async getPaymentsByMember(memberId: string) {\n+    return await this.payment.getPaymentsByMember(memberId);\n+  }\n+\n+  async getPaymentsByBranch(branchId: string) {\n+    const payments = await this.payment.getAllPayments();\n+    return payments.filter(p => p.branchId === branchId);\n+  }\n+\n+  // Point 관련 호환성 메서드\n+  async getAllPoints() {\n+    return await this.point.getAllPoints();\n+  }\n+\n+  // 새로운 포인트 시스템에서만 포인트 내역 조회\n+  async getAllPointsUnified() {\n+    return await this.point.getAllPointsFromTransactions();\n+  }\n+\n+  async getMemberPointStats(memberId: string) {\n+    return await this.point.getMemberPointStatsUnified(memberId);\n+  }\n+\n+  async addPoint(pointData: import('./types').Point) {\n+    return await this.point.addPoint(pointData);\n+  }\n+\n+  async updatePoint(id: string, updates: Partial<import('./types').Point>) {\n+    const points = await this.point.getAllPoints();\n+    const point = points.find(p => p.id === id);\n+    if (!point) {\n+      throw new Error('포인트를 찾을 수 없습니다.');\n+    }\n+    // Point 업데이트 로직을 대체 구현\n+    const updatedPoint = { ...point, ...updates, updatedAt: new Date() };\n+    return await this.point.addPoint(updatedPoint);\n+  }\n+\n+  async deletePoint(id: string) {\n+    // Point 삭제는 직접 구현 필요 (서비스에 없음)\n+    console.warn('Point 삭제는 지원되지 않습니다.');\n+    return false;\n+  }\n+\n+  async getPointById(id: string) {\n+    const points = await this.point.getAllPoints();\n+    return points.find(p => p.id === id) || null;\n+  }\n+\n+  async getPointsByMember(memberId: string) {\n+    return await this.point.getPointsByMember(memberId);\n+  }\n+\n+  // Course 관련 호환성 메서드\n+  async getAllCourseEnrollments() {\n+    return await this.course.getAllCourseEnrollments();\n+  }\n+\n+  async addCourseEnrollment(enrollmentData: Omit<import('./types').CourseEnrollment, 'id' | 'createdAt' | 'updatedAt'>) {\n+    return await this.course.addCourseEnrollment(enrollmentData);\n+  }\n+\n+  async updateCourseEnrollment(id: string, updates: Partial<import('./types').CourseEnrollment>) {\n+    return await this.course.updateCourseEnrollment(id, updates);\n+  }\n+\n+  async deleteCourseEnrollment(id: string) {\n+    return await this.course.deleteCourseEnrollment(id);\n+  }\n+\n+  async getCourseEnrollmentById(id: string) {\n+    return await this.course.getCourseEnrollmentById(id);\n+  }\n+\n+  async getCourseEnrollmentsByMember(memberId: string) {\n+    return await this.course.getCourseEnrollmentsByMember(memberId);\n+  }\n+\n+  async getCourseEnrollmentsByBranch(branchId: string) {\n+    return await this.course.getCourseEnrollmentsByBranch(branchId);\n+  }\n+\n+  async getUnpaidMetaInfo() {\n+    return await this.course.getUnpaidMetaInfo();\n+  }\n+\n+  async getMemberUnpaidTotal(memberId: string) {\n+    return await this.course.getMemberUnpaidTotal(memberId);\n+  }\n+\n+  // Terms 관련 호환성 메서드\n+  async getAllTermsDocuments() {\n+    return await this.terms.getAllTermsDocuments();\n+  }\n+\n+  async addTermsDocument(termsData: Omit<import('./types').TermsDocument, 'id' | 'createdAt' | 'updatedAt'>) {\n+    return await this.terms.addTermsDocument(termsData);\n+  }\n+\n+  async updateTermsDocument(id: string, updates: Partial<import('./types').TermsDocument>) {\n+    return await this.terms.updateTermsDocument(id, updates);\n+  }\n+\n+  async deleteTermsDocument(id: string) {\n+    return await this.terms.deleteTermsDocument(id);\n+  }\n+\n+  async getTermsDocumentById(id: string) {\n+    return await this.terms.getTermsDocumentById(id);\n+  }\n+\n+  async getLatestTermsDocument(type: string) {\n+    // 타입을 명시적으로 캐스팅\n+    const validType = type as \"privacy_policy\" | \"terms_of_service\" | \"business_info\" | \"marketing_consent\" | \"member_terms\" | \"contract\";\n+    return await this.terms.getActiveTermsDocument(validType);\n+  }\n+\n+  // Holiday 관련 호환성 메서드 (HolidaySettings로 대체)\n+  async getAllHolidays() {\n+    // HolidayService에는 전체 조회가 없으므로 최근 1년 범위로 조회\n+    const now = new Date();\n+    const startDate = new Date(now.getFullYear() - 1, 0, 1).toISOString().split('T')[0];\n+    const endDate = new Date(now.getFullYear() + 1, 11, 31).toISOString().split('T')[0];\n+    return await this.holiday.getHolidaySettingsByDateRange(startDate, endDate);\n+  }\n+\n+  async addHoliday(holidayData: import('./types').HolidaySettings) {\n+    return await this.holiday.saveHolidaySettings([holidayData]);\n+  }\n+\n+  async updateHoliday(id: string, updates: Partial<import('./types').HolidaySettings>) {\n+    // HolidayService는 개별 업데이트가 없으므로 조회 후 전체 저장\n+    const allHolidays = await this.getAllHolidays();\n+    const target = allHolidays.find(h => h.id === id);\n+    if (!target) {\n+      throw new Error('휴일 설정을 찾을 수 없습니다.');\n+    }\n+    const updated = { ...target, ...updates, updatedAt: new Date() };\n+    return await this.holiday.saveHolidaySettings([updated]);\n+  }\n+\n+  async deleteHoliday(id: string) {\n+    // HolidayService에는 삭제 메서드가 없음\n+    console.warn('Holiday 삭제는 직접 지원되지 않습니다.');\n+    return false;\n+  }\n+\n+  async getHolidayById(id: string) {\n+    const allHolidays = await this.getAllHolidays();\n+    return allHolidays.find(h => h.id === id) || null;\n+  }\n+\n+  async getHolidaysByYear(year: number) {\n+    const startDate = new Date(year, 0, 1).toISOString().split('T')[0];\n+    const endDate = new Date(year, 11, 31).toISOString().split('T')[0];\n+    return await this.holiday.getHolidaySettingsByDateRange(startDate, endDate);\n+  }\n+\n+  async isHoliday(date: Date) {\n+    const dateString = date.toISOString().split('T')[0];\n+    const holidays = await this.holiday.getHolidaySettingsByDate(dateString);\n+    return holidays.length > 0;\n+  }\n+\n+  async getHolidaySettingsByDateRange(startDate: string, endDate: string) {\n+    return await this.holiday.getHolidaySettingsByDateRange(startDate, endDate);\n+  }\n+\n+  async saveHolidaySettings(settings: Omit<import('./types').HolidaySettings, 'id' | 'createdAt' | 'updatedAt'>[]) {\n+    return await this.holiday.saveHolidaySettings(settings);\n+  }\n+\n+  // 주별 휴일설정 관련 메서드\n+  async saveWeeklyHolidaySettings(settings: Omit<import('./types').WeeklyHolidaySettings, 'id' | 'createdAt' | 'updatedAt'>[]) {\n+    return await this.weeklyHoliday.saveWeeklyHolidaySettings(settings);\n+  }\n+\n+  async getWeeklyHolidaySettingsByStaff(staffId: string) {\n+    return await this.weeklyHoliday.getWeeklyHolidaySettingsByStaff(staffId);\n+  }\n+\n+  async getWeeklyHolidaySettingsByStaffAndWeek(staffId: string, weekStartDate: string) {\n+    return await this.weeklyHoliday.getWeeklyHolidaySettingsByStaffAndWeek(staffId, weekStartDate);\n+  }\n+\n+  async getWeeklyHolidaySettingsByWeek(weekStartDate: string) {\n+    return await this.weeklyHoliday.getWeeklyHolidaySettingsByWeek(weekStartDate);\n+  }\n+\n+  async deleteWeeklyHolidaySettings(id: string) {\n+    return await this.weeklyHoliday.deleteWeeklyHolidaySettings(id);\n+  }\n+\n+  async deleteWeeklyHolidaySettingsByStaff(staffId: string) {\n+    return await this.weeklyHoliday.deleteWeeklyHolidaySettingsByStaff(staffId);\n+  }\n+\n+  async isHolidayByDate(staffId: string, date: string) {\n+    return await this.weeklyHoliday.isHolidayByDate(staffId, date);\n+  }\n+\n+  getNextMondayDate() {\n+    return this.weeklyHoliday.getNextMondayDate();\n+  }\n+\n+  getCurrentMondayDate() {\n+    return this.weeklyHoliday.getCurrentMondayDate();\n+  }\n+\n+  // Staff migration 관련 호환성 메서드\n+  async migrateStaffActiveStatus() {\n+    return await this.staff.migrateStaffActiveStatus();\n+  }\n+\n+  async checkDuplicateStaff(loginId: string, email: string, phone: string) {\n+    return await this.staff.checkDuplicateStaff(loginId, email, phone);\n+  }\n+\n+  // Locker 관련 호환성 메서드\n+  async getAllLockers() {\n+    return await this.locker.getAllLockers();\n+  }\n+\n+  async getLockersByBranch(branchId: string) {\n+    return await this.locker.getLockersByBranch(branchId);\n+  }\n+\n+  async addLocker(lockerData: Omit<import('./types').Locker, 'id' | 'createdAt' | 'updatedAt'>) {\n+    return await this.locker.addLocker(lockerData);\n+  }\n+\n+  async addMultipleLockers(lockersData: Omit<import('./types').Locker, 'id' | 'createdAt' | 'updatedAt'>[]) {\n+    return await this.locker.addMultipleLockers(lockersData);\n+  }\n+\n+  async updateLocker(id: string, updates: Partial<import('./types').Locker>) {\n+    return await this.locker.updateLocker(id, updates);\n+  }\n+\n+  async deleteLocker(id: string) {\n+    return await this.locker.deleteLocker(id);\n+  }\n+\n+  async getLockerById(id: string) {\n+    return await this.locker.getLockerById(id);\n+  }\n+\n+  async getLockersByUser(userId: string) {\n+    return await this.locker.getLockersByUser(userId);\n+  }\n+\n+  async assignLockerToUser(lockerId: string, userId: string, userName: string, months: number, paymentId?: string) {\n+    return await this.locker.assignLockerToUser(lockerId, userId, userName, months, paymentId, this.member);\n+  }\n+\n+  async unassignLocker(lockerId: string) {\n+    return await this.locker.unassignLocker(lockerId, this.member);\n+  }\n+\n+  async getExpiredLockers() {\n+    return await this.locker.getExpiredLockers();\n+  }\n+\n+  async checkLockerNumberDuplicate(branchId: string, number: string, excludeId?: string) {\n+    return await this.locker.checkLockerNumberDuplicate(branchId, number, excludeId);\n+  }\n+\n+  // ScheduleEvent 관련 호환성 메서드\n+  async saveScheduleEvents(events: Omit<import('./types').ScheduleEvent, 'id' | 'createdAt' | 'updatedAt'>[]) {\n+    return await this.scheduleEvent.saveScheduleEvents(events);\n+  }\n+\n+  async deleteScheduleEventsBySource(sourceType: string, sourceId?: string) {\n+    return await this.scheduleEvent.deleteScheduleEventsBySource(sourceType, sourceId);\n+  }\n+\n+  async getScheduleEventsByStaff(staffId: string, startDate?: Date, endDate?: Date) {\n+    return await this.scheduleEvent.getScheduleEventsByStaff(staffId, startDate, endDate);\n+  }\n+\n+  async getAllScheduleEvents(startDate?: Date, endDate?: Date) {\n+    return await this.scheduleEvent.getAllScheduleEvents(startDate, endDate);\n+  }\n+\n+  async deleteScheduleEvent(eventId: string) {\n+    return await this.scheduleEvent.deleteScheduleEvent(eventId);\n+  }\n+}\n+\n+// 싱글톤 인스턴스 생성 및 export\n+export const dbManager = new IndexedDBManager();\n+\n+// 개발자 도구에서 사용할 수 있도록 전역 객체에 추가\n+if (typeof window !== 'undefined') {\n+  (window as any).dbManager = dbManager;\n+}\n+\n+// 기존 호환성을 위한 default export\n+export default dbManager;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761459341743,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -119,692 +119,11 @@\n       \n       // 3. 결제 데이터에 주문 ID 추가\n       await this.migratePaymentsWithOrderId();\n       \n-      console.log('=== 데이터 마이그레이션 완료 ===');\n-    } catch (error) {\n-      console.error('데이터 마이그레이션 실패:', error);\n-    }\n-  }\n-\n-  /**\n-   * 기존 결제 데이터에 orderId 추가 (역호환성)\n-   */\n-  private async migratePaymentsWithOrderId(): Promise<void> {\n-    try {\n-      console.log('결제 데이터 주문 ID 마이그레이션 시작...');\n+      // 4. 수강 데이터에 appliedPrice 필드 추가\n+      await this.course.migrateAppliedPriceField();\n       \n-      const payments = await this.payment.getAllPayments();\n-      const paymentsWithoutOrderId = payments.filter(p => !p.orderId);\n-      \n-      if (paymentsWithoutOrderId.length === 0) {\n-        console.log('마이그레이션이 필요한 결제 데이터가 없습니다.');\n-        return;\n-      }\n-      \n-      // 각 결제에 대해 가상의 주문 생성\n-      for (const payment of paymentsWithoutOrderId) {\n-        // 1. 기존 결제를 위한 주문 생성\n-        const orderId = await this.order.createOrder({\n-          memberId: payment.memberId,\n-          memberName: payment.memberName,\n-          branchId: payment.branchId,\n-          branchName: payment.branchName,\n-          coach: payment.coach,\n-          coachName: payment.coachName,\n-          orderItems: payment.products.map(p => ({\n-            productId: p.id,\n-            productName: p.name,\n-            programId: p.programId || '',\n-            programName: p.programName || '',\n-            programType: p.programType || '',\n-            price: p.price,\n-            quantity: p.quantity\n-          })),\n-          totalAmount: payment.totalAmount,\n-          paidAmount: payment.paidAmount,\n-          unpaidAmount: payment.unpaidAmount,\n-          pointsUsed: 0, // 기존 데이터에서는 포인트 사용 정보 없음\n-          pointsEarned: 0,\n-          orderStatus: payment.paymentStatus === 'completed' ? 'completed' : \n-                      payment.paymentStatus === 'unpaid' ? 'partially_paid' : 'pending',\n-          orderType: payment.paymentType === 'course' ? 'course_enrollment' : 'product_purchase',\n-          memo: `마이그레이션된 기존 결제 (원본 결제 ID: ${payment.id.slice(-8)})`\n-        });\n-        \n-        // 2. 결제에 주문 ID 추가\n-        await this.payment.updatePayment(payment.id, { orderId });\n-        \n-        // 3. 관련 수강 등록에도 주문 ID 추가\n-        if (payment.relatedCourseId) {\n-          await this.course.updateCourseEnrollment(payment.relatedCourseId, { orderId });\n-        }\n-      }\n-      \n-      console.log(`결제 데이터 주문 ID 마이그레이션 완료: ${paymentsWithoutOrderId.length}건 처리`);\n-    } catch (error) {\n-      console.error('결제 데이터 주문 ID 마이그레이션 실패:', error);\n-    }\n-  }\n-\n-  /**\n-   * 전체 데이터베이스 초기화 (개발/테스트용)\n-   */\n-  async clearAllData(): Promise<void> {\n-    await super.clearAllData();\n-  }\n-\n-  /**\n-   * 데이터베이스 연결 상태 확인\n-   */\n-  get isConnected(): boolean {\n-    return this.db !== null;\n-  }\n-\n-  /**\n-   * 데이터베이스 버전 정보\n-   */\n-  get dbVersion(): number {\n-    return this.version;\n-  }\n-\n-  // ===============================\n-  // Backward Compatibility Layer\n-  // 기존 API 호환성을 위한 메서드들\n-  // ===============================\n-\n-  // Branch 관련 호환성 메서드\n-  async getAllBranches() {\n-    return await this.branch.getAllBranches();\n-  }\n-\n-  async addBranch(branchData: Omit<import('./types').Branch, 'id' | 'createdAt' | 'updatedAt'>) {\n-    return await this.branch.addBranch(branchData);\n-  }\n-\n-  async updateBranch(id: string, updates: Partial<import('./types').Branch>) {\n-    return await this.branch.updateBranch(id, updates);\n-  }\n-\n-  async deleteBranch(id: string) {\n-    return await this.branch.deleteBranch(id);\n-  }\n-\n-  async getBranchById(id: string) {\n-    return await this.branch.getBranchById(id);\n-  }\n-\n-  async getOrCreateBranchByName(name: string) {\n-    return await this.branch.getOrCreateBranchByName(name);\n-  }\n-\n-  // 라커 가격 관련 메서드\n-  async getLockerPrice(branchId: string) {\n-    return await this.branch.getLockerPrice(branchId);\n-  }\n-\n-  async updateLockerPrice(branchId: string, price: number) {\n-    return await this.branch.updateLockerPrice(branchId, price);\n-  }\n-\n-  // Staff 관련 호환성 메서드\n-  async getAllStaff() {\n-    return await this.staff.getAllStaff();\n-  }\n-\n-  async addStaff(staffData: Omit<import('./types').Staff, 'id' | 'createdAt' | 'updatedAt'>) {\n-    return await this.staff.addStaff(staffData);\n-  }\n-\n-  async updateStaff(id: string, updates: Partial<import('./types').Staff>) {\n-    return await this.staff.updateStaff(id, updates);\n-  }\n-\n-  async deleteStaff(id: string) {\n-    return await this.staff.deleteStaff(id);\n-  }\n-\n-  async getStaffById(id: string) {\n-    return await this.staff.getStaffById(id);\n-  }\n-\n-  async getStaffByLoginId(loginId: string) {\n-    return await this.staff.getStaffByLoginId(loginId);\n-  }\n-\n-  async toggleStaffStatus(id: string) {\n-    return await this.staff.toggleStaffStatus(id);\n-  }\n-\n-  // Member 관련 호환성 메서드\n-  async getAllMembers() {\n-    return await this.member.getAllMembers();\n-  }\n-\n-  async addMember(memberData: Omit<import('./types').Member, 'id' | 'createdAt' | 'updatedAt'>) {\n-    return await this.member.addMember(memberData);\n-  }\n-\n-  async updateMember(id: string, updates: Partial<import('./types').Member>) {\n-    return await this.member.updateMember(id, updates);\n-  }\n-\n-  async deleteMember(id: string) {\n-    return await this.member.deleteMember(id);\n-  }\n-\n-  async getMemberById(id: string) {\n-    return await this.member.getMemberById(id);\n-  }\n-\n-  async searchMembers(searchTerm: string) {\n-    return await this.member.searchMembers(searchTerm);\n-  }\n-\n-  async checkMemberDuplicate(phone: string, email?: string) {\n-    return await this.member.checkMemberDuplicate(phone, email);\n-  }\n-\n-  // Product 관련 호환성 메서드\n-  async getAllProducts() {\n-    return await this.product.getAllProducts();\n-  }\n-\n-  async addProduct(productData: Omit<import('./types').Product, 'id' | 'createdAt' | 'updatedAt'>) {\n-    return await this.product.addProduct(productData);\n-  }\n-\n-  async updateProduct(id: string, updates: Partial<import('./types').Product>) {\n-    return await this.product.updateProduct(id, updates);\n-  }\n-\n-  async deleteProduct(id: string) {\n-    return await this.product.deleteProduct(id);\n-  }\n-\n-  async getProductById(id: string) {\n-    return await this.product.getProductById(id);\n-  }\n-\n-  async getProductsByBranch(branchId: string) {\n-    return await this.product.getProductsByBranch(branchId);\n-  }\n-\n-  async getProductsByProgram(programId: string) {\n-    return await this.product.getProductsByProgram(programId);\n-  }\n-\n-  // Program 관련 호환성 메서드\n-  async getAllPrograms() {\n-    return await this.program.getAllPrograms();\n-  }\n-\n-  async addProgram(programData: Omit<import('./types').Program, 'id' | 'createdAt' | 'updatedAt'>) {\n-    return await this.program.addProgram(programData);\n-  }\n-\n-  async updateProgram(id: string, updates: Partial<import('./types').Program>) {\n-    return await this.program.updateProgram(id, updates);\n-  }\n-\n-  async deleteProgram(id: string) {\n-    return await this.program.deleteProgram(id);\n-  }\n-\n-  async getProgramById(id: string) {\n-    const programs = await this.program.getAllPrograms();\n-    return programs.find(p => p.id === id) || null;\n-  }\n-\n-  async getProgramsByBranch(branchId: string) {\n-    const products = await this.product.getAllProducts();\n-    const programIds = Array.from(new Set(products.filter(p => p.branchId === branchId).map(p => p.programId)));\n-    const programs = await this.program.getAllPrograms();\n-    return programs.filter(p => programIds.includes(p.id));\n-  }\n-\n-  // Payment 관련 호환성 메서드\n-  async getAllPayments() {\n-    return await this.payment.getAllPayments();\n-  }\n-\n-  async addPayment(paymentData: Omit<import('./types').Payment, 'id' | 'createdAt' | 'updatedAt'>) {\n-    return await this.payment.addPayment(paymentData);\n-  }\n-\n-  async updatePayment(id: string, updates: Partial<import('./types').Payment>) {\n-    return await this.payment.updatePayment(id, updates);\n-  }\n-\n-  async deletePayment(id: string) {\n-    return await this.payment.deletePayment(id);\n-  }\n-\n-  async getPaymentById(id: string) {\n-    return await this.payment.getPaymentById(id);\n-  }\n-\n-  async getPaymentsByMember(memberId: string) {\n-    return await this.payment.getPaymentsByMember(memberId);\n-  }\n-\n-  async getPaymentsByBranch(branchId: string) {\n-    const payments = await this.payment.getAllPayments();\n-    return payments.filter(p => p.branchId === branchId);\n-  }\n-\n-  // Point 관련 호환성 메서드\n-  async getAllPoints() {\n-    return await this.point.getAllPoints();\n-  }\n-\n-  // 새로운 포인트 시스템에서만 포인트 내역 조회\n-  async getAllPointsUnified() {\n-    return await this.point.getAllPointsFromTransactions();\n-  }\n-\n-  async getMemberPointStats(memberId: string) {\n-    return await this.point.getMemberPointStatsUnified(memberId);\n-  }\n-\n-  async addPoint(pointData: import('./types').Point) {\n-    return await this.point.addPoint(pointData);\n-  }\n-\n-  async updatePoint(id: string, updates: Partial<import('./types').Point>) {\n-    const points = await this.point.getAllPoints();\n-    const point = points.find(p => p.id === id);\n-    if (!point) {\n-      throw new Error('포인트를 찾을 수 없습니다.');\n-    }\n-    // Point 업데이트 로직을 대체 구현\n-    const updatedPoint = { ...point, ...updates, updatedAt: new Date() };\n-    return await this.point.addPoint(updatedPoint);\n-  }\n-\n-  async deletePoint(id: string) {\n-    // Point 삭제는 직접 구현 필요 (서비스에 없음)\n-    console.warn('Point 삭제는 지원되지 않습니다.');\n-    return false;\n-  }\n-\n-  async getPointById(id: string) {\n-    const points = await this.point.getAllPoints();\n-    return points.find(p => p.id === id) || null;\n-  }\n-\n-  async getPointsByMember(memberId: string) {\n-    return await this.point.getPointsByMember(memberId);\n-  }\n-\n-  // Course 관련 호환성 메서드\n-  async getAllCourseEnrollments() {\n-    return await this.course.getAllCourseEnrollments();\n-  }\n-\n-  async addCourseEnrollment(enrollmentData: Omit<import('./types').CourseEnrollment, 'id' | 'createdAt' | 'updatedAt'>) {\n-    return await this.course.addCourseEnrollment(enrollmentData);\n-  }\n-\n-  async updateCourseEnrollment(id: string, updates: Partial<import('./types').CourseEnrollment>) {\n-    return await this.course.updateCourseEnrollment(id, updates);\n-  }\n-\n-  async deleteCourseEnrollment(id: string) {\n-    return await this.course.deleteCourseEnrollment(id);\n-  }\n-\n-  async getCourseEnrollmentById(id: string) {\n-    return await this.course.getCourseEnrollmentById(id);\n-  }\n-\n-  async getCourseEnrollmentsByMember(memberId: string) {\n-    return await this.course.getCourseEnrollmentsByMember(memberId);\n-  }\n-\n-  async getCourseEnrollmentsByBranch(branchId: string) {\n-    return await this.course.getCourseEnrollmentsByBranch(branchId);\n-  }\n-\n-  async getUnpaidMetaInfo() {\n-    return await this.course.getUnpaidMetaInfo();\n-  }\n-\n-  async getMemberUnpaidTotal(memberId: string) {\n-    return await this.course.getMemberUnpaidTotal(memberId);\n-  }\n-\n-  // Terms 관련 호환성 메서드\n-  async getAllTermsDocuments() {\n-    return await this.terms.getAllTermsDocuments();\n-  }\n-\n-  async addTermsDocument(termsData: Omit<import('./types').TermsDocument, 'id' | 'createdAt' | 'updatedAt'>) {\n-    return await this.terms.addTermsDocument(termsData);\n-  }\n-\n-  async updateTermsDocument(id: string, updates: Partial<import('./types').TermsDocument>) {\n-    return await this.terms.updateTermsDocument(id, updates);\n-  }\n-\n-  async deleteTermsDocument(id: string) {\n-    return await this.terms.deleteTermsDocument(id);\n-  }\n-\n-  async getTermsDocumentById(id: string) {\n-    return await this.terms.getTermsDocumentById(id);\n-  }\n-\n-  async getLatestTermsDocument(type: string) {\n-    // 타입을 명시적으로 캐스팅\n-    const validType = type as \"privacy_policy\" | \"terms_of_service\" | \"business_info\" | \"marketing_consent\" | \"member_terms\" | \"contract\";\n-    return await this.terms.getActiveTermsDocument(validType);\n-  }\n-\n-  // Holiday 관련 호환성 메서드 (HolidaySettings로 대체)\n-  async getAllHolidays() {\n-    // HolidayService에는 전체 조회가 없으므로 최근 1년 범위로 조회\n-    const now = new Date();\n-    const startDate = new Date(now.getFullYear() - 1, 0, 1).toISOString().split('T')[0];\n-    const endDate = new Date(now.getFullYear() + 1, 11, 31).toISOString().split('T')[0];\n-    return await this.holiday.getHolidaySettingsByDateRange(startDate, endDate);\n-  }\n-\n-  async addHoliday(holidayData: import('./types').HolidaySettings) {\n-    return await this.holiday.saveHolidaySettings([holidayData]);\n-  }\n-\n-  async updateHoliday(id: string, updates: Partial<import('./types').HolidaySettings>) {\n-    // HolidayService는 개별 업데이트가 없으므로 조회 후 전체 저장\n-    const allHolidays = await this.getAllHolidays();\n-    const target = allHolidays.find(h => h.id === id);\n-    if (!target) {\n-      throw new Error('휴일 설정을 찾을 수 없습니다.');\n-    }\n-    const updated = { ...target, ...updates, updatedAt: new Date() };\n-    return await this.holiday.saveHolidaySettings([updated]);\n-  }\n-\n-  async deleteHoliday(id: string) {\n-    // HolidayService에는 삭제 메서드가 없음\n-    console.warn('Holiday 삭제는 직접 지원되지 않습니다.');\n-    return false;\n-  }\n-\n-  async getHolidayById(id: string) {\n-    const allHolidays = await this.getAllHolidays();\n-    return allHolidays.find(h => h.id === id) || null;\n-  }\n-\n-  async getHolidaysByYear(year: number) {\n-    const startDate = new Date(year, 0, 1).toISOString().split('T')[0];\n-    const endDate = new Date(year, 11, 31).toISOString().split('T')[0];\n-    return await this.holiday.getHolidaySettingsByDateRange(startDate, endDate);\n-  }\n-\n-  async isHoliday(date: Date) {\n-    const dateString = date.toISOString().split('T')[0];\n-    const holidays = await this.holiday.getHolidaySettingsByDate(dateString);\n-    return holidays.length > 0;\n-  }\n-\n-  async getHolidaySettingsByDateRange(startDate: string, endDate: string) {\n-    return await this.holiday.getHolidaySettingsByDateRange(startDate, endDate);\n-  }\n-\n-  async saveHolidaySettings(settings: Omit<import('./types').HolidaySettings, 'id' | 'createdAt' | 'updatedAt'>[]) {\n-    return await this.holiday.saveHolidaySettings(settings);\n-  }\n-\n-  // 주별 휴일설정 관련 메서드\n-  async saveWeeklyHolidaySettings(settings: Omit<import('./types').WeeklyHolidaySettings, 'id' | 'createdAt' | 'updatedAt'>[]) {\n-    return await this.weeklyHoliday.saveWeeklyHolidaySettings(settings);\n-  }\n-\n-  async getWeeklyHolidaySettingsByStaff(staffId: string) {\n-    return await this.weeklyHoliday.getWeeklyHolidaySettingsByStaff(staffId);\n-  }\n-\n-  async getWeeklyHolidaySettingsByStaffAndWeek(staffId: string, weekStartDate: string) {\n-    return await this.weeklyHoliday.getWeeklyHolidaySettingsByStaffAndWeek(staffId, weekStartDate);\n-  }\n-\n-  async getWeeklyHolidaySettingsByWeek(weekStartDate: string) {\n-    return await this.weeklyHoliday.getWeeklyHolidaySettingsByWeek(weekStartDate);\n-  }\n-\n-  async deleteWeeklyHolidaySettings(id: string) {\n-    return await this.weeklyHoliday.deleteWeeklyHolidaySettings(id);\n-  }\n-\n-  async deleteWeeklyHolidaySettingsByStaff(staffId: string) {\n-    return await this.weeklyHoliday.deleteWeeklyHolidaySettingsByStaff(staffId);\n-  }\n-\n-  async isHolidayByDate(staffId: string, date: string) {\n-    return await this.weeklyHoliday.isHolidayByDate(staffId, date);\n-  }\n-\n-  getNextMondayDate() {\n-    return this.weeklyHoliday.getNextMondayDate();\n-  }\n-\n-  getCurrentMondayDate() {\n-    return this.weeklyHoliday.getCurrentMondayDate();\n-  }\n-\n-  // Staff migration 관련 호환성 메서드\n-  async migrateStaffActiveStatus() {\n-    return await this.staff.migrateStaffActiveStatus();\n-  }\n-\n-  async checkDuplicateStaff(loginId: string, email: string, phone: string) {\n-    return await this.staff.checkDuplicateStaff(loginId, email, phone);\n-  }\n-\n-  // Locker 관련 호환성 메서드\n-  async getAllLockers() {\n-    return await this.locker.getAllLockers();\n-  }\n-\n-  async getLockersByBranch(branchId: string) {\n-    return await this.locker.getLockersByBranch(branchId);\n-  }\n-\n-  async addLocker(lockerData: Omit<import('./types').Locker, 'id' | 'createdAt' | 'updatedAt'>) {\n-    return await this.locker.addLocker(lockerData);\n-  }\n-\n-  async addMultipleLockers(lockersData: Omit<import('./types').Locker, 'id' | 'createdAt' | 'updatedAt'>[]) {\n-    return await this.locker.addMultipleLockers(lockersData);\n-  }\n-\n-  async updateLocker(id: string, updates: Partial<import('./types').Locker>) {\n-    return await this.locker.updateLocker(id, updates);\n-  }\n-\n-  async deleteLocker(id: string) {\n-    return await this.locker.deleteLocker(id);\n-  }\n-\n-  async getLockerById(id: string) {\n-    return await this.locker.getLockerById(id);\n-  }\n-\n-  async getLockersByUser(userId: string) {\n-    return await this.locker.getLockersByUser(userId);\n-  }\n-\n-  async assignLockerToUser(lockerId: string, userId: string, userName: string, months: number, paymentId?: string) {\n-    return await this.locker.assignLockerToUser(lockerId, userId, userName, months, paymentId, this.member);\n-  }\n-\n-  async unassignLocker(lockerId: string) {\n-    return await this.locker.unassignLocker(lockerId, this.member);\n-  }\n-\n-  async getExpiredLockers() {\n-    return await this.locker.getExpiredLockers();\n-  }\n-\n-  async checkLockerNumberDuplicate(branchId: string, number: string, excludeId?: string) {\n-    return await this.locker.checkLockerNumberDuplicate(branchId, number, excludeId);\n-  }\n-\n-  // ScheduleEvent 관련 호환성 메서드\n-  async saveScheduleEvents(events: Omit<import('./types').ScheduleEvent, 'id' | 'createdAt' | 'updatedAt'>[]) {\n-    return await this.scheduleEvent.saveScheduleEvents(events);\n-  }\n-\n-  async deleteScheduleEventsBySource(sourceType: string, sourceId?: string) {\n-    return await this.scheduleEvent.deleteScheduleEventsBySource(sourceType, sourceId);\n-  }\n-\n-  async getScheduleEventsByStaff(staffId: string, startDate?: Date, endDate?: Date) {\n-    return await this.scheduleEvent.getScheduleEventsByStaff(staffId, startDate, endDate);\n-  }\n-\n-  async getAllScheduleEvents(startDate?: Date, endDate?: Date) {\n-    return await this.scheduleEvent.getAllScheduleEvents(startDate, endDate);\n-  }\n-\n-  async deleteScheduleEvent(eventId: string) {\n-    return await this.scheduleEvent.deleteScheduleEvent(eventId);\n-  }\n-}\n-\n-// 싱글톤 인스턴스 생성 및 export\n-export const dbManager = new IndexedDBManager();\n-\n-// 개발자 도구에서 사용할 수 있도록 전역 객체에 추가\n-if (typeof window !== 'undefined') {\n-  (window as any).dbManager = dbManager;\n-}\n-\n-// 기존 호환성을 위한 default export\n-export default dbManager;\n-/**\n- * IndexedDB 통합 매니저\n- * 모든 개별 서비스들을 통합하여 하나의 인터페이스로 제공\n- */\n-\n-// 필요한 imports를 먼저 선언\n-import { BranchService } from './BranchService';\n-import { StaffService } from './StaffService';\n-import { ProgramService, ProductService, HolidayService, WeeklyHolidayService, ScheduleEventService } from './ProgramService';\n-import { MemberService } from './MemberService';\n-import { PaymentService, OrderService } from './PaymentService';\n-import { PointService } from './PointService';\n-import { CourseService } from './CourseService';\n-import { TermsService } from './TermsService';\n-import { LockerService } from './LockerService';\n-import { BaseDBManager } from './BaseDBManager';\n-\n-// 타입 정의 export\n-export * from './types';\n-\n-// 기본 클래스 export\n-export { BaseDBManager } from './BaseDBManager';\n-\n-// 개별 서비스 클래스들 export\n-export { BranchService } from './BranchService';\n-export { StaffService } from './StaffService';\n-export { ProgramService, ProductService, HolidayService, ScheduleEventService } from './ProgramService';\n-export { MemberService } from './MemberService';\n-export { PaymentService, OrderService } from './PaymentService';\n-export { PointService } from './PointService';\n-export { CourseService } from './CourseService';\n-export { TermsService } from './TermsService';\n-export { LockerService } from './LockerService';\n-\n-/**\n- * 통합 데이터베이스 매니저\n- * 모든 서비스들을 하나의 인스턴스에서 접근할 수 있도록 제공\n- */\n-export class IndexedDBManager extends BaseDBManager {\n-  public branch: BranchService;\n-  public staff: StaffService;\n-  public program: ProgramService;\n-  public product: ProductService;\n-  public holiday: HolidayService;\n-  public weeklyHoliday: WeeklyHolidayService;\n-  public scheduleEvent: ScheduleEventService;\n-  public member: MemberService;\n-  public payment: PaymentService;\n-  public order: OrderService;\n-  public point: PointService;\n-  public course: CourseService;\n-  public terms: TermsService;\n-  public locker: LockerService;\n-\n-  constructor() {\n-    super();\n-    \n-    // 각 서비스 인스턴스 생성\n-    this.branch = new BranchService();\n-    this.staff = new StaffService();\n-    this.program = new ProgramService();\n-    this.product = new ProductService();\n-    this.holiday = new HolidayService();\n-    this.weeklyHoliday = new WeeklyHolidayService();\n-    this.scheduleEvent = new ScheduleEventService();\n-    this.member = new MemberService();\n-    this.payment = new PaymentService();\n-    this.order = new OrderService();\n-    this.point = new PointService();\n-    this.course = new CourseService();\n-    this.terms = new TermsService();\n-    this.locker = new LockerService();\n-\n-    // 데이터 마이그레이션 실행\n-    this.runMigrations();\n-  }\n-\n-  /**\n-   * 통합 주문 처리 (서비스 간 협력이 필요한 복합 기능)\n-   */\n-  async processOrderWithPayments(orderData: import('./types').OrderProcessingData): Promise<string> {\n-    return await this.order.processOrderWithPayments(orderData, {\n-      productService: this.product,\n-      paymentService: this.payment,\n-      pointService: this.point,\n-      courseService: this.course\n-    });\n-  }\n-\n-  /**\n-   * 로그인 ID 중복 체크 (직원과 회원 모두 확인)\n-   */\n-  async checkLoginIdDuplicate(loginId: string): Promise<import('./types').LoginIdDuplicateCheckResult> {\n-    return await this.member.checkLoginIdDuplicate(\n-      loginId, \n-      (id: string) => this.staff.getStaffByLoginId(id)\n-    );\n-  }\n-\n-  /**\n-   * 회원 포인트 잔액 조회 (호환성 유지)\n-   */\n-  async getMemberPointBalance(memberId: string): Promise<number> {\n-    return await this.point.getMemberPointBalanceV2(memberId);\n-  }\n-\n-  /**\n-   * 전체 데이터 마이그레이션 실행\n-   */\n-  private async runMigrations(): Promise<void> {\n-    try {\n-      console.log('=== 데이터 마이그레이션 시작 ===');\n-      \n-      // 1. 직원 isActive 필드 마이그레이션\n-      await this.staff.migrateStaffActiveStatus();\n-      \n-      // 2. 포인트 데이터 마이그레이션\n-      await this.point.migratePointsToTransactions();\n-      \n-      // 3. 결제 데이터에 주문 ID 추가\n-      await this.migratePaymentsWithOrderId();\n-      \n       console.log('=== 데이터 마이그레이션 완료 ===');\n     } catch (error) {\n       console.error('데이터 마이그레이션 실패:', error);\n     }\n"
                },
                {
                    "date": 1761463030962,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,8 +12,9 @@\n import { PointService } from './PointService';\n import { CourseService } from './CourseService';\n import { TermsService } from './TermsService';\n import { LockerService } from './LockerService';\n+import { ExercisePrescriptionService } from './ExercisePrescriptionService';\n import { BaseDBManager } from './BaseDBManager';\n \n // 타입 정의 export\n export * from './types';\n@@ -30,8 +31,9 @@\n export { PointService } from './PointService';\n export { CourseService } from './CourseService';\n export { TermsService } from './TermsService';\n export { LockerService } from './LockerService';\n+export { ExercisePrescriptionService } from './ExercisePrescriptionService';\n \n /**\n  * 통합 데이터베이스 매니저\n  * 모든 서비스들을 하나의 인스턴스에서 접근할 수 있도록 제공\n@@ -50,8 +52,9 @@\n   public point: PointService;\n   public course: CourseService;\n   public terms: TermsService;\n   public locker: LockerService;\n+  public exercisePrescription: ExercisePrescriptionService;\n \n   constructor() {\n     super();\n     \n@@ -69,8 +72,9 @@\n     this.point = new PointService();\n     this.course = new CourseService();\n     this.terms = new TermsService();\n     this.locker = new LockerService();\n+    this.exercisePrescription = new ExercisePrescriptionService();\n \n     // 데이터 마이그레이션 실행\n     this.runMigrations();\n   }\n"
                }
            ],
            "date": 1761368450696,
            "name": "Commit-0",
            "content": "/**\n * IndexedDB 통합 매니저\n * 모든 개별 서비스들을 통합하여 하나의 인터페이스로 제공\n */\n\n// 필요한 imports를 먼저 선언\nimport { BranchService } from './BranchService';\nimport { StaffService } from './StaffService';\nimport { ProgramService, ProductService, HolidayService } from './ProgramService';\nimport { MemberService } from './MemberService';\nimport { PaymentService, OrderService } from './PaymentService';\nimport { PointService } from './PointService';\nimport { CourseService } from './CourseService';\nimport { TermsService } from './TermsService';\nimport { BaseDBManager } from './BaseDBManager';\n\n// 타입 정의 export\nexport * from './types';\n\n// 기본 클래스 export\nexport { BaseDBManager } from './BaseDBManager';\n\n// 개별 서비스 클래스들 export\nexport { BranchService } from './BranchService';\nexport { StaffService } from './StaffService';\nexport { ProgramService, ProductService, HolidayService } from './ProgramService';\nexport { MemberService } from './MemberService';\nexport { PaymentService, OrderService } from './PaymentService';\nexport { PointService } from './PointService';\nexport { CourseService } from './CourseService';\nexport { TermsService } from './TermsService';\n\n/**\n * 통합 데이터베이스 매니저\n * 모든 서비스들을 하나의 인스턴스에서 접근할 수 있도록 제공\n */\nexport class IndexedDBManager extends BaseDBManager {\n  public branch: BranchService;\n  public staff: StaffService;\n  public program: ProgramService;\n  public product: ProductService;\n  public holiday: HolidayService;\n  public member: MemberService;\n  public payment: PaymentService;\n  public order: OrderService;\n  public point: PointService;\n  public course: CourseService;\n  public terms: TermsService;\n\n  constructor() {\n    super();\n    \n    // 각 서비스 인스턴스 생성\n    this.branch = new BranchService();\n    this.staff = new StaffService();\n    this.program = new ProgramService();\n    this.product = new ProductService();\n    this.holiday = new HolidayService();\n    this.member = new MemberService();\n    this.payment = new PaymentService();\n    this.order = new OrderService();\n    this.point = new PointService();\n    this.course = new CourseService();\n    this.terms = new TermsService();\n\n    // 데이터 마이그레이션 실행\n    this.runMigrations();\n  }\n\n  /**\n   * 통합 주문 처리 (서비스 간 협력이 필요한 복합 기능)\n   */\n  async processOrderWithPayments(orderData: import('./types').OrderProcessingData): Promise<string> {\n    return await this.order.processOrderWithPayments(orderData, {\n      productService: this.product,\n      paymentService: this.payment,\n      pointService: this.point,\n      courseService: this.course\n    });\n  }\n\n  /**\n   * 로그인 ID 중복 체크 (직원과 회원 모두 확인)\n   */\n  async checkLoginIdDuplicate(loginId: string): Promise<import('./types').LoginIdDuplicateCheckResult> {\n    return await this.member.checkLoginIdDuplicate(\n      loginId, \n      (id: string) => this.staff.getStaffByLoginId(id)\n    );\n  }\n\n  /**\n   * 회원 포인트 잔액 조회 (호환성 유지)\n   */\n  async getMemberPointBalance(memberId: string): Promise<number> {\n    return await this.point.getMemberPointBalanceV2(memberId);\n  }\n\n  /**\n   * 전체 데이터 마이그레이션 실행\n   */\n  private async runMigrations(): Promise<void> {\n    try {\n      console.log('=== 데이터 마이그레이션 시작 ===');\n      \n      // 1. 직원 isActive 필드 마이그레이션\n      await this.staff.migrateStaffActiveStatus();\n      \n      // 2. 포인트 데이터 마이그레이션\n      await this.point.migratePointsToTransactions();\n      \n      // 3. 결제 데이터에 주문 ID 추가\n      await this.migratePaymentsWithOrderId();\n      \n      console.log('=== 데이터 마이그레이션 완료 ===');\n    } catch (error) {\n      console.error('데이터 마이그레이션 실패:', error);\n    }\n  }\n\n  /**\n   * 기존 결제 데이터에 orderId 추가 (역호환성)\n   */\n  private async migratePaymentsWithOrderId(): Promise<void> {\n    try {\n      console.log('결제 데이터 주문 ID 마이그레이션 시작...');\n      \n      const payments = await this.payment.getAllPayments();\n      const paymentsWithoutOrderId = payments.filter(p => !p.orderId);\n      \n      if (paymentsWithoutOrderId.length === 0) {\n        console.log('마이그레이션이 필요한 결제 데이터가 없습니다.');\n        return;\n      }\n      \n      // 각 결제에 대해 가상의 주문 생성\n      for (const payment of paymentsWithoutOrderId) {\n        // 1. 기존 결제를 위한 주문 생성\n        const orderId = await this.order.createOrder({\n          memberId: payment.memberId,\n          memberName: payment.memberName,\n          branchId: payment.branchId,\n          branchName: payment.branchName,\n          coach: payment.coach,\n          coachName: payment.coachName,\n          orderItems: payment.products.map(p => ({\n            productId: p.id,\n            productName: p.name,\n            programId: p.programId || '',\n            programName: p.programName || '',\n            programType: p.programType || '',\n            price: p.price,\n            quantity: p.quantity\n          })),\n          totalAmount: payment.totalAmount,\n          paidAmount: payment.paidAmount,\n          unpaidAmount: payment.unpaidAmount,\n          pointsUsed: 0, // 기존 데이터에서는 포인트 사용 정보 없음\n          pointsEarned: 0,\n          orderStatus: payment.paymentStatus === 'completed' ? 'completed' : \n                      payment.paymentStatus === 'unpaid' ? 'partially_paid' : 'pending',\n          orderType: payment.paymentType === 'course' ? 'course_enrollment' : 'product_purchase',\n          memo: `마이그레이션된 기존 결제 (원본 결제 ID: ${payment.id.slice(-8)})`\n        });\n        \n        // 2. 결제에 주문 ID 추가\n        await this.payment.updatePayment(payment.id, { orderId });\n        \n        // 3. 관련 수강 등록에도 주문 ID 추가\n        if (payment.relatedCourseId) {\n          await this.course.updateCourseEnrollment(payment.relatedCourseId, { orderId });\n        }\n      }\n      \n      console.log(`결제 데이터 주문 ID 마이그레이션 완료: ${paymentsWithoutOrderId.length}건 처리`);\n    } catch (error) {\n      console.error('결제 데이터 주문 ID 마이그레이션 실패:', error);\n    }\n  }\n\n  /**\n   * 전체 데이터베이스 초기화 (개발/테스트용)\n   */\n  async clearAllData(): Promise<void> {\n    await super.clearAllData();\n  }\n\n  /**\n   * 데이터베이스 연결 상태 확인\n   */\n  get isConnected(): boolean {\n    return this.db !== null;\n  }\n\n  /**\n   * 데이터베이스 버전 정보\n   */\n  get dbVersion(): number {\n    return this.version;\n  }\n}\n\n// 싱글톤 인스턴스 생성 및 export\nexport const dbManager = new IndexedDBManager();\n\n// 개발자 도구에서 사용할 수 있도록 전역 객체에 추가\nif (typeof window !== 'undefined') {\n  (window as any).dbManager = dbManager;\n}\n\n// 기존 호환성을 위한 default export\nexport default dbManager;"
        }
    ]
}