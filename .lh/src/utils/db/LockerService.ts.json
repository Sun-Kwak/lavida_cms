{
    "sourceFile": "src/utils/db/LockerService.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1761377685408,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1761378612784,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -157,45 +157,85 @@\n     return allLockers.filter(locker => locker.userId === userId && locker.isActive);\n   }\n \n   /**\n-   * 라커 배정 (사용자 할당)\n+   * 라커 배정 (사용자 할당 및 회원 정보 업데이트)\n    */\n   async assignLockerToUser(\n     lockerId: string, \n     userId: string, \n     userName: string, \n     months: number,\n-    paymentId?: string\n+    paymentId?: string,\n+    memberService?: any // MemberService 타입 (순환 참조 방지를 위해 any 사용)\n   ): Promise<Locker> {\n     const startDate = new Date();\n     const endDate = new Date();\n     endDate.setMonth(startDate.getMonth() + months);\n \n-    return await this.updateLocker(lockerId, {\n+    // 라커 정보 업데이트\n+    const updatedLocker = await this.updateLocker(lockerId, {\n       status: 'occupied',\n       userId,\n       userName,\n       startDate: startDate.toISOString().split('T')[0],\n       endDate: endDate.toISOString().split('T')[0],\n       months,\n       paymentId\n     });\n+\n+    // 회원 정보에도 라커 정보 추가 (MemberService가 있는 경우)\n+    if (memberService) {\n+      try {\n+        await memberService.updateMemberLockerInfo(userId, {\n+          lockerId,\n+          lockerNumber: updatedLocker.number,\n+          startDate: startDate.toISOString().split('T')[0],\n+          endDate: endDate.toISOString().split('T')[0],\n+          months,\n+          paymentId\n+        });\n+        console.log('회원 라커 정보 업데이트 완료:', userId);\n+      } catch (error) {\n+        console.error('회원 라커 정보 업데이트 실패:', error);\n+        // 라커 배정은 성공했으므로 에러를 throw하지 않고 로그만 남김\n+      }\n+    }\n+\n+    return updatedLocker;\n   }\n \n   /**\n-   * 라커 해제 (사용자 할당 해제)\n+   * 라커 해제 (사용자 할당 해제 및 회원 정보 업데이트)\n    */\n-  async unassignLocker(lockerId: string): Promise<Locker> {\n-    return await this.updateLocker(lockerId, {\n+  async unassignLocker(lockerId: string, memberService?: any): Promise<Locker> {\n+    // 라커 정보에서 사용자 ID 가져오기\n+    const locker = await this.getLockerById(lockerId);\n+    const userId = locker?.userId;\n+\n+    // 라커 해제\n+    const updatedLocker = await this.updateLocker(lockerId, {\n       status: 'available',\n       userId: undefined,\n       userName: undefined,\n       startDate: undefined,\n       endDate: undefined,\n       months: undefined,\n       paymentId: undefined\n     });\n+\n+    // 회원 정보에서도 라커 정보 제거 (MemberService가 있고 userId가 있는 경우)\n+    if (memberService && userId) {\n+      try {\n+        await memberService.updateMemberLockerInfo(userId, null);\n+        console.log('회원 라커 정보 제거 완료:', userId);\n+      } catch (error) {\n+        console.error('회원 라커 정보 제거 실패:', error);\n+        // 라커 해제는 성공했으므로 에러를 throw하지 않고 로그만 남김\n+      }\n+    }\n+\n+    return updatedLocker;\n   }\n \n   /**\n    * 만료된 라커 조회 (자동 해제용)\n"
                }
            ],
            "date": 1761377685408,
            "name": "Commit-0",
            "content": "/**\n * 라커 관련 데이터베이스 서비스\n */\n\nimport { BaseDBManager } from './BaseDBManager';\nimport type { Locker } from './types';\n\nexport class LockerService extends BaseDBManager {\n\n  /**\n   * 모든 라커 조회\n   */\n  async getAllLockers(): Promise<Locker[]> {\n    try {\n      return await this.executeTransaction('lockers', 'readonly', (store) => \n        store.getAll()\n      );\n    } catch (error) {\n      console.error('라커 조회 실패:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 지점별 라커 조회\n   */\n  async getLockersByBranch(branchId: string): Promise<Locker[]> {\n    const allLockers = await this.getAllLockers();\n    return allLockers.filter(locker => locker.branchId === branchId && locker.isActive);\n  }\n\n  /**\n   * 라커 추가\n   */\n  async addLocker(lockerData: Omit<Locker, 'id' | 'createdAt' | 'updatedAt'>): Promise<Locker> {\n    const now = new Date();\n    const newLocker: Locker = {\n      ...lockerData,\n      id: this.generateUUID(),\n      createdAt: now,\n      updatedAt: now\n    };\n\n    try {\n      await this.executeTransaction('lockers', 'readwrite', (store) => \n        store.add(newLocker)\n      );\n      return newLocker;\n    } catch (error) {\n      console.error('라커 추가 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 여러 라커 일괄 추가\n   */\n  async addMultipleLockers(lockersData: Omit<Locker, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<Locker[]> {\n    const now = new Date();\n    const newLockers: Locker[] = lockersData.map(lockerData => ({\n      ...lockerData,\n      id: this.generateUUID(),\n      createdAt: now,\n      updatedAt: now\n    }));\n\n    try {\n      // 각각 개별적으로 추가\n      for (const locker of newLockers) {\n        await this.executeTransaction('lockers', 'readwrite', (store) => \n          store.add(locker)\n        );\n      }\n      return newLockers;\n    } catch (error) {\n      console.error('여러 라커 추가 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 라커 정보 업데이트\n   */\n  async updateLocker(id: string, updates: Partial<Locker>): Promise<Locker> {\n    try {\n      // 기존 라커 정보 조회\n      const existingLocker = await this.executeTransaction('lockers', 'readonly', (store) => \n        store.get(id)\n      );\n\n      if (!existingLocker) {\n        throw new Error('라커를 찾을 수 없습니다.');\n      }\n\n      // 업데이트된 라커 정보 생성\n      const updatedLocker: Locker = {\n        ...existingLocker,\n        ...updates,\n        id: existingLocker.id, // ID는 변경되지 않도록\n        createdAt: new Date(existingLocker.createdAt),\n        updatedAt: new Date()\n      };\n\n      await this.executeTransaction('lockers', 'readwrite', (store) => \n        store.put(updatedLocker)\n      );\n\n      return updatedLocker;\n    } catch (error) {\n      console.error('라커 업데이트 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 라커 삭제 (소프트 삭제)\n   */\n  async deleteLocker(id: string): Promise<Locker> {\n    return await this.updateLocker(id, { isActive: false });\n  }\n\n  /**\n   * 라커 완전 삭제 (하드 삭제)\n   */\n  async permanentDeleteLocker(id: string): Promise<boolean> {\n    try {\n      await this.executeTransaction('lockers', 'readwrite', (store) => \n        store.delete(id)\n      );\n      return true;\n    } catch (error) {\n      console.error('라커 완전 삭제 실패:', error);\n      return false;\n    }\n  }\n\n  /**\n   * 라커 ID로 조회\n   */\n  async getLockerById(id: string): Promise<Locker | null> {\n    try {\n      const result = await this.executeTransaction('lockers', 'readonly', (store) => \n        store.get(id)\n      );\n      return result || null;\n    } catch (error) {\n      console.error('라커 조회 실패:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 사용자별 라커 조회\n   */\n  async getLockersByUser(userId: string): Promise<Locker[]> {\n    const allLockers = await this.getAllLockers();\n    return allLockers.filter(locker => locker.userId === userId && locker.isActive);\n  }\n\n  /**\n   * 라커 배정 (사용자 할당)\n   */\n  async assignLockerToUser(\n    lockerId: string, \n    userId: string, \n    userName: string, \n    months: number,\n    paymentId?: string\n  ): Promise<Locker> {\n    const startDate = new Date();\n    const endDate = new Date();\n    endDate.setMonth(startDate.getMonth() + months);\n\n    return await this.updateLocker(lockerId, {\n      status: 'occupied',\n      userId,\n      userName,\n      startDate: startDate.toISOString().split('T')[0],\n      endDate: endDate.toISOString().split('T')[0],\n      months,\n      paymentId\n    });\n  }\n\n  /**\n   * 라커 해제 (사용자 할당 해제)\n   */\n  async unassignLocker(lockerId: string): Promise<Locker> {\n    return await this.updateLocker(lockerId, {\n      status: 'available',\n      userId: undefined,\n      userName: undefined,\n      startDate: undefined,\n      endDate: undefined,\n      months: undefined,\n      paymentId: undefined\n    });\n  }\n\n  /**\n   * 만료된 라커 조회 (자동 해제용)\n   */\n  async getExpiredLockers(): Promise<Locker[]> {\n    const allLockers = await this.getAllLockers();\n    const today = new Date().toISOString().split('T')[0];\n    \n    return allLockers.filter(locker => \n      locker.status === 'occupied' && \n      locker.endDate && \n      locker.endDate < today &&\n      locker.isActive\n    );\n  }\n\n  /**\n   * 라커 번호 중복 체크\n   */\n  async checkLockerNumberDuplicate(branchId: string, number: string, excludeId?: string): Promise<boolean> {\n    const branchLockers = await this.getLockersByBranch(branchId);\n    return branchLockers.some(locker => \n      locker.number === number && \n      locker.id !== excludeId\n    );\n  }\n}"
        }
    ]
}