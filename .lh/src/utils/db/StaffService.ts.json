{
    "sourceFile": "src/utils/db/StaffService.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1761368450309,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1761368450309,
            "name": "Commit-0",
            "content": "/**\n * 직원 관리 서비스\n */\n\nimport { BaseDBManager } from './BaseDBManager';\nimport { Staff, DuplicateCheckResult } from './types';\nimport { SYSTEM_ADMIN_CONFIG } from '../../constants/staffConstants';\n\nexport class StaffService extends BaseDBManager {\n\n  /**\n   * 모든 직원 조회\n   */\n  async getAllStaff(): Promise<Staff[]> {\n    try {\n      const staffList = await this.executeTransaction('staff', 'readonly', (store) => \n        store.getAll()\n      );\n\n      // 저장된 파일 데이터를 File 객체로 복원\n      return staffList.map(staff => {\n        if (staff.contractFileData && staff.contractFileName) {\n          // 파일 확장자로부터 MIME 타입 추정\n          const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n          let mimeType = 'application/octet-stream';\n          \n          if (extension === 'pdf') {\n            mimeType = 'application/pdf';\n          } else if (['jpg', 'jpeg'].includes(extension || '')) {\n            mimeType = 'image/jpeg';\n          } else if (extension === 'png') {\n            mimeType = 'image/png';\n          }\n\n          staff.contractFile = this.arrayBufferToFile(\n            staff.contractFileData, \n            staff.contractFileName, \n            mimeType\n          );\n        }\n        return staff;\n      });\n    } catch (error) {\n      console.error('직원 조회 실패:', error);\n      return [];\n    }\n  }\n\n  /**\n   * ID로 직원 조회\n   */\n  async getStaffById(id: string): Promise<Staff | null> {\n    try {\n      const staff = await this.executeTransaction('staff', 'readonly', (store) => \n        store.get(id)\n      );\n\n      if (!staff) return null;\n\n      // 저장된 파일 데이터를 File 객체로 복원\n      if (staff.contractFileData && staff.contractFileName) {\n        const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n        let mimeType = 'application/octet-stream';\n        \n        if (extension === 'pdf') {\n          mimeType = 'application/pdf';\n        } else if (['jpg', 'jpeg'].includes(extension || '')) {\n          mimeType = 'image/jpeg';\n        } else if (extension === 'png') {\n          mimeType = 'image/png';\n        }\n\n        staff.contractFile = this.arrayBufferToFile(\n          staff.contractFileData, \n          staff.contractFileName, \n          mimeType\n        );\n      }\n\n      return staff;\n    } catch (error) {\n      console.error('직원 조회 실패:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 직원 추가\n   */\n  async addStaff(staffData: Omit<Staff, 'id' | 'createdAt' | 'updatedAt'>): Promise<Staff> {\n    const now = new Date();\n    \n    // 파일 데이터 처리\n    let contractFileData: ArrayBuffer | undefined;\n    let contractFileName: string | undefined;\n    \n    if (staffData.contractFile) {\n      contractFileData = await this.fileToArrayBuffer(staffData.contractFile);\n      contractFileName = staffData.contractFile.name;\n    }\n\n    const newStaff: Staff = {\n      ...staffData,\n      id: this.generateUUID(),\n      createdAt: now,\n      updatedAt: now,\n      isActive: staffData.isActive !== undefined ? staffData.isActive : true, // 기본값 true\n      contractFile: undefined, // File 객체는 저장하지 않음\n      contractFileName,\n      contractFileData,\n    };\n\n    try {\n      await this.executeTransaction('staff', 'readwrite', (store) => \n        store.add(newStaff)\n      );\n      console.log('직원 추가 성공:', newStaff);\n      return newStaff;\n    } catch (error) {\n      console.error('직원 추가 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 시스템 관리자 계정인지 확인\n   */\n  private isSystemAdmin(staff: Staff): boolean {\n    return staff.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID;\n  }\n\n  /**\n   * 시스템 관리자 보호 검증\n   */\n  private validateSystemAdminProtection(staff: Staff, operation: 'delete' | 'permission_change'): void {\n    if (this.isSystemAdmin(staff)) {\n      const message = operation === 'delete' \n        ? '시스템 관리자 계정은 삭제할 수 없습니다.'\n        : '시스템 관리자 계정의 권한은 변경할 수 없습니다.';\n      throw new Error(message);\n    }\n  }\n\n  /**\n   * 직원 수정\n   */\n  async updateStaff(id: string, updates: Partial<Omit<Staff, 'id' | 'createdAt'>>): Promise<Staff | null> {\n    try {\n      const existing = await this.getStaffById(id);\n      if (!existing) {\n        throw new Error('존재하지 않는 직원입니다.');\n      }\n\n      // 시스템 관리자 권한 변경 보호\n      if (updates.permission && updates.permission !== existing.permission) {\n        this.validateSystemAdminProtection(existing, 'permission_change');\n      }\n\n      // 파일 데이터 처리\n      let contractFileData = existing.contractFileData;\n      let contractFileName = existing.contractFileName;\n      \n      if (updates.contractFile) {\n        contractFileData = await this.fileToArrayBuffer(updates.contractFile);\n        contractFileName = updates.contractFile.name;\n      }\n\n      const updatedStaff: Staff = {\n        ...existing,\n        ...updates,\n        updatedAt: new Date(),\n        contractFile: undefined, // File 객체는 저장하지 않음\n        contractFileName,\n        contractFileData,\n      };\n\n      await this.executeTransaction('staff', 'readwrite', (store) => \n        store.put(updatedStaff)\n      );\n\n      console.log('직원 수정 성공:', updatedStaff);\n      return updatedStaff;\n    } catch (error) {\n      console.error('직원 수정 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 직원 삭제\n   */\n  async deleteStaff(id: string): Promise<boolean> {\n    try {\n      const existing = await this.getStaffById(id);\n      if (!existing) {\n        throw new Error('존재하지 않는 직원입니다.');\n      }\n\n      // 시스템 관리자 삭제 보호\n      this.validateSystemAdminProtection(existing, 'delete');\n\n      await this.executeTransaction('staff', 'readwrite', (store) => \n        store.delete(id)\n      );\n      console.log('직원 삭제 성공:', id);\n      return true;\n    } catch (error) {\n      console.error('직원 삭제 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 직원 활성/비활성 상태 토글\n   */\n  async toggleStaffStatus(id: string): Promise<Staff | null> {\n    try {\n      const existing = await this.getStaffById(id);\n      if (!existing) {\n        throw new Error('존재하지 않는 직원입니다.');\n      }\n\n      // 시스템 관리자 상태 변경 보호\n      if (existing.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID) {\n        throw new Error('시스템 관리자 계정의 상태는 변경할 수 없습니다.');\n      }\n\n      const updatedStaff = {\n        ...existing,\n        isActive: !existing.isActive,\n        updatedAt: new Date()\n      };\n\n      await this.executeTransaction('staff', 'readwrite', (store) => \n        store.put(updatedStaff)\n      );\n\n      console.log('직원 상태 변경 성공:', id, `-> ${updatedStaff.isActive ? '활성' : '비활성'}`);\n      return updatedStaff;\n    } catch (error) {\n      console.error('직원 상태 변경 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 지점별 직원 조회\n   */\n  async getStaffByBranch(branchId: string): Promise<Staff[]> {\n    try {\n      return await this.executeTransaction('staff', 'readonly', (store) => {\n        const index = store.index('branchId');\n        return index.getAll(IDBKeyRange.only(branchId));\n      });\n    } catch (error) {\n      console.error('지점별 직원 조회 실패:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 이메일로 직원 조회\n   */\n  async getStaffByEmail(email: string): Promise<Staff | null> {\n    try {\n      const result = await this.executeTransaction('staff', 'readonly', (store) => {\n        const index = store.index('email');\n        return index.get(email);\n      });\n      return result || null;\n    } catch (error) {\n      console.error('이메일로 직원 조회 실패:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 로그인ID로 직원 조회\n   */\n  async getStaffByLoginId(loginId: string): Promise<Staff | null> {\n    try {\n      const staff = await this.executeTransaction('staff', 'readonly', (store) => {\n        const index = store.index('loginId');\n        return index.get(loginId);\n      });\n\n      if (!staff) return null;\n\n      // 저장된 파일 데이터를 File 객체로 복원\n      if (staff.contractFileData && staff.contractFileName) {\n        const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n        let mimeType = 'application/octet-stream';\n        \n        if (extension === 'pdf') {\n          mimeType = 'application/pdf';\n        } else if (['jpg', 'jpeg'].includes(extension || '')) {\n          mimeType = 'image/jpeg';\n        } else if (extension === 'png') {\n          mimeType = 'image/png';\n        }\n\n        staff.contractFile = this.arrayBufferToFile(\n          staff.contractFileData, \n          staff.contractFileName, \n          mimeType\n        );\n      }\n\n      return staff;\n    } catch (error) {\n      console.error('로그인ID로 직원 조회 실패:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 전화번호로 직원 조회\n   */\n  async getStaffByPhone(phone: string): Promise<Staff | null> {\n    try {\n      const allStaff = await this.getAllStaff();\n      const found = allStaff.find(staff => staff.phone === phone);\n      return found || null;\n    } catch (error) {\n      console.error('전화번호로 직원 조회 실패:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 중복 체크 함수 (등록 시 사용)\n   */\n  async checkDuplicateStaff(loginId: string, email: string, phone: string): Promise<DuplicateCheckResult> {\n    try {\n      // 로그인 ID 중복 체크\n      const existingByLoginId = await this.getStaffByLoginId(loginId);\n      if (existingByLoginId) {\n        return {\n          isDuplicate: true,\n          duplicateField: 'loginId',\n          message: '이미 사용 중인 로그인 ID입니다.'\n        };\n      }\n\n      // 이메일 중복 체크\n      const existingByEmail = await this.getStaffByEmail(email);\n      if (existingByEmail) {\n        return {\n          isDuplicate: true,\n          duplicateField: 'email',\n          message: '이미 사용 중인 이메일입니다.'\n        };\n      }\n\n      // 전화번호 중복 체크\n      const existingByPhone = await this.getStaffByPhone(phone);\n      if (existingByPhone) {\n        return {\n          isDuplicate: true,\n          duplicateField: 'phone',\n          message: '이미 사용 중인 전화번호입니다.'\n        };\n      }\n\n      return { isDuplicate: false };\n    } catch (error) {\n      console.error('중복 체크 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 기존 직원 데이터의 isActive 필드 초기화 (마이그레이션용)\n   */\n  async migrateStaffActiveStatus(): Promise<void> {\n    try {\n      const allStaff = await this.executeTransaction('staff', 'readonly', (store) => \n        store.getAll()\n      );\n\n      // isActive 필드가 없는 직원들을 찾아서 업데이트\n      const staffToUpdate = allStaff.filter(staff => staff.isActive === undefined);\n      \n      if (staffToUpdate.length > 0) {\n        console.log(`${staffToUpdate.length}명의 직원 isActive 필드를 초기화합니다.`);\n        \n        for (const staff of staffToUpdate) {\n          const updatedStaff = {\n            ...staff,\n            isActive: true, // 기본값을 true로 설정\n            updatedAt: new Date()\n          };\n          \n          await this.executeTransaction('staff', 'readwrite', (store) => \n            store.put(updatedStaff)\n          );\n        }\n        \n        console.log('직원 isActive 필드 초기화 완료');\n      }\n    } catch (error) {\n      console.error('직원 isActive 필드 초기화 실패:', error);\n    }\n  }\n}"
        }
    ]
}