{
    "sourceFile": "src/utils/db/ProgramService.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1761368450406,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1761451696547,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -537,5 +537,219 @@\n       console.error('직원 휴일설정 전체 삭제 실패:', error);\n       throw error;\n     }\n   }\n+}\n+\n+// 주별 휴일설정 서비스 클래스\n+export class WeeklyHolidayService extends BaseDBManager {\n+\n+  /**\n+   * 주별 휴일설정 추가/업데이트\n+   */\n+  async saveWeeklyHolidaySettings(settingsArray: Omit<import('./types').WeeklyHolidaySettings, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<import('./types').WeeklyHolidaySettings[]> {\n+    try {\n+      const savedSettings: import('./types').WeeklyHolidaySettings[] = [];\n+      \n+      for (const setting of settingsArray) {\n+        // 기존 설정이 있는지 확인\n+        const existingSettings = await this.getWeeklyHolidaySettingsByStaffAndWeek(setting.staffId, setting.weekStartDate);\n+        \n+        let savedSetting: import('./types').WeeklyHolidaySettings;\n+        \n+        if (existingSettings.length > 0) {\n+          // 업데이트\n+          const existing = existingSettings[0];\n+          savedSetting = {\n+            ...existing,\n+            ...setting,\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('weeklyHolidaySettings', 'readwrite', (store) => \n+            store.put(savedSetting)\n+          );\n+        } else {\n+          // 새로 추가\n+          savedSetting = {\n+            ...setting,\n+            id: this.generateUUID(),\n+            createdAt: new Date(),\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('weeklyHolidaySettings', 'readwrite', (store) => \n+            store.add(savedSetting)\n+          );\n+        }\n+        \n+        savedSettings.push(savedSetting);\n+      }\n+\n+      console.log('주별 휴일설정 저장 성공:', savedSettings.length);\n+      return savedSettings;\n+    } catch (error) {\n+      console.error('주별 휴일설정 저장 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 모든 주별 휴일설정 조회\n+   */\n+  async getWeeklyHolidaySettingsByStaff(staffId: string): Promise<import('./types').WeeklyHolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('weeklyHolidaySettings', 'readonly', (store) => {\n+        const index = store.index('staffId');\n+        return index.getAll(IDBKeyRange.only(staffId));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('직원별 주별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 특정 주 휴일설정 조회\n+   */\n+  async getWeeklyHolidaySettingsByStaffAndWeek(staffId: string, weekStartDate: string): Promise<import('./types').WeeklyHolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('weeklyHolidaySettings', 'readonly', (store) => {\n+        const index = store.index('staffWeek');\n+        return index.getAll(IDBKeyRange.only([staffId, weekStartDate]));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('직원별 주별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 특정 주의 모든 휴일설정 조회\n+   */\n+  async getWeeklyHolidaySettingsByWeek(weekStartDate: string): Promise<import('./types').WeeklyHolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('weeklyHolidaySettings', 'readonly', (store) => {\n+        const index = store.index('weekStartDate');\n+        return index.getAll(IDBKeyRange.only(weekStartDate));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('주별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 주별 휴일설정 삭제\n+   */\n+  async deleteWeeklyHolidaySettings(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('weeklyHolidaySettings', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('주별 휴일설정 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('주별 휴일설정 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 모든 주별 휴일설정 삭제\n+   */\n+  async deleteWeeklyHolidaySettingsByStaff(staffId: string): Promise<boolean> {\n+    try {\n+      const settings = await this.getWeeklyHolidaySettingsByStaff(staffId);\n+      \n+      for (const setting of settings) {\n+        await this.deleteWeeklyHolidaySettings(setting.id);\n+      }\n+\n+      console.log('직원 주별 휴일설정 전체 삭제 성공:', staffId);\n+      return true;\n+    } catch (error) {\n+      console.error('직원 주별 휴일설정 전체 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 주어진 날짜가 휴일인지 확인하는 헬퍼 메소드\n+   */\n+  async isHolidayByDate(staffId: string, date: string): Promise<boolean> {\n+    try {\n+      const dateObj = new Date(date + 'T00:00:00');\n+      const dayOfWeek = dateObj.getDay(); // 0: 일요일, 1: 월요일, ...\n+      \n+      // 해당 주의 월요일 찾기\n+      const monday = new Date(dateObj);\n+      monday.setDate(dateObj.getDate() - (dayOfWeek === 0 ? 6 : dayOfWeek - 1));\n+      const weekStartDate = monday.toISOString().split('T')[0];\n+      \n+      const settings = await this.getWeeklyHolidaySettingsByStaffAndWeek(staffId, weekStartDate);\n+      \n+      if (settings.length === 0) {\n+        // 설정이 없으면 주말을 기본 휴일로 간주\n+        return dayOfWeek === 0 || dayOfWeek === 6;\n+      }\n+      \n+      const setting = settings[0];\n+      const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'] as const;\n+      const dayName = dayNames[dayOfWeek];\n+      \n+      return setting.weekDays[dayName];\n+    } catch (error) {\n+      console.error('휴일 여부 확인 실패:', error);\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * 다음주 월요일 날짜 계산 헬퍼 메소드\n+   */\n+  getNextMondayDate(): string {\n+    const today = new Date();\n+    const nextMonday = new Date(today);\n+    const dayOfWeek = today.getDay();\n+    \n+    // 다음주 월요일까지의 일수 계산\n+    const daysUntilNextMonday = dayOfWeek === 0 ? 1 : 8 - dayOfWeek;\n+    nextMonday.setDate(today.getDate() + daysUntilNextMonday);\n+    \n+    return nextMonday.toISOString().split('T')[0];\n+  }\n+\n+  /**\n+   * 현재 주 월요일 날짜 계산 헬퍼 메소드\n+   */\n+  getCurrentMondayDate(): string {\n+    const today = new Date();\n+    const monday = new Date(today);\n+    const dayOfWeek = today.getDay();\n+    \n+    // 이번주 월요일까지의 일수 계산\n+    const daysToMonday = dayOfWeek === 0 ? -6 : -(dayOfWeek - 1);\n+    monday.setDate(today.getDate() + daysToMonday);\n+    \n+    return monday.toISOString().split('T')[0];\n+  }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1761453398139,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -715,9 +715,9 @@\n       const setting = settings[0];\n       const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'] as const;\n       const dayName = dayNames[dayOfWeek];\n       \n-      return setting.weekDays[dayName];\n+      return setting.weekDays[dayName].isHoliday;\n     } catch (error) {\n       console.error('휴일 여부 확인 실패:', error);\n       return false;\n     }\n"
                },
                {
                    "date": 1761455802406,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -751,5 +751,202 @@\n     monday.setDate(today.getDate() + daysToMonday);\n     \n     return monday.toISOString().split('T')[0];\n   }\n+}\n+\n+// 스케줄 이벤트 서비스 클래스\n+export class ScheduleEventService extends BaseDBManager {\n+\n+  /**\n+   * 스케줄 이벤트 추가/업데이트\n+   */\n+  async saveScheduleEvents(events: Omit<import('./types').ScheduleEvent, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<import('./types').ScheduleEvent[]> {\n+    try {\n+      await this.initDB();\n+      if (!this.db) throw new Error('데이터베이스 연결 실패');\n+\n+      const transaction = this.db.transaction(['scheduleEvents'], 'readwrite');\n+      const store = transaction.objectStore('scheduleEvents');\n+      const savedEvents: import('./types').ScheduleEvent[] = [];\n+\n+      for (const eventData of events) {\n+        const now = new Date();\n+        const event: import('./types').ScheduleEvent = {\n+          ...eventData,\n+          id: `schedule-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n+          createdAt: now,\n+          updatedAt: now\n+        };\n+\n+        await store.add(event);\n+        savedEvents.push(event);\n+      }\n+\n+      return new Promise((resolve, reject) => {\n+        transaction.oncomplete = () => {\n+          console.log('스케줄 이벤트 저장 성공:', savedEvents.length);\n+          resolve(savedEvents);\n+        };\n+        transaction.onerror = () => reject(transaction.error);\n+      });\n+    } catch (error) {\n+      console.error('스케줄 이벤트 저장 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 출처의 스케줄 이벤트 삭제\n+   */\n+  async deleteScheduleEventsBySource(sourceType: string, sourceId?: string): Promise<void> {\n+    try {\n+      await this.initDB();\n+      if (!this.db) throw new Error('데이터베이스 연결 실패');\n+\n+      const transaction = this.db.transaction(['scheduleEvents'], 'readwrite');\n+      const store = transaction.objectStore('scheduleEvents');\n+      \n+      // sourceType으로 인덱스 검색\n+      const index = store.index('sourceType');\n+      const request = index.openCursor(IDBKeyRange.only(sourceType));\n+\n+      request.onsuccess = (event) => {\n+        const cursor = (event.target as IDBRequest).result;\n+        if (cursor) {\n+          const scheduleEvent = cursor.value as import('./types').ScheduleEvent;\n+          \n+          // sourceId가 지정된 경우 추가 필터링\n+          if (!sourceId || scheduleEvent.sourceId === sourceId) {\n+            cursor.delete();\n+          }\n+          \n+          cursor.continue();\n+        }\n+      };\n+\n+      return new Promise((resolve, reject) => {\n+        transaction.oncomplete = () => {\n+          console.log(`스케줄 이벤트 삭제 완료: sourceType=${sourceType}, sourceId=${sourceId}`);\n+          resolve();\n+        };\n+        transaction.onerror = () => reject(transaction.error);\n+      });\n+    } catch (error) {\n+      console.error('스케줄 이벤트 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 스케줄 이벤트 조회\n+   */\n+  async getScheduleEventsByStaff(staffId: string, startDate?: Date, endDate?: Date): Promise<import('./types').ScheduleEvent[]> {\n+    try {\n+      await this.initDB();\n+      if (!this.db) throw new Error('데이터베이스 연결 실패');\n+\n+      const transaction = this.db.transaction(['scheduleEvents'], 'readonly');\n+      const store = transaction.objectStore('scheduleEvents');\n+      const index = store.index('staffId');\n+      \n+      const events: import('./types').ScheduleEvent[] = [];\n+      const request = index.openCursor(IDBKeyRange.only(staffId));\n+\n+      request.onsuccess = (event) => {\n+        const cursor = (event.target as IDBRequest).result;\n+        if (cursor) {\n+          const scheduleEvent = cursor.value as import('./types').ScheduleEvent;\n+          \n+          // 날짜 범위 필터링\n+          if (startDate && endDate) {\n+            const eventStart = new Date(scheduleEvent.startTime);\n+            if (eventStart >= startDate && eventStart <= endDate) {\n+              events.push(scheduleEvent);\n+            }\n+          } else {\n+            events.push(scheduleEvent);\n+          }\n+          \n+          cursor.continue();\n+        }\n+      };\n+\n+      return new Promise((resolve, reject) => {\n+        transaction.oncomplete = () => resolve(events);\n+        transaction.onerror = () => reject(transaction.error);\n+      });\n+    } catch (error) {\n+      console.error('스케줄 이벤트 조회 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 스케줄 이벤트 조회\n+   */\n+  async getAllScheduleEvents(startDate?: Date, endDate?: Date): Promise<import('./types').ScheduleEvent[]> {\n+    try {\n+      await this.initDB();\n+      if (!this.db) throw new Error('데이터베이스 연결 실패');\n+\n+      const transaction = this.db.transaction(['scheduleEvents'], 'readonly');\n+      const store = transaction.objectStore('scheduleEvents');\n+      \n+      const events: import('./types').ScheduleEvent[] = [];\n+      const request = store.openCursor();\n+\n+      request.onsuccess = (event) => {\n+        const cursor = (event.target as IDBRequest).result;\n+        if (cursor) {\n+          const scheduleEvent = cursor.value as import('./types').ScheduleEvent;\n+          \n+          // 날짜 범위 필터링\n+          if (startDate && endDate) {\n+            const eventStart = new Date(scheduleEvent.startTime);\n+            if (eventStart >= startDate && eventStart <= endDate) {\n+              events.push(scheduleEvent);\n+            }\n+          } else {\n+            events.push(scheduleEvent);\n+          }\n+          \n+          cursor.continue();\n+        }\n+      };\n+\n+      return new Promise((resolve, reject) => {\n+        transaction.oncomplete = () => resolve(events);\n+        transaction.onerror = () => reject(transaction.error);\n+      });\n+    } catch (error) {\n+      console.error('스케줄 이벤트 조회 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 이벤트 삭제\n+   */\n+  async deleteScheduleEvent(eventId: string): Promise<void> {\n+    try {\n+      await this.initDB();\n+      if (!this.db) throw new Error('데이터베이스 연결 실패');\n+\n+      const transaction = this.db.transaction(['scheduleEvents'], 'readwrite');\n+      const store = transaction.objectStore('scheduleEvents');\n+      \n+      await store.delete(eventId);\n+      \n+      return new Promise((resolve, reject) => {\n+        transaction.oncomplete = () => {\n+          console.log('스케줄 이벤트 삭제 완료:', eventId);\n+          resolve();\n+        };\n+        transaction.onerror = () => reject(transaction.error);\n+      });\n+    } catch (error) {\n+      console.error('스케줄 이벤트 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1762427386669,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -365,23 +365,23 @@\n     }\n   }\n }\n \n-// 휴일설정 서비스 클래스\n-export class HolidayService extends BaseDBManager {\n+// WeeklyWorkSchedule 서비스 클래스 (근무시간/휴게시간만 관리, 휴일은 Staff.holidays 사용)\n+export class WeeklyWorkScheduleService extends BaseDBManager {\n \n   /**\n-   * 휴일설정 추가/업데이트\n+   * 주별 근무 스케줄 추가/업데이트\n    */\n-  async saveHolidaySettings(settingsArray: Omit<import('./types').HolidaySettings, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<import('./types').HolidaySettings[]> {\n+  async saveWeeklyWorkSchedule(settingsArray: Omit<import('./types').WeeklyWorkSchedule, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<import('./types').WeeklyWorkSchedule[]> {\n     try {\n-      const savedSettings: import('./types').HolidaySettings[] = [];\n+      const savedSettings: import('./types').WeeklyWorkSchedule[] = [];\n       \n       for (const setting of settingsArray) {\n         // 기존 설정이 있는지 확인\n-        const existingSettings = await this.getHolidaySettingsByStaffAndDate(setting.staffId, setting.date);\n+        const existingSettings = await this.getWeeklyWorkScheduleByStaffAndWeek(setting.staffId, setting.weekStartDate);\n         \n-        let savedSetting: import('./types').HolidaySettings;\n+        let savedSetting: import('./types').WeeklyWorkSchedule;\n         \n         if (existingSettings.length > 0) {\n           // 업데이트\n           const existing = existingSettings[0];\n@@ -390,9 +390,9 @@\n             ...setting,\n             updatedAt: new Date()\n           };\n           \n-          await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n+          await this.executeTransaction('weeklyWorkSchedule', 'readwrite', (store) => \n             store.put(savedSetting)\n           );\n         } else {\n           // 새로 추가\n@@ -402,30 +402,30 @@\n             createdAt: new Date(),\n             updatedAt: new Date()\n           };\n           \n-          await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n+          await this.executeTransaction('weeklyWorkSchedule', 'readwrite', (store) => \n             store.add(savedSetting)\n           );\n         }\n         \n         savedSettings.push(savedSetting);\n       }\n \n-      console.log('휴일설정 저장 성공:', savedSettings.length);\n+      console.log('주별 근무 스케줄 저장 성공:', savedSettings.length);\n       return savedSettings;\n     } catch (error) {\n-      console.error('휴일설정 저장 실패:', error);\n+      console.error('주별 근무 스케줄 저장 실패:', error);\n       throw error;\n     }\n   }\n \n   /**\n-   * 특정 직원의 모든 휴일설정 조회\n+   * 특정 직원의 모든 주별 근무 스케줄 조회\n    */\n-  async getHolidaySettingsByStaff(staffId: string): Promise<import('./types').HolidaySettings[]> {\n+  async getWeeklyWorkScheduleByStaff(staffId: string): Promise<import('./types').WeeklyWorkSchedule[]> {\n     try {\n-      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n+      const settings = await this.executeTransaction('weeklyWorkSchedule', 'readonly', (store) => {\n         const index = store.index('staffId');\n         return index.getAll(IDBKeyRange.only(staffId));\n       });\n       \n@@ -434,108 +434,65 @@\n         createdAt: new Date(setting.createdAt),\n         updatedAt: new Date(setting.updatedAt)\n       }));\n     } catch (error) {\n-      console.error('직원별 휴일설정 조회 실패:', error);\n+      console.error('직원별 주별 근무 스케줄 조회 실패:', error);\n       return [];\n     }\n   }\n \n   /**\n-   * 특정 직원의 특정 날짜 휴일설정 조회\n+   * 특정 직원의 특정 주 근무 스케줄 조회\n    */\n-  async getHolidaySettingsByStaffAndDate(staffId: string, date: string): Promise<import('./types').HolidaySettings[]> {\n+  async getWeeklyWorkScheduleByStaffAndWeek(staffId: string, weekStartDate: string): Promise<import('./types').WeeklyWorkSchedule[]> {\n     try {\n-      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n-        const index = store.index('staffDate');\n-        return index.getAll(IDBKeyRange.only([staffId, date]));\n+      const settings = await this.executeTransaction('weeklyWorkSchedule', 'readonly', (store) => {\n+        const index = store.index('staffWeek');\n+        return index.getAll(IDBKeyRange.only([staffId, weekStartDate]));\n       });\n       \n       return settings.map(setting => ({\n         ...setting,\n         createdAt: new Date(setting.createdAt),\n         updatedAt: new Date(setting.updatedAt)\n       }));\n     } catch (error) {\n-      console.error('직원별 날짜별 휴일설정 조회 실패:', error);\n+      console.error('직원별 주별 근무 스케줄 조회 실패:', error);\n       return [];\n     }\n   }\n \n   /**\n-   * 특정 날짜의 모든 휴일설정 조회\n+   * 주별 근무 스케줄 삭제\n    */\n-  async getHolidaySettingsByDate(date: string): Promise<import('./types').HolidaySettings[]> {\n+  async deleteWeeklyWorkSchedule(id: string): Promise<boolean> {\n     try {\n-      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n-        const index = store.index('date');\n-        return index.getAll(IDBKeyRange.only(date));\n-      });\n-      \n-      return settings.map(setting => ({\n-        ...setting,\n-        createdAt: new Date(setting.createdAt),\n-        updatedAt: new Date(setting.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('날짜별 휴일설정 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 날짜 범위의 휴일설정 조회\n-   */\n-  async getHolidaySettingsByDateRange(startDate: string, endDate: string): Promise<import('./types').HolidaySettings[]> {\n-    try {\n-      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n-        const index = store.index('date');\n-        return index.getAll(IDBKeyRange.bound(startDate, endDate));\n-      });\n-      \n-      return settings.map(setting => ({\n-        ...setting,\n-        createdAt: new Date(setting.createdAt),\n-        updatedAt: new Date(setting.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('날짜 범위별 휴일설정 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 휴일설정 삭제\n-   */\n-  async deleteHolidaySettings(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n+      await this.executeTransaction('weeklyWorkSchedule', 'readwrite', (store) => \n         store.delete(id)\n       );\n-\n-      console.log('휴일설정 삭제 성공:', id);\n+      console.log('주별 근무 스케줄 삭제 성공:', id);\n       return true;\n     } catch (error) {\n-      console.error('휴일설정 삭제 실패:', error);\n+      console.error('주별 근무 스케줄 삭제 실패:', error);\n       throw error;\n     }\n   }\n \n   /**\n-   * 특정 직원의 모든 휴일설정 삭제\n+   * 특정 직원의 모든 주별 근무 스케줄 삭제\n    */\n-  async deleteHolidaySettingsByStaff(staffId: string): Promise<boolean> {\n+  async deleteWeeklyWorkScheduleByStaff(staffId: string): Promise<boolean> {\n     try {\n-      const settings = await this.getHolidaySettingsByStaff(staffId);\n+      const settings = await this.getWeeklyWorkScheduleByStaff(staffId);\n       \n       for (const setting of settings) {\n-        await this.deleteHolidaySettings(setting.id);\n+        await this.deleteWeeklyWorkSchedule(setting.id);\n       }\n-\n-      console.log('직원 휴일설정 전체 삭제 성공:', staffId);\n+      \n+      console.log('직원 주별 근무 스케줄 전체 삭제 성공:', staffId);\n       return true;\n     } catch (error) {\n-      console.error('직원 휴일설정 전체 삭제 실패:', error);\n+      console.error('직원 주별 근무 스케줄 전체 삭제 실패:', error);\n       throw error;\n     }\n   }\n }\n"
                },
                {
                    "date": 1763865368742,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,959 @@\n+/**\n+ * 프로그램 및 상품 관리 서비스\n+ */\n+\n+import { BaseDBManager } from './BaseDBManager';\n+import { Program, Product } from './types';\n+\n+export class ProgramService extends BaseDBManager {\n+\n+  // =================== 프로그램 관리 메서드 ===================\n+\n+  /**\n+   * 프로그램 추가\n+   */\n+  async addProgram(programData: Omit<Program, 'id' | 'createdAt' | 'updatedAt'>): Promise<Program> {\n+    try {\n+      // 프로그램명 중복 체크\n+      const existingProgram = await this.getProgramByName(programData.name);\n+      if (existingProgram) {\n+        throw new Error('이미 존재하는 프로그램명입니다.');\n+      }\n+\n+      const newProgram: Program = {\n+        id: this.generateUUID(),\n+        ...programData,\n+        createdAt: new Date(),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.add(newProgram)\n+      );\n+\n+      console.log('프로그램 추가 성공:', newProgram);\n+      return newProgram;\n+    } catch (error) {\n+      console.error('프로그램 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 프로그램 조회\n+   */\n+  async getAllPrograms(): Promise<Program[]> {\n+    try {\n+      const programs = await this.executeTransaction('programs', 'readonly', (store) => \n+        store.getAll()\n+      );\n+      \n+      return programs.map(program => ({\n+        ...program,\n+        createdAt: new Date(program.createdAt),\n+        updatedAt: new Date(program.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('프로그램 목록 조회 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 프로그램명으로 조회\n+   */\n+  async getProgramByName(name: string): Promise<Program | null> {\n+    try {\n+      const program = await this.executeTransaction('programs', 'readonly', (store) => \n+        store.index('name').get(name)\n+      );\n+      \n+      if (program) {\n+        return {\n+          ...program,\n+          createdAt: new Date(program.createdAt),\n+          updatedAt: new Date(program.updatedAt)\n+        };\n+      }\n+      \n+      return null;\n+    } catch (error) {\n+      console.error('프로그램 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 프로그램 수정\n+   */\n+  async updateProgram(id: string, updates: Partial<Omit<Program, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Program | null> {\n+    try {\n+      const existingProgram = await this.executeTransaction('programs', 'readonly', (store) => \n+        store.get(id)\n+      );\n+\n+      if (!existingProgram) {\n+        console.error('수정할 프로그램을 찾을 수 없습니다:', id);\n+        return null;\n+      }\n+\n+      // 프로그램명 변경 시 중복 체크\n+      if (updates.name && updates.name !== existingProgram.name) {\n+        const duplicateProgram = await this.getProgramByName(updates.name);\n+        if (duplicateProgram) {\n+          throw new Error('이미 존재하는 프로그램명입니다.');\n+        }\n+      }\n+\n+      const updatedProgram: Program = {\n+        ...existingProgram,\n+        ...updates,\n+        id,\n+        createdAt: new Date(existingProgram.createdAt),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.put(updatedProgram)\n+      );\n+\n+      console.log('프로그램 수정 성공:', updatedProgram);\n+      return updatedProgram;\n+    } catch (error) {\n+      console.error('프로그램 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 프로그램 삭제\n+   */\n+  async deleteProgram(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('프로그램 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('프로그램 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+}\n+\n+export class ProductService extends BaseDBManager {\n+\n+  // =================== 상품 관리 메서드 ===================\n+\n+  /**\n+   * 상품 추가\n+   */\n+  async addProduct(productData: Omit<Product, 'id' | 'createdAt' | 'updatedAt'>): Promise<Product> {\n+    try {\n+      const newProduct: Product = {\n+        id: this.generateUUID(),\n+        ...productData,\n+        createdAt: new Date(),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.add(newProduct)\n+      );\n+\n+      console.log('상품 추가 성공:', newProduct);\n+      return newProduct;\n+    } catch (error) {\n+      console.error('상품 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 상품 조회\n+   */\n+  async getAllProducts(): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => \n+        store.getAll()\n+      );\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('상품 목록 조회 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * ID로 상품 조회\n+   */\n+  async getProductById(id: string): Promise<Product | null> {\n+    try {\n+      const product = await this.executeTransaction('products', 'readonly', (store) => \n+        store.get(id)\n+      );\n+      \n+      if (product) {\n+        return {\n+          ...product,\n+          createdAt: new Date(product.createdAt),\n+          updatedAt: new Date(product.updatedAt)\n+        };\n+      }\n+      \n+      return null;\n+    } catch (error) {\n+      console.error('상품 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 지점별 상품 조회\n+   */\n+  async getProductsByBranch(branchId: string): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('branchId');\n+        return index.getAll(IDBKeyRange.only(branchId));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('지점별 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 프로그램별 상품 조회\n+   */\n+  async getProductsByProgram(programId: string): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('programId');\n+        return index.getAll(IDBKeyRange.only(programId));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('프로그램별 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 지점과 프로그램으로 상품 조회\n+   */\n+  async getProductsByBranchAndProgram(branchId: string, programId: string): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('branchProgram');\n+        return index.getAll(IDBKeyRange.only([branchId, programId]));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('지점-프로그램별 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 상품 수정\n+   */\n+  async updateProduct(id: string, updates: Partial<Omit<Product, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Product | null> {\n+    try {\n+      const existingProduct = await this.executeTransaction('products', 'readonly', (store) => \n+        store.get(id)\n+      );\n+\n+      if (!existingProduct) {\n+        console.error('수정할 상품을 찾을 수 없습니다:', id);\n+        return null;\n+      }\n+\n+      const updatedProduct: Product = {\n+        ...existingProduct,\n+        ...updates,\n+        id,\n+        createdAt: new Date(existingProduct.createdAt),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.put(updatedProduct)\n+      );\n+\n+      console.log('상품 수정 성공:', updatedProduct);\n+      return updatedProduct;\n+    } catch (error) {\n+      console.error('상품 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 상품 삭제\n+   */\n+  async deleteProduct(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('상품 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('상품 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 활성 상품만 조회\n+   */\n+  async getActiveProducts(): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('isActive');\n+        return index.getAll(IDBKeyRange.only(true));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('활성 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 상품명으로 검색\n+   */\n+  async searchProductsByName(name: string): Promise<Product[]> {\n+    try {\n+      const allProducts = await this.getAllProducts();\n+      return allProducts.filter(product => \n+        product.name.toLowerCase().includes(name.toLowerCase())\n+      );\n+    } catch (error) {\n+      console.error('상품 검색 실패:', error);\n+      return [];\n+    }\n+  }\n+}\n+\n+// WeeklyWorkSchedule 서비스 클래스 (근무시간/휴게시간만 관리, 휴일은 Staff.holidays 사용)\n+export class WeeklyWorkScheduleService extends BaseDBManager {\n+\n+  /**\n+   * 주별 근무 스케줄 추가/업데이트\n+   */\n+  async saveWeeklyWorkSchedule(settingsArray: Omit<import('./types').WeeklyWorkSchedule, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<import('./types').WeeklyWorkSchedule[]> {\n+    try {\n+      const savedSettings: import('./types').WeeklyWorkSchedule[] = [];\n+      \n+      for (const setting of settingsArray) {\n+        // 기존 설정이 있는지 확인\n+        const existingSettings = await this.getWeeklyWorkScheduleByStaffAndWeek(setting.staffId, setting.weekStartDate);\n+        \n+        let savedSetting: import('./types').WeeklyWorkSchedule;\n+        \n+        if (existingSettings.length > 0) {\n+          // 업데이트\n+          const existing = existingSettings[0];\n+          savedSetting = {\n+            ...existing,\n+            ...setting,\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('weeklyWorkSchedule', 'readwrite', (store) => \n+            store.put(savedSetting)\n+          );\n+        } else {\n+          // 새로 추가\n+          savedSetting = {\n+            ...setting,\n+            id: this.generateUUID(),\n+            createdAt: new Date(),\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('weeklyWorkSchedule', 'readwrite', (store) => \n+            store.add(savedSetting)\n+          );\n+        }\n+        \n+        savedSettings.push(savedSetting);\n+      }\n+\n+      console.log('주별 근무 스케줄 저장 성공:', savedSettings.length);\n+      return savedSettings;\n+    } catch (error) {\n+      console.error('주별 근무 스케줄 저장 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 모든 주별 근무 스케줄 조회\n+   */\n+  async getWeeklyWorkScheduleByStaff(staffId: string): Promise<import('./types').WeeklyWorkSchedule[]> {\n+    try {\n+      const settings = await this.executeTransaction('weeklyWorkSchedule', 'readonly', (store) => {\n+        const index = store.index('staffId');\n+        return index.getAll(IDBKeyRange.only(staffId));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('직원별 주별 근무 스케줄 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 특정 주 근무 스케줄 조회\n+   */\n+  async getWeeklyWorkScheduleByStaffAndWeek(staffId: string, weekStartDate: string): Promise<import('./types').WeeklyWorkSchedule[]> {\n+    try {\n+      const settings = await this.executeTransaction('weeklyWorkSchedule', 'readonly', (store) => {\n+        const index = store.index('staffWeek');\n+        return index.getAll(IDBKeyRange.only([staffId, weekStartDate]));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('직원별 주별 근무 스케줄 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 주별 근무 스케줄 삭제\n+   */\n+  async deleteWeeklyWorkSchedule(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('weeklyWorkSchedule', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+      console.log('주별 근무 스케줄 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('주별 근무 스케줄 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 모든 주별 근무 스케줄 삭제\n+   */\n+  async deleteWeeklyWorkScheduleByStaff(staffId: string): Promise<boolean> {\n+    try {\n+      const settings = await this.getWeeklyWorkScheduleByStaff(staffId);\n+      \n+      for (const setting of settings) {\n+        await this.deleteWeeklyWorkSchedule(setting.id);\n+      }\n+      \n+      console.log('직원 주별 근무 스케줄 전체 삭제 성공:', staffId);\n+      return true;\n+    } catch (error) {\n+      console.error('직원 주별 근무 스케줄 전체 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+}\n+\n+// 주별 휴일설정 서비스 클래스\n+export class WeeklyHolidayService extends BaseDBManager {\n+\n+  /**\n+   * 주별 휴일설정 추가/업데이트\n+   */\n+  async saveWeeklyHolidaySettings(settingsArray: Omit<import('./types').WeeklyHolidaySettings, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<import('./types').WeeklyHolidaySettings[]> {\n+    try {\n+      const savedSettings: import('./types').WeeklyHolidaySettings[] = [];\n+      \n+      for (const setting of settingsArray) {\n+        // 기존 설정이 있는지 확인\n+        const existingSettings = await this.getWeeklyHolidaySettingsByStaffAndWeek(setting.staffId, setting.weekStartDate);\n+        \n+        let savedSetting: import('./types').WeeklyHolidaySettings;\n+        \n+        if (existingSettings.length > 0) {\n+          // 업데이트\n+          const existing = existingSettings[0];\n+          savedSetting = {\n+            ...existing,\n+            ...setting,\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('weeklyHolidaySettings', 'readwrite', (store) => \n+            store.put(savedSetting)\n+          );\n+        } else {\n+          // 새로 추가\n+          savedSetting = {\n+            ...setting,\n+            id: this.generateUUID(),\n+            createdAt: new Date(),\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('weeklyHolidaySettings', 'readwrite', (store) => \n+            store.add(savedSetting)\n+          );\n+        }\n+        \n+        savedSettings.push(savedSetting);\n+      }\n+\n+      console.log('주별 휴일설정 저장 성공:', savedSettings.length);\n+      return savedSettings;\n+    } catch (error) {\n+      console.error('주별 휴일설정 저장 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 모든 주별 휴일설정 조회\n+   */\n+  async getWeeklyHolidaySettingsByStaff(staffId: string): Promise<import('./types').WeeklyHolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('weeklyHolidaySettings', 'readonly', (store) => {\n+        const index = store.index('staffId');\n+        return index.getAll(IDBKeyRange.only(staffId));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('직원별 주별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 특정 주 휴일설정 조회\n+   */\n+  async getWeeklyHolidaySettingsByStaffAndWeek(staffId: string, weekStartDate: string): Promise<import('./types').WeeklyHolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('weeklyHolidaySettings', 'readonly', (store) => {\n+        const index = store.index('staffWeek');\n+        return index.getAll(IDBKeyRange.only([staffId, weekStartDate]));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('직원별 주별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 특정 주의 모든 휴일설정 조회\n+   */\n+  async getWeeklyHolidaySettingsByWeek(weekStartDate: string): Promise<import('./types').WeeklyHolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('weeklyHolidaySettings', 'readonly', (store) => {\n+        const index = store.index('weekStartDate');\n+        return index.getAll(IDBKeyRange.only(weekStartDate));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('주별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 주별 휴일설정 삭제\n+   */\n+  async deleteWeeklyHolidaySettings(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('weeklyHolidaySettings', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('주별 휴일설정 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('주별 휴일설정 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 모든 주별 휴일설정 삭제\n+   */\n+  async deleteWeeklyHolidaySettingsByStaff(staffId: string): Promise<boolean> {\n+    try {\n+      const settings = await this.getWeeklyHolidaySettingsByStaff(staffId);\n+      \n+      for (const setting of settings) {\n+        await this.deleteWeeklyHolidaySettings(setting.id);\n+      }\n+\n+      console.log('직원 주별 휴일설정 전체 삭제 성공:', staffId);\n+      return true;\n+    } catch (error) {\n+      console.error('직원 주별 휴일설정 전체 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 주어진 날짜가 휴일인지 확인하는 헬퍼 메소드\n+   */\n+  async isHolidayByDate(staffId: string, date: string): Promise<boolean> {\n+    try {\n+      const dateObj = new Date(date + 'T00:00:00');\n+      const dayOfWeek = dateObj.getDay(); // 0: 일요일, 1: 월요일, ...\n+      \n+      // 해당 주의 월요일 찾기\n+      const monday = new Date(dateObj);\n+      monday.setDate(dateObj.getDate() - (dayOfWeek === 0 ? 6 : dayOfWeek - 1));\n+      const weekStartDate = monday.toISOString().split('T')[0];\n+      \n+      const settings = await this.getWeeklyHolidaySettingsByStaffAndWeek(staffId, weekStartDate);\n+      \n+      if (settings.length === 0) {\n+        // 설정이 없으면 주말을 기본 휴일로 간주\n+        return dayOfWeek === 0 || dayOfWeek === 6;\n+      }\n+      \n+      const setting = settings[0];\n+      const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'] as const;\n+      const dayName = dayNames[dayOfWeek];\n+      \n+      return setting.weekDays[dayName].isHoliday;\n+    } catch (error) {\n+      console.error('휴일 여부 확인 실패:', error);\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * 다음주 월요일 날짜 계산 헬퍼 메소드\n+   */\n+  getNextMondayDate(): string {\n+    const today = new Date();\n+    const nextMonday = new Date(today);\n+    const dayOfWeek = today.getDay();\n+    \n+    // 다음주 월요일까지의 일수 계산\n+    const daysUntilNextMonday = dayOfWeek === 0 ? 1 : 8 - dayOfWeek;\n+    nextMonday.setDate(today.getDate() + daysUntilNextMonday);\n+    \n+    return nextMonday.toISOString().split('T')[0];\n+  }\n+\n+  /**\n+   * 현재 주 월요일 날짜 계산 헬퍼 메소드\n+   */\n+  getCurrentMondayDate(): string {\n+    const today = new Date();\n+    const monday = new Date(today);\n+    const dayOfWeek = today.getDay();\n+    \n+    // 이번주 월요일까지의 일수 계산\n+    const daysToMonday = dayOfWeek === 0 ? -6 : -(dayOfWeek - 1);\n+    monday.setDate(today.getDate() + daysToMonday);\n+    \n+    return monday.toISOString().split('T')[0];\n+  }\n+}\n+\n+// 스케줄 이벤트 서비스 클래스\n+export class ScheduleEventService extends BaseDBManager {\n+\n+  /**\n+   * 스케줄 이벤트 추가/업데이트\n+   */\n+  async saveScheduleEvents(events: Omit<import('./types').ScheduleEvent, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<import('./types').ScheduleEvent[]> {\n+    try {\n+      await this.initDB();\n+      if (!this.db) throw new Error('데이터베이스 연결 실패');\n+\n+      const transaction = this.db.transaction(['scheduleEvents'], 'readwrite');\n+      const store = transaction.objectStore('scheduleEvents');\n+      const savedEvents: import('./types').ScheduleEvent[] = [];\n+\n+      for (const eventData of events) {\n+        const now = new Date();\n+        const event: import('./types').ScheduleEvent = {\n+          ...eventData,\n+          id: `schedule-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n+          createdAt: now,\n+          updatedAt: now\n+        };\n+\n+        await store.add(event);\n+        savedEvents.push(event);\n+      }\n+\n+      return new Promise((resolve, reject) => {\n+        transaction.oncomplete = () => {\n+          console.log('스케줄 이벤트 저장 성공:', savedEvents.length);\n+          resolve(savedEvents);\n+        };\n+        transaction.onerror = () => reject(transaction.error);\n+      });\n+    } catch (error) {\n+      console.error('스케줄 이벤트 저장 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 출처의 스케줄 이벤트 삭제\n+   */\n+  async deleteScheduleEventsBySource(sourceType: string, sourceId?: string): Promise<void> {\n+    try {\n+      await this.initDB();\n+      if (!this.db) throw new Error('데이터베이스 연결 실패');\n+\n+      const transaction = this.db.transaction(['scheduleEvents'], 'readwrite');\n+      const store = transaction.objectStore('scheduleEvents');\n+      \n+      // sourceType으로 인덱스 검색\n+      const index = store.index('sourceType');\n+      const request = index.openCursor(IDBKeyRange.only(sourceType));\n+\n+      request.onsuccess = (event) => {\n+        const cursor = (event.target as IDBRequest).result;\n+        if (cursor) {\n+          const scheduleEvent = cursor.value as import('./types').ScheduleEvent;\n+          \n+          // sourceId가 지정된 경우 추가 필터링\n+          if (!sourceId || scheduleEvent.sourceId === sourceId) {\n+            cursor.delete();\n+          }\n+          \n+          cursor.continue();\n+        }\n+      };\n+\n+      return new Promise((resolve, reject) => {\n+        transaction.oncomplete = () => {\n+          console.log(`스케줄 이벤트 삭제 완료: sourceType=${sourceType}, sourceId=${sourceId}`);\n+          resolve();\n+        };\n+        transaction.onerror = () => reject(transaction.error);\n+      });\n+    } catch (error) {\n+      console.error('스케줄 이벤트 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 스케줄 이벤트 조회\n+   */\n+  async getScheduleEventsByStaff(staffId: string, startDate?: Date, endDate?: Date): Promise<import('./types').ScheduleEvent[]> {\n+    try {\n+      await this.initDB();\n+      if (!this.db) throw new Error('데이터베이스 연결 실패');\n+\n+      const transaction = this.db.transaction(['scheduleEvents'], 'readonly');\n+      const store = transaction.objectStore('scheduleEvents');\n+      const index = store.index('staffId');\n+      \n+      const events: import('./types').ScheduleEvent[] = [];\n+      const request = index.openCursor(IDBKeyRange.only(staffId));\n+\n+      request.onsuccess = (event) => {\n+        const cursor = (event.target as IDBRequest).result;\n+        if (cursor) {\n+          const scheduleEvent = cursor.value as import('./types').ScheduleEvent;\n+          \n+          // 날짜 범위 필터링\n+          if (startDate && endDate) {\n+            const eventStart = new Date(scheduleEvent.startTime);\n+            if (eventStart >= startDate && eventStart <= endDate) {\n+              events.push(scheduleEvent);\n+            }\n+          } else {\n+            events.push(scheduleEvent);\n+          }\n+          \n+          cursor.continue();\n+        }\n+      };\n+\n+      return new Promise((resolve, reject) => {\n+        transaction.oncomplete = () => resolve(events);\n+        transaction.onerror = () => reject(transaction.error);\n+      });\n+    } catch (error) {\n+      console.error('스케줄 이벤트 조회 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 스케줄 이벤트 조회\n+   */\n+  async getAllScheduleEvents(startDate?: Date, endDate?: Date): Promise<import('./types').ScheduleEvent[]> {\n+    try {\n+      await this.initDB();\n+      if (!this.db) throw new Error('데이터베이스 연결 실패');\n+\n+      const transaction = this.db.transaction(['scheduleEvents'], 'readonly');\n+      const store = transaction.objectStore('scheduleEvents');\n+      \n+      const events: import('./types').ScheduleEvent[] = [];\n+      const request = store.openCursor();\n+\n+      request.onsuccess = (event) => {\n+        const cursor = (event.target as IDBRequest).result;\n+        if (cursor) {\n+          const scheduleEvent = cursor.value as import('./types').ScheduleEvent;\n+          \n+          // 날짜 범위 필터링\n+          if (startDate && endDate) {\n+            const eventStart = new Date(scheduleEvent.startTime);\n+            if (eventStart >= startDate && eventStart <= endDate) {\n+              events.push(scheduleEvent);\n+            }\n+          } else {\n+            events.push(scheduleEvent);\n+          }\n+          \n+          cursor.continue();\n+        }\n+      };\n+\n+      return new Promise((resolve, reject) => {\n+        transaction.oncomplete = () => resolve(events);\n+        transaction.onerror = () => reject(transaction.error);\n+      });\n+    } catch (error) {\n+      console.error('스케줄 이벤트 조회 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 스케줄 이벤트 업데이트\n+   */\n+  async updateScheduleEvent(eventId: string, updates: Partial<import('./types').ScheduleEvent>): Promise<import('./types').ScheduleEvent> {\n+    try {\n+      await this.initDB();\n+      if (!this.db) throw new Error('데이터베이스 연결 실패');\n+\n+      const transaction = this.db.transaction(['scheduleEvents'], 'readwrite');\n+      const store = transaction.objectStore('scheduleEvents');\n+      \n+      // 기존 이벤트 조회\n+      const getRequest = store.get(eventId);\n+      \n+      return new Promise((resolve, reject) => {\n+        getRequest.onsuccess = () => {\n+          const existingEvent = getRequest.result as import('./types').ScheduleEvent;\n+          if (!existingEvent) {\n+            reject(new Error('이벤트를 찾을 수 없습니다'));\n+            return;\n+          }\n+\n+          // 업데이트된 이벤트 생성\n+          const updatedEvent: import('./types').ScheduleEvent = {\n+            ...existingEvent,\n+            ...updates,\n+            id: eventId, // ID는 변경 불가\n+            createdAt: existingEvent.createdAt, // 생성일은 유지\n+            updatedAt: new Date() // 수정일 업데이트\n+          };\n+\n+          // 업데이트 수행\n+          const putRequest = store.put(updatedEvent);\n+          \n+          putRequest.onsuccess = () => {\n+            console.log('스케줄 이벤트 업데이트 완료:', eventId);\n+            resolve(updatedEvent);\n+          };\n+          \n+          putRequest.onerror = () => reject(putRequest.error);\n+        };\n+        \n+        getRequest.onerror = () => reject(getRequest.error);\n+      });\n+    } catch (error) {\n+      console.error('스케줄 이벤트 업데이트 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 이벤트 삭제\n+   */\n+  async deleteScheduleEvent(eventId: string): Promise<void> {\n+    try {\n+      await this.initDB();\n+      if (!this.db) throw new Error('데이터베이스 연결 실패');\n+\n+      const transaction = this.db.transaction(['scheduleEvents'], 'readwrite');\n+      const store = transaction.objectStore('scheduleEvents');\n+      \n+      await store.delete(eventId);\n+      \n+      return new Promise((resolve, reject) => {\n+        transaction.oncomplete = () => {\n+          console.log('스케줄 이벤트 삭제 완료:', eventId);\n+          resolve();\n+        };\n+        transaction.onerror = () => reject(transaction.error);\n+      });\n+    } catch (error) {\n+      console.error('스케줄 이벤트 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763871650835,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,959 @@\n+/**\n+ * 프로그램 및 상품 관리 서비스\n+ */\n+\n+import { BaseDBManager } from './BaseDBManager';\n+import { Program, Product } from './types';\n+\n+export class ProgramService extends BaseDBManager {\n+\n+  // =================== 프로그램 관리 메서드 ===================\n+\n+  /**\n+   * 프로그램 추가\n+   */\n+  async addProgram(programData: Omit<Program, 'id' | 'createdAt' | 'updatedAt'>): Promise<Program> {\n+    try {\n+      // 프로그램명 중복 체크\n+      const existingProgram = await this.getProgramByName(programData.name);\n+      if (existingProgram) {\n+        throw new Error('이미 존재하는 프로그램명입니다.');\n+      }\n+\n+      const newProgram: Program = {\n+        id: this.generateUUID(),\n+        ...programData,\n+        createdAt: new Date(),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.add(newProgram)\n+      );\n+\n+      console.log('프로그램 추가 성공:', newProgram);\n+      return newProgram;\n+    } catch (error) {\n+      console.error('프로그램 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 프로그램 조회\n+   */\n+  async getAllPrograms(): Promise<Program[]> {\n+    try {\n+      const programs = await this.executeTransaction('programs', 'readonly', (store) => \n+        store.getAll()\n+      );\n+      \n+      return programs.map(program => ({\n+        ...program,\n+        createdAt: new Date(program.createdAt),\n+        updatedAt: new Date(program.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('프로그램 목록 조회 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 프로그램명으로 조회\n+   */\n+  async getProgramByName(name: string): Promise<Program | null> {\n+    try {\n+      const program = await this.executeTransaction('programs', 'readonly', (store) => \n+        store.index('name').get(name)\n+      );\n+      \n+      if (program) {\n+        return {\n+          ...program,\n+          createdAt: new Date(program.createdAt),\n+          updatedAt: new Date(program.updatedAt)\n+        };\n+      }\n+      \n+      return null;\n+    } catch (error) {\n+      console.error('프로그램 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 프로그램 수정\n+   */\n+  async updateProgram(id: string, updates: Partial<Omit<Program, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Program | null> {\n+    try {\n+      const existingProgram = await this.executeTransaction('programs', 'readonly', (store) => \n+        store.get(id)\n+      );\n+\n+      if (!existingProgram) {\n+        console.error('수정할 프로그램을 찾을 수 없습니다:', id);\n+        return null;\n+      }\n+\n+      // 프로그램명 변경 시 중복 체크\n+      if (updates.name && updates.name !== existingProgram.name) {\n+        const duplicateProgram = await this.getProgramByName(updates.name);\n+        if (duplicateProgram) {\n+          throw new Error('이미 존재하는 프로그램명입니다.');\n+        }\n+      }\n+\n+      const updatedProgram: Program = {\n+        ...existingProgram,\n+        ...updates,\n+        id,\n+        createdAt: new Date(existingProgram.createdAt),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.put(updatedProgram)\n+      );\n+\n+      console.log('프로그램 수정 성공:', updatedProgram);\n+      return updatedProgram;\n+    } catch (error) {\n+      console.error('프로그램 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 프로그램 삭제\n+   */\n+  async deleteProgram(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('프로그램 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('프로그램 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+}\n+\n+export class ProductService extends BaseDBManager {\n+\n+  // =================== 상품 관리 메서드 ===================\n+\n+  /**\n+   * 상품 추가\n+   */\n+  async addProduct(productData: Omit<Product, 'id' | 'createdAt' | 'updatedAt'>): Promise<Product> {\n+    try {\n+      const newProduct: Product = {\n+        id: this.generateUUID(),\n+        ...productData,\n+        createdAt: new Date(),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.add(newProduct)\n+      );\n+\n+      console.log('상품 추가 성공:', newProduct);\n+      return newProduct;\n+    } catch (error) {\n+      console.error('상품 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 상품 조회\n+   */\n+  async getAllProducts(): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => \n+        store.getAll()\n+      );\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('상품 목록 조회 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * ID로 상품 조회\n+   */\n+  async getProductById(id: string): Promise<Product | null> {\n+    try {\n+      const product = await this.executeTransaction('products', 'readonly', (store) => \n+        store.get(id)\n+      );\n+      \n+      if (product) {\n+        return {\n+          ...product,\n+          createdAt: new Date(product.createdAt),\n+          updatedAt: new Date(product.updatedAt)\n+        };\n+      }\n+      \n+      return null;\n+    } catch (error) {\n+      console.error('상품 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 지점별 상품 조회\n+   */\n+  async getProductsByBranch(branchId: string): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('branchId');\n+        return index.getAll(IDBKeyRange.only(branchId));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('지점별 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 프로그램별 상품 조회\n+   */\n+  async getProductsByProgram(programId: string): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('programId');\n+        return index.getAll(IDBKeyRange.only(programId));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('프로그램별 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 지점과 프로그램으로 상품 조회\n+   */\n+  async getProductsByBranchAndProgram(branchId: string, programId: string): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('branchProgram');\n+        return index.getAll(IDBKeyRange.only([branchId, programId]));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('지점-프로그램별 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 상품 수정\n+   */\n+  async updateProduct(id: string, updates: Partial<Omit<Product, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Product | null> {\n+    try {\n+      const existingProduct = await this.executeTransaction('products', 'readonly', (store) => \n+        store.get(id)\n+      );\n+\n+      if (!existingProduct) {\n+        console.error('수정할 상품을 찾을 수 없습니다:', id);\n+        return null;\n+      }\n+\n+      const updatedProduct: Product = {\n+        ...existingProduct,\n+        ...updates,\n+        id,\n+        createdAt: new Date(existingProduct.createdAt),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.put(updatedProduct)\n+      );\n+\n+      console.log('상품 수정 성공:', updatedProduct);\n+      return updatedProduct;\n+    } catch (error) {\n+      console.error('상품 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 상품 삭제\n+   */\n+  async deleteProduct(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('상품 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('상품 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 활성 상품만 조회\n+   */\n+  async getActiveProducts(): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('isActive');\n+        return index.getAll(IDBKeyRange.only(true));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('활성 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 상품명으로 검색\n+   */\n+  async searchProductsByName(name: string): Promise<Product[]> {\n+    try {\n+      const allProducts = await this.getAllProducts();\n+      return allProducts.filter(product => \n+        product.name.toLowerCase().includes(name.toLowerCase())\n+      );\n+    } catch (error) {\n+      console.error('상품 검색 실패:', error);\n+      return [];\n+    }\n+  }\n+}\n+\n+// WeeklyWorkSchedule 서비스 클래스 (근무시간/휴게시간만 관리, 휴일은 Staff.holidays 사용)\n+export class WeeklyWorkScheduleService extends BaseDBManager {\n+\n+  /**\n+   * 주별 근무 스케줄 추가/업데이트\n+   */\n+  async saveWeeklyWorkSchedule(settingsArray: Omit<import('./types').WeeklyWorkSchedule, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<import('./types').WeeklyWorkSchedule[]> {\n+    try {\n+      const savedSettings: import('./types').WeeklyWorkSchedule[] = [];\n+      \n+      for (const setting of settingsArray) {\n+        // 기존 설정이 있는지 확인\n+        const existingSettings = await this.getWeeklyWorkScheduleByStaffAndWeek(setting.staffId, setting.weekStartDate);\n+        \n+        let savedSetting: import('./types').WeeklyWorkSchedule;\n+        \n+        if (existingSettings.length > 0) {\n+          // 업데이트\n+          const existing = existingSettings[0];\n+          savedSetting = {\n+            ...existing,\n+            ...setting,\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('weeklyWorkSchedule', 'readwrite', (store) => \n+            store.put(savedSetting)\n+          );\n+        } else {\n+          // 새로 추가\n+          savedSetting = {\n+            ...setting,\n+            id: this.generateUUID(),\n+            createdAt: new Date(),\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('weeklyWorkSchedule', 'readwrite', (store) => \n+            store.add(savedSetting)\n+          );\n+        }\n+        \n+        savedSettings.push(savedSetting);\n+      }\n+\n+      console.log('주별 근무 스케줄 저장 성공:', savedSettings.length);\n+      return savedSettings;\n+    } catch (error) {\n+      console.error('주별 근무 스케줄 저장 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 모든 주별 근무 스케줄 조회\n+   */\n+  async getWeeklyWorkScheduleByStaff(staffId: string): Promise<import('./types').WeeklyWorkSchedule[]> {\n+    try {\n+      const settings = await this.executeTransaction('weeklyWorkSchedule', 'readonly', (store) => {\n+        const index = store.index('staffId');\n+        return index.getAll(IDBKeyRange.only(staffId));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('직원별 주별 근무 스케줄 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 특정 주 근무 스케줄 조회\n+   */\n+  async getWeeklyWorkScheduleByStaffAndWeek(staffId: string, weekStartDate: string): Promise<import('./types').WeeklyWorkSchedule[]> {\n+    try {\n+      const settings = await this.executeTransaction('weeklyWorkSchedule', 'readonly', (store) => {\n+        const index = store.index('staffWeek');\n+        return index.getAll(IDBKeyRange.only([staffId, weekStartDate]));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('직원별 주별 근무 스케줄 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 주별 근무 스케줄 삭제\n+   */\n+  async deleteWeeklyWorkSchedule(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('weeklyWorkSchedule', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+      console.log('주별 근무 스케줄 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('주별 근무 스케줄 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 모든 주별 근무 스케줄 삭제\n+   */\n+  async deleteWeeklyWorkScheduleByStaff(staffId: string): Promise<boolean> {\n+    try {\n+      const settings = await this.getWeeklyWorkScheduleByStaff(staffId);\n+      \n+      for (const setting of settings) {\n+        await this.deleteWeeklyWorkSchedule(setting.id);\n+      }\n+      \n+      console.log('직원 주별 근무 스케줄 전체 삭제 성공:', staffId);\n+      return true;\n+    } catch (error) {\n+      console.error('직원 주별 근무 스케줄 전체 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+}\n+\n+// 일별 스케줄설정 서비스 클래스\n+export class DailyScheduleService extends BaseDBManager {\n+\n+  /**\n+   * 일별 스케줄설정 저장/업데이트 (배열 일괄 처리)\n+   */\n+  async saveDailySchedules(settingsArray: Omit<import('./types').DailyScheduleSettings, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<import('./types').DailyScheduleSettings[]> {\n+    try {\n+      const savedSettings: import('./types').DailyScheduleSettings[] = [];\n+      \n+      for (const setting of settingsArray) {\n+        // 기존 설정이 있는지 확인 (staffId + date 조합)\n+        const existingSettings = await this.getDailySchedulesByStaffAndDate(setting.staffId, setting.date);\n+        \n+        let savedSetting: import('./types').WeeklyHolidaySettings;\n+        \n+        if (existingSettings.length > 0) {\n+          // 업데이트\n+          const existing = existingSettings[0];\n+          savedSetting = {\n+            ...existing,\n+            ...setting,\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('weeklyHolidaySettings', 'readwrite', (store) => \n+            store.put(savedSetting)\n+          );\n+        } else {\n+          // 새로 추가\n+          savedSetting = {\n+            ...setting,\n+            id: this.generateUUID(),\n+            createdAt: new Date(),\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('weeklyHolidaySettings', 'readwrite', (store) => \n+            store.add(savedSetting)\n+          );\n+        }\n+        \n+        savedSettings.push(savedSetting);\n+      }\n+\n+      console.log('일별 스케줄설정 저장 성공:', savedSettings.length);\n+      return savedSettings;\n+    } catch (error) {\n+      console.error('일별 스케줄설정 저장 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 모든 주별 휴일설정 조회\n+   */\n+  async getWeeklyHolidaySettingsByStaff(staffId: string): Promise<import('./types').WeeklyHolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('weeklyHolidaySettings', 'readonly', (store) => {\n+        const index = store.index('staffId');\n+        return index.getAll(IDBKeyRange.only(staffId));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('직원별 주별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 특정 주 휴일설정 조회\n+   */\n+  async getWeeklyHolidaySettingsByStaffAndWeek(staffId: string, weekStartDate: string): Promise<import('./types').WeeklyHolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('weeklyHolidaySettings', 'readonly', (store) => {\n+        const index = store.index('staffWeek');\n+        return index.getAll(IDBKeyRange.only([staffId, weekStartDate]));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('직원별 주별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 특정 주의 모든 휴일설정 조회\n+   */\n+  async getWeeklyHolidaySettingsByWeek(weekStartDate: string): Promise<import('./types').WeeklyHolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('weeklyHolidaySettings', 'readonly', (store) => {\n+        const index = store.index('weekStartDate');\n+        return index.getAll(IDBKeyRange.only(weekStartDate));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('주별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 주별 휴일설정 삭제\n+   */\n+  async deleteWeeklyHolidaySettings(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('weeklyHolidaySettings', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('주별 휴일설정 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('주별 휴일설정 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 모든 주별 휴일설정 삭제\n+   */\n+  async deleteWeeklyHolidaySettingsByStaff(staffId: string): Promise<boolean> {\n+    try {\n+      const settings = await this.getWeeklyHolidaySettingsByStaff(staffId);\n+      \n+      for (const setting of settings) {\n+        await this.deleteWeeklyHolidaySettings(setting.id);\n+      }\n+\n+      console.log('직원 주별 휴일설정 전체 삭제 성공:', staffId);\n+      return true;\n+    } catch (error) {\n+      console.error('직원 주별 휴일설정 전체 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 주어진 날짜가 휴일인지 확인하는 헬퍼 메소드\n+   */\n+  async isHolidayByDate(staffId: string, date: string): Promise<boolean> {\n+    try {\n+      const dateObj = new Date(date + 'T00:00:00');\n+      const dayOfWeek = dateObj.getDay(); // 0: 일요일, 1: 월요일, ...\n+      \n+      // 해당 주의 월요일 찾기\n+      const monday = new Date(dateObj);\n+      monday.setDate(dateObj.getDate() - (dayOfWeek === 0 ? 6 : dayOfWeek - 1));\n+      const weekStartDate = monday.toISOString().split('T')[0];\n+      \n+      const settings = await this.getWeeklyHolidaySettingsByStaffAndWeek(staffId, weekStartDate);\n+      \n+      if (settings.length === 0) {\n+        // 설정이 없으면 주말을 기본 휴일로 간주\n+        return dayOfWeek === 0 || dayOfWeek === 6;\n+      }\n+      \n+      const setting = settings[0];\n+      const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'] as const;\n+      const dayName = dayNames[dayOfWeek];\n+      \n+      return setting.weekDays[dayName].isHoliday;\n+    } catch (error) {\n+      console.error('휴일 여부 확인 실패:', error);\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * 다음주 월요일 날짜 계산 헬퍼 메소드\n+   */\n+  getNextMondayDate(): string {\n+    const today = new Date();\n+    const nextMonday = new Date(today);\n+    const dayOfWeek = today.getDay();\n+    \n+    // 다음주 월요일까지의 일수 계산\n+    const daysUntilNextMonday = dayOfWeek === 0 ? 1 : 8 - dayOfWeek;\n+    nextMonday.setDate(today.getDate() + daysUntilNextMonday);\n+    \n+    return nextMonday.toISOString().split('T')[0];\n+  }\n+\n+  /**\n+   * 현재 주 월요일 날짜 계산 헬퍼 메소드\n+   */\n+  getCurrentMondayDate(): string {\n+    const today = new Date();\n+    const monday = new Date(today);\n+    const dayOfWeek = today.getDay();\n+    \n+    // 이번주 월요일까지의 일수 계산\n+    const daysToMonday = dayOfWeek === 0 ? -6 : -(dayOfWeek - 1);\n+    monday.setDate(today.getDate() + daysToMonday);\n+    \n+    return monday.toISOString().split('T')[0];\n+  }\n+}\n+\n+// 스케줄 이벤트 서비스 클래스\n+export class ScheduleEventService extends BaseDBManager {\n+\n+  /**\n+   * 스케줄 이벤트 추가/업데이트\n+   */\n+  async saveScheduleEvents(events: Omit<import('./types').ScheduleEvent, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<import('./types').ScheduleEvent[]> {\n+    try {\n+      await this.initDB();\n+      if (!this.db) throw new Error('데이터베이스 연결 실패');\n+\n+      const transaction = this.db.transaction(['scheduleEvents'], 'readwrite');\n+      const store = transaction.objectStore('scheduleEvents');\n+      const savedEvents: import('./types').ScheduleEvent[] = [];\n+\n+      for (const eventData of events) {\n+        const now = new Date();\n+        const event: import('./types').ScheduleEvent = {\n+          ...eventData,\n+          id: `schedule-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n+          createdAt: now,\n+          updatedAt: now\n+        };\n+\n+        await store.add(event);\n+        savedEvents.push(event);\n+      }\n+\n+      return new Promise((resolve, reject) => {\n+        transaction.oncomplete = () => {\n+          console.log('스케줄 이벤트 저장 성공:', savedEvents.length);\n+          resolve(savedEvents);\n+        };\n+        transaction.onerror = () => reject(transaction.error);\n+      });\n+    } catch (error) {\n+      console.error('스케줄 이벤트 저장 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 출처의 스케줄 이벤트 삭제\n+   */\n+  async deleteScheduleEventsBySource(sourceType: string, sourceId?: string): Promise<void> {\n+    try {\n+      await this.initDB();\n+      if (!this.db) throw new Error('데이터베이스 연결 실패');\n+\n+      const transaction = this.db.transaction(['scheduleEvents'], 'readwrite');\n+      const store = transaction.objectStore('scheduleEvents');\n+      \n+      // sourceType으로 인덱스 검색\n+      const index = store.index('sourceType');\n+      const request = index.openCursor(IDBKeyRange.only(sourceType));\n+\n+      request.onsuccess = (event) => {\n+        const cursor = (event.target as IDBRequest).result;\n+        if (cursor) {\n+          const scheduleEvent = cursor.value as import('./types').ScheduleEvent;\n+          \n+          // sourceId가 지정된 경우 추가 필터링\n+          if (!sourceId || scheduleEvent.sourceId === sourceId) {\n+            cursor.delete();\n+          }\n+          \n+          cursor.continue();\n+        }\n+      };\n+\n+      return new Promise((resolve, reject) => {\n+        transaction.oncomplete = () => {\n+          console.log(`스케줄 이벤트 삭제 완료: sourceType=${sourceType}, sourceId=${sourceId}`);\n+          resolve();\n+        };\n+        transaction.onerror = () => reject(transaction.error);\n+      });\n+    } catch (error) {\n+      console.error('스케줄 이벤트 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 스케줄 이벤트 조회\n+   */\n+  async getScheduleEventsByStaff(staffId: string, startDate?: Date, endDate?: Date): Promise<import('./types').ScheduleEvent[]> {\n+    try {\n+      await this.initDB();\n+      if (!this.db) throw new Error('데이터베이스 연결 실패');\n+\n+      const transaction = this.db.transaction(['scheduleEvents'], 'readonly');\n+      const store = transaction.objectStore('scheduleEvents');\n+      const index = store.index('staffId');\n+      \n+      const events: import('./types').ScheduleEvent[] = [];\n+      const request = index.openCursor(IDBKeyRange.only(staffId));\n+\n+      request.onsuccess = (event) => {\n+        const cursor = (event.target as IDBRequest).result;\n+        if (cursor) {\n+          const scheduleEvent = cursor.value as import('./types').ScheduleEvent;\n+          \n+          // 날짜 범위 필터링\n+          if (startDate && endDate) {\n+            const eventStart = new Date(scheduleEvent.startTime);\n+            if (eventStart >= startDate && eventStart <= endDate) {\n+              events.push(scheduleEvent);\n+            }\n+          } else {\n+            events.push(scheduleEvent);\n+          }\n+          \n+          cursor.continue();\n+        }\n+      };\n+\n+      return new Promise((resolve, reject) => {\n+        transaction.oncomplete = () => resolve(events);\n+        transaction.onerror = () => reject(transaction.error);\n+      });\n+    } catch (error) {\n+      console.error('스케줄 이벤트 조회 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 스케줄 이벤트 조회\n+   */\n+  async getAllScheduleEvents(startDate?: Date, endDate?: Date): Promise<import('./types').ScheduleEvent[]> {\n+    try {\n+      await this.initDB();\n+      if (!this.db) throw new Error('데이터베이스 연결 실패');\n+\n+      const transaction = this.db.transaction(['scheduleEvents'], 'readonly');\n+      const store = transaction.objectStore('scheduleEvents');\n+      \n+      const events: import('./types').ScheduleEvent[] = [];\n+      const request = store.openCursor();\n+\n+      request.onsuccess = (event) => {\n+        const cursor = (event.target as IDBRequest).result;\n+        if (cursor) {\n+          const scheduleEvent = cursor.value as import('./types').ScheduleEvent;\n+          \n+          // 날짜 범위 필터링\n+          if (startDate && endDate) {\n+            const eventStart = new Date(scheduleEvent.startTime);\n+            if (eventStart >= startDate && eventStart <= endDate) {\n+              events.push(scheduleEvent);\n+            }\n+          } else {\n+            events.push(scheduleEvent);\n+          }\n+          \n+          cursor.continue();\n+        }\n+      };\n+\n+      return new Promise((resolve, reject) => {\n+        transaction.oncomplete = () => resolve(events);\n+        transaction.onerror = () => reject(transaction.error);\n+      });\n+    } catch (error) {\n+      console.error('스케줄 이벤트 조회 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 스케줄 이벤트 업데이트\n+   */\n+  async updateScheduleEvent(eventId: string, updates: Partial<import('./types').ScheduleEvent>): Promise<import('./types').ScheduleEvent> {\n+    try {\n+      await this.initDB();\n+      if (!this.db) throw new Error('데이터베이스 연결 실패');\n+\n+      const transaction = this.db.transaction(['scheduleEvents'], 'readwrite');\n+      const store = transaction.objectStore('scheduleEvents');\n+      \n+      // 기존 이벤트 조회\n+      const getRequest = store.get(eventId);\n+      \n+      return new Promise((resolve, reject) => {\n+        getRequest.onsuccess = () => {\n+          const existingEvent = getRequest.result as import('./types').ScheduleEvent;\n+          if (!existingEvent) {\n+            reject(new Error('이벤트를 찾을 수 없습니다'));\n+            return;\n+          }\n+\n+          // 업데이트된 이벤트 생성\n+          const updatedEvent: import('./types').ScheduleEvent = {\n+            ...existingEvent,\n+            ...updates,\n+            id: eventId, // ID는 변경 불가\n+            createdAt: existingEvent.createdAt, // 생성일은 유지\n+            updatedAt: new Date() // 수정일 업데이트\n+          };\n+\n+          // 업데이트 수행\n+          const putRequest = store.put(updatedEvent);\n+          \n+          putRequest.onsuccess = () => {\n+            console.log('스케줄 이벤트 업데이트 완료:', eventId);\n+            resolve(updatedEvent);\n+          };\n+          \n+          putRequest.onerror = () => reject(putRequest.error);\n+        };\n+        \n+        getRequest.onerror = () => reject(getRequest.error);\n+      });\n+    } catch (error) {\n+      console.error('스케줄 이벤트 업데이트 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 이벤트 삭제\n+   */\n+  async deleteScheduleEvent(eventId: string): Promise<void> {\n+    try {\n+      await this.initDB();\n+      if (!this.db) throw new Error('데이터베이스 연결 실패');\n+\n+      const transaction = this.db.transaction(['scheduleEvents'], 'readwrite');\n+      const store = transaction.objectStore('scheduleEvents');\n+      \n+      await store.delete(eventId);\n+      \n+      return new Promise((resolve, reject) => {\n+        transaction.oncomplete = () => {\n+          console.log('스케줄 이벤트 삭제 완료:', eventId);\n+          resolve();\n+        };\n+        transaction.onerror = () => reject(transaction.error);\n+      });\n+    } catch (error) {\n+      console.error('스케줄 이벤트 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1761368450406,
            "name": "Commit-0",
            "content": "/**\n * 프로그램 및 상품 관리 서비스\n */\n\nimport { BaseDBManager } from './BaseDBManager';\nimport { Program, Product } from './types';\n\nexport class ProgramService extends BaseDBManager {\n\n  // =================== 프로그램 관리 메서드 ===================\n\n  /**\n   * 프로그램 추가\n   */\n  async addProgram(programData: Omit<Program, 'id' | 'createdAt' | 'updatedAt'>): Promise<Program> {\n    try {\n      // 프로그램명 중복 체크\n      const existingProgram = await this.getProgramByName(programData.name);\n      if (existingProgram) {\n        throw new Error('이미 존재하는 프로그램명입니다.');\n      }\n\n      const newProgram: Program = {\n        id: this.generateUUID(),\n        ...programData,\n        createdAt: new Date(),\n        updatedAt: new Date()\n      };\n\n      await this.executeTransaction('programs', 'readwrite', (store) => \n        store.add(newProgram)\n      );\n\n      console.log('프로그램 추가 성공:', newProgram);\n      return newProgram;\n    } catch (error) {\n      console.error('프로그램 추가 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 모든 프로그램 조회\n   */\n  async getAllPrograms(): Promise<Program[]> {\n    try {\n      const programs = await this.executeTransaction('programs', 'readonly', (store) => \n        store.getAll()\n      );\n      \n      return programs.map(program => ({\n        ...program,\n        createdAt: new Date(program.createdAt),\n        updatedAt: new Date(program.updatedAt)\n      }));\n    } catch (error) {\n      console.error('프로그램 목록 조회 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 프로그램명으로 조회\n   */\n  async getProgramByName(name: string): Promise<Program | null> {\n    try {\n      const program = await this.executeTransaction('programs', 'readonly', (store) => \n        store.index('name').get(name)\n      );\n      \n      if (program) {\n        return {\n          ...program,\n          createdAt: new Date(program.createdAt),\n          updatedAt: new Date(program.updatedAt)\n        };\n      }\n      \n      return null;\n    } catch (error) {\n      console.error('프로그램 조회 실패:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 프로그램 수정\n   */\n  async updateProgram(id: string, updates: Partial<Omit<Program, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Program | null> {\n    try {\n      const existingProgram = await this.executeTransaction('programs', 'readonly', (store) => \n        store.get(id)\n      );\n\n      if (!existingProgram) {\n        console.error('수정할 프로그램을 찾을 수 없습니다:', id);\n        return null;\n      }\n\n      // 프로그램명 변경 시 중복 체크\n      if (updates.name && updates.name !== existingProgram.name) {\n        const duplicateProgram = await this.getProgramByName(updates.name);\n        if (duplicateProgram) {\n          throw new Error('이미 존재하는 프로그램명입니다.');\n        }\n      }\n\n      const updatedProgram: Program = {\n        ...existingProgram,\n        ...updates,\n        id,\n        createdAt: new Date(existingProgram.createdAt),\n        updatedAt: new Date()\n      };\n\n      await this.executeTransaction('programs', 'readwrite', (store) => \n        store.put(updatedProgram)\n      );\n\n      console.log('프로그램 수정 성공:', updatedProgram);\n      return updatedProgram;\n    } catch (error) {\n      console.error('프로그램 수정 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 프로그램 삭제\n   */\n  async deleteProgram(id: string): Promise<boolean> {\n    try {\n      await this.executeTransaction('programs', 'readwrite', (store) => \n        store.delete(id)\n      );\n\n      console.log('프로그램 삭제 성공:', id);\n      return true;\n    } catch (error) {\n      console.error('프로그램 삭제 실패:', error);\n      throw error;\n    }\n  }\n}\n\nexport class ProductService extends BaseDBManager {\n\n  // =================== 상품 관리 메서드 ===================\n\n  /**\n   * 상품 추가\n   */\n  async addProduct(productData: Omit<Product, 'id' | 'createdAt' | 'updatedAt'>): Promise<Product> {\n    try {\n      const newProduct: Product = {\n        id: this.generateUUID(),\n        ...productData,\n        createdAt: new Date(),\n        updatedAt: new Date()\n      };\n\n      await this.executeTransaction('products', 'readwrite', (store) => \n        store.add(newProduct)\n      );\n\n      console.log('상품 추가 성공:', newProduct);\n      return newProduct;\n    } catch (error) {\n      console.error('상품 추가 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 모든 상품 조회\n   */\n  async getAllProducts(): Promise<Product[]> {\n    try {\n      const products = await this.executeTransaction('products', 'readonly', (store) => \n        store.getAll()\n      );\n      \n      return products.map(product => ({\n        ...product,\n        createdAt: new Date(product.createdAt),\n        updatedAt: new Date(product.updatedAt)\n      }));\n    } catch (error) {\n      console.error('상품 목록 조회 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * ID로 상품 조회\n   */\n  async getProductById(id: string): Promise<Product | null> {\n    try {\n      const product = await this.executeTransaction('products', 'readonly', (store) => \n        store.get(id)\n      );\n      \n      if (product) {\n        return {\n          ...product,\n          createdAt: new Date(product.createdAt),\n          updatedAt: new Date(product.updatedAt)\n        };\n      }\n      \n      return null;\n    } catch (error) {\n      console.error('상품 조회 실패:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 지점별 상품 조회\n   */\n  async getProductsByBranch(branchId: string): Promise<Product[]> {\n    try {\n      const products = await this.executeTransaction('products', 'readonly', (store) => {\n        const index = store.index('branchId');\n        return index.getAll(IDBKeyRange.only(branchId));\n      });\n      \n      return products.map(product => ({\n        ...product,\n        createdAt: new Date(product.createdAt),\n        updatedAt: new Date(product.updatedAt)\n      }));\n    } catch (error) {\n      console.error('지점별 상품 조회 실패:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 프로그램별 상품 조회\n   */\n  async getProductsByProgram(programId: string): Promise<Product[]> {\n    try {\n      const products = await this.executeTransaction('products', 'readonly', (store) => {\n        const index = store.index('programId');\n        return index.getAll(IDBKeyRange.only(programId));\n      });\n      \n      return products.map(product => ({\n        ...product,\n        createdAt: new Date(product.createdAt),\n        updatedAt: new Date(product.updatedAt)\n      }));\n    } catch (error) {\n      console.error('프로그램별 상품 조회 실패:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 지점과 프로그램으로 상품 조회\n   */\n  async getProductsByBranchAndProgram(branchId: string, programId: string): Promise<Product[]> {\n    try {\n      const products = await this.executeTransaction('products', 'readonly', (store) => {\n        const index = store.index('branchProgram');\n        return index.getAll(IDBKeyRange.only([branchId, programId]));\n      });\n      \n      return products.map(product => ({\n        ...product,\n        createdAt: new Date(product.createdAt),\n        updatedAt: new Date(product.updatedAt)\n      }));\n    } catch (error) {\n      console.error('지점-프로그램별 상품 조회 실패:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 상품 수정\n   */\n  async updateProduct(id: string, updates: Partial<Omit<Product, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Product | null> {\n    try {\n      const existingProduct = await this.executeTransaction('products', 'readonly', (store) => \n        store.get(id)\n      );\n\n      if (!existingProduct) {\n        console.error('수정할 상품을 찾을 수 없습니다:', id);\n        return null;\n      }\n\n      const updatedProduct: Product = {\n        ...existingProduct,\n        ...updates,\n        id,\n        createdAt: new Date(existingProduct.createdAt),\n        updatedAt: new Date()\n      };\n\n      await this.executeTransaction('products', 'readwrite', (store) => \n        store.put(updatedProduct)\n      );\n\n      console.log('상품 수정 성공:', updatedProduct);\n      return updatedProduct;\n    } catch (error) {\n      console.error('상품 수정 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 상품 삭제\n   */\n  async deleteProduct(id: string): Promise<boolean> {\n    try {\n      await this.executeTransaction('products', 'readwrite', (store) => \n        store.delete(id)\n      );\n\n      console.log('상품 삭제 성공:', id);\n      return true;\n    } catch (error) {\n      console.error('상품 삭제 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 활성 상품만 조회\n   */\n  async getActiveProducts(): Promise<Product[]> {\n    try {\n      const products = await this.executeTransaction('products', 'readonly', (store) => {\n        const index = store.index('isActive');\n        return index.getAll(IDBKeyRange.only(true));\n      });\n      \n      return products.map(product => ({\n        ...product,\n        createdAt: new Date(product.createdAt),\n        updatedAt: new Date(product.updatedAt)\n      }));\n    } catch (error) {\n      console.error('활성 상품 조회 실패:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 상품명으로 검색\n   */\n  async searchProductsByName(name: string): Promise<Product[]> {\n    try {\n      const allProducts = await this.getAllProducts();\n      return allProducts.filter(product => \n        product.name.toLowerCase().includes(name.toLowerCase())\n      );\n    } catch (error) {\n      console.error('상품 검색 실패:', error);\n      return [];\n    }\n  }\n}\n\n// 휴일설정 서비스 클래스\nexport class HolidayService extends BaseDBManager {\n\n  /**\n   * 휴일설정 추가/업데이트\n   */\n  async saveHolidaySettings(settingsArray: Omit<import('./types').HolidaySettings, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<import('./types').HolidaySettings[]> {\n    try {\n      const savedSettings: import('./types').HolidaySettings[] = [];\n      \n      for (const setting of settingsArray) {\n        // 기존 설정이 있는지 확인\n        const existingSettings = await this.getHolidaySettingsByStaffAndDate(setting.staffId, setting.date);\n        \n        let savedSetting: import('./types').HolidaySettings;\n        \n        if (existingSettings.length > 0) {\n          // 업데이트\n          const existing = existingSettings[0];\n          savedSetting = {\n            ...existing,\n            ...setting,\n            updatedAt: new Date()\n          };\n          \n          await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n            store.put(savedSetting)\n          );\n        } else {\n          // 새로 추가\n          savedSetting = {\n            ...setting,\n            id: this.generateUUID(),\n            createdAt: new Date(),\n            updatedAt: new Date()\n          };\n          \n          await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n            store.add(savedSetting)\n          );\n        }\n        \n        savedSettings.push(savedSetting);\n      }\n\n      console.log('휴일설정 저장 성공:', savedSettings.length);\n      return savedSettings;\n    } catch (error) {\n      console.error('휴일설정 저장 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 특정 직원의 모든 휴일설정 조회\n   */\n  async getHolidaySettingsByStaff(staffId: string): Promise<import('./types').HolidaySettings[]> {\n    try {\n      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n        const index = store.index('staffId');\n        return index.getAll(IDBKeyRange.only(staffId));\n      });\n      \n      return settings.map(setting => ({\n        ...setting,\n        createdAt: new Date(setting.createdAt),\n        updatedAt: new Date(setting.updatedAt)\n      }));\n    } catch (error) {\n      console.error('직원별 휴일설정 조회 실패:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 특정 직원의 특정 날짜 휴일설정 조회\n   */\n  async getHolidaySettingsByStaffAndDate(staffId: string, date: string): Promise<import('./types').HolidaySettings[]> {\n    try {\n      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n        const index = store.index('staffDate');\n        return index.getAll(IDBKeyRange.only([staffId, date]));\n      });\n      \n      return settings.map(setting => ({\n        ...setting,\n        createdAt: new Date(setting.createdAt),\n        updatedAt: new Date(setting.updatedAt)\n      }));\n    } catch (error) {\n      console.error('직원별 날짜별 휴일설정 조회 실패:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 특정 날짜의 모든 휴일설정 조회\n   */\n  async getHolidaySettingsByDate(date: string): Promise<import('./types').HolidaySettings[]> {\n    try {\n      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n        const index = store.index('date');\n        return index.getAll(IDBKeyRange.only(date));\n      });\n      \n      return settings.map(setting => ({\n        ...setting,\n        createdAt: new Date(setting.createdAt),\n        updatedAt: new Date(setting.updatedAt)\n      }));\n    } catch (error) {\n      console.error('날짜별 휴일설정 조회 실패:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 날짜 범위의 휴일설정 조회\n   */\n  async getHolidaySettingsByDateRange(startDate: string, endDate: string): Promise<import('./types').HolidaySettings[]> {\n    try {\n      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n        const index = store.index('date');\n        return index.getAll(IDBKeyRange.bound(startDate, endDate));\n      });\n      \n      return settings.map(setting => ({\n        ...setting,\n        createdAt: new Date(setting.createdAt),\n        updatedAt: new Date(setting.updatedAt)\n      }));\n    } catch (error) {\n      console.error('날짜 범위별 휴일설정 조회 실패:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 휴일설정 삭제\n   */\n  async deleteHolidaySettings(id: string): Promise<boolean> {\n    try {\n      await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n        store.delete(id)\n      );\n\n      console.log('휴일설정 삭제 성공:', id);\n      return true;\n    } catch (error) {\n      console.error('휴일설정 삭제 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 특정 직원의 모든 휴일설정 삭제\n   */\n  async deleteHolidaySettingsByStaff(staffId: string): Promise<boolean> {\n    try {\n      const settings = await this.getHolidaySettingsByStaff(staffId);\n      \n      for (const setting of settings) {\n        await this.deleteHolidaySettings(setting.id);\n      }\n\n      console.log('직원 휴일설정 전체 삭제 성공:', staffId);\n      return true;\n    } catch (error) {\n      console.error('직원 휴일설정 전체 삭제 실패:', error);\n      throw error;\n    }\n  }\n}"
        }
    ]
}