{
    "sourceFile": "src/utils/db/TermsService.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1761368450658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1761368450658,
            "name": "Commit-0",
            "content": "/**\n * 약관 및 문서 관리 서비스\n */\n\nimport { BaseDBManager } from './BaseDBManager';\nimport { TermsDocument } from './types';\n\nexport class TermsService extends BaseDBManager {\n\n  /**\n   * 약관/문서 추가\n   */\n  async addTermsDocument(documentData: Omit<TermsDocument, 'id' | 'createdAt' | 'updatedAt' | 'version'>): Promise<TermsDocument> {\n    try {\n      // 같은 타입의 기존 문서들의 최대 버전 찾기\n      const existingDocs = await this.getTermsDocumentsByType(documentData.type);\n      const maxVersion = existingDocs.length > 0 ? Math.max(...existingDocs.map(doc => doc.version)) : 0;\n\n      // 기존 활성 문서들 비활성화\n      for (const doc of existingDocs.filter(d => d.isActive)) {\n        await this.updateTermsDocument(doc.id, { isActive: false });\n      }\n\n      const newDocument: TermsDocument = {\n        ...documentData,\n        id: this.generateUUID(),\n        version: maxVersion + 1,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        publishedAt: documentData.isActive ? new Date() : null\n      };\n\n      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n        store.add(newDocument)\n      );\n\n      console.log('약관/문서 추가 성공:', newDocument);\n      return newDocument;\n    } catch (error) {\n      console.error('약관/문서 추가 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 모든 약관/문서 조회\n   */\n  async getAllTermsDocuments(): Promise<TermsDocument[]> {\n    try {\n      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n        store.getAll()\n      );\n      \n      return documents.map(doc => ({\n        ...doc,\n        createdAt: new Date(doc.createdAt),\n        updatedAt: new Date(doc.updatedAt),\n        publishedAt: doc.publishedAt ? new Date(doc.publishedAt) : null\n      }));\n    } catch (error) {\n      console.error('약관/문서 목록 조회 실패:', error);\n      return [];\n    }\n  }\n\n  /**\n   * ID로 약관/문서 조회\n   */\n  async getTermsDocumentById(id: string): Promise<TermsDocument | null> {\n    try {\n      const document = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n        store.get(id)\n      );\n      \n      if (document) {\n        return {\n          ...document,\n          createdAt: new Date(document.createdAt),\n          updatedAt: new Date(document.updatedAt),\n          publishedAt: document.publishedAt ? new Date(document.publishedAt) : null\n        };\n      }\n      \n      return null;\n    } catch (error) {\n      console.error('약관/문서 조회 실패:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 타입별 약관/문서 조회\n   */\n  async getTermsDocumentsByType(type: TermsDocument['type']): Promise<TermsDocument[]> {\n    try {\n      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => {\n        return store.getAll();\n      });\n      \n      const filteredDocs = documents.filter(doc => doc.type === type);\n      \n      return filteredDocs.map(doc => ({\n        ...doc,\n        createdAt: new Date(doc.createdAt),\n        updatedAt: new Date(doc.updatedAt),\n        publishedAt: doc.publishedAt ? new Date(doc.publishedAt) : null\n      })).sort((a, b) => b.version - a.version); // 최신 버전부터\n    } catch (error) {\n      console.error('타입별 약관/문서 조회 실패:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 활성화된 약관/문서만 조회 (타입별)\n   */\n  async getActiveTermsDocument(type: TermsDocument['type']): Promise<TermsDocument | null> {\n    try {\n      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => {\n        return store.getAll();\n      });\n      \n      const activeDoc = documents.find(doc => doc.type === type && doc.isActive);\n      \n      if (!activeDoc) return null;\n\n      return {\n        ...activeDoc,\n        createdAt: new Date(activeDoc.createdAt),\n        updatedAt: new Date(activeDoc.updatedAt),\n        publishedAt: activeDoc.publishedAt ? new Date(activeDoc.publishedAt) : null\n      };\n    } catch (error) {\n      console.error('활성 약관/문서 조회 실패:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 약관/문서 수정\n   */\n  async updateTermsDocument(id: string, updates: Partial<Omit<TermsDocument, 'id' | 'createdAt' | 'updatedAt' | 'version'>>): Promise<TermsDocument | null> {\n    try {\n      const existingDocument = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n        store.get(id)\n      );\n\n      if (!existingDocument) {\n        console.error('수정할 약관/문서를 찾을 수 없습니다:', id);\n        return null;\n      }\n\n      // 활성화 시 같은 타입의 다른 문서들 비활성화\n      if (updates.isActive === true && !existingDocument.isActive) {\n        const otherDocs = await this.getTermsDocumentsByType(existingDocument.type);\n        for (const doc of otherDocs.filter((d: TermsDocument) => d.id !== id && d.isActive)) {\n          await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n            store.put({\n              ...doc,\n              isActive: false,\n              updatedAt: new Date()\n            })\n          );\n        }\n      }\n\n      const updatedDocument: TermsDocument = {\n        ...existingDocument,\n        ...updates,\n        id,\n        createdAt: new Date(existingDocument.createdAt),\n        updatedAt: new Date(),\n        publishedAt: updates.isActive === true && !existingDocument.isActive ? new Date() : \n                    updates.isActive === false ? null : \n                    existingDocument.publishedAt\n      };\n\n      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n        store.put(updatedDocument)\n      );\n\n      console.log('약관/문서 수정 성공:', updatedDocument);\n      return updatedDocument;\n    } catch (error) {\n      console.error('약관/문서 수정 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 약관/문서 삭제\n   */\n  async deleteTermsDocument(id: string): Promise<boolean> {\n    try {\n      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n        store.delete(id)\n      );\n\n      console.log('약관/문서 삭제 성공:', id);\n      return true;\n    } catch (error) {\n      console.error('약관/문서 삭제 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 약관/문서 검색 (제목, 내용)\n   */\n  async searchTermsDocuments(searchTerm: string): Promise<TermsDocument[]> {\n    try {\n      const allDocuments = await this.getAllTermsDocuments();\n      const lowerSearchTerm = searchTerm.toLowerCase();\n      \n      return allDocuments.filter(doc => \n        doc.title.toLowerCase().includes(lowerSearchTerm) ||\n        doc.content.toLowerCase().includes(lowerSearchTerm)\n      );\n    } catch (error) {\n      console.error('약관/문서 검색 실패:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 모든 활성 약관/문서 조회 (회원가입 시 사용)\n   */\n  async getAllActiveTermsDocuments(): Promise<TermsDocument[]> {\n    try {\n      const allDocuments = await this.getAllTermsDocuments();\n      return allDocuments.filter(doc => doc.isActive);\n    } catch (error) {\n      console.error('활성 약관/문서 조회 실패:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 약관 타입별 최신 버전 조회\n   */\n  async getLatestVersionByType(type: TermsDocument['type']): Promise<TermsDocument | null> {\n    try {\n      const documents = await this.getTermsDocumentsByType(type);\n      // 이미 최신 버전부터 정렬되어 있음\n      return documents.length > 0 ? documents[0] : null;\n    } catch (error) {\n      console.error('최신 버전 약관/문서 조회 실패:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 약관 버전 히스토리 조회\n   */\n  async getVersionHistory(type: TermsDocument['type']): Promise<TermsDocument[]> {\n    try {\n      return await this.getTermsDocumentsByType(type);\n    } catch (error) {\n      console.error('약관 버전 히스토리 조회 실패:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 약관 발행 (비활성 상태를 활성으로 변경)\n   */\n  async publishTermsDocument(id: string): Promise<TermsDocument | null> {\n    try {\n      return await this.updateTermsDocument(id, { \n        isActive: true,\n        publishedAt: new Date()\n      });\n    } catch (error) {\n      console.error('약관/문서 발행 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 약관 철회 (활성 상태를 비활성으로 변경)\n   */\n  async unpublishTermsDocument(id: string): Promise<TermsDocument | null> {\n    try {\n      return await this.updateTermsDocument(id, { \n        isActive: false,\n        publishedAt: null\n      });\n    } catch (error) {\n      console.error('약관/문서 철회 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 약관 복사 (새 버전 생성)\n   */\n  async duplicateTermsDocument(id: string, updates?: Partial<Pick<TermsDocument, 'title' | 'content'>>): Promise<TermsDocument> {\n    try {\n      const originalDoc = await this.getTermsDocumentById(id);\n      if (!originalDoc) {\n        throw new Error('복사할 약관/문서를 찾을 수 없습니다.');\n      }\n\n      return await this.addTermsDocument({\n        type: originalDoc.type,\n        title: updates?.title || `${originalDoc.title} (복사본)`,\n        content: updates?.content || originalDoc.content,\n        isActive: false // 복사본은 비활성 상태로 생성\n      });\n    } catch (error) {\n      console.error('약관/문서 복사 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 약관 타입별 통계\n   */\n  async getTermsStatsByType(): Promise<Record<TermsDocument['type'], {\n    total: number;\n    active: number;\n    inactive: number;\n    latestVersion: number;\n  }>> {\n    try {\n      const allDocuments = await this.getAllTermsDocuments();\n      const types: TermsDocument['type'][] = [\n        'privacy_policy', 'terms_of_service', 'business_info', \n        'marketing_consent', 'member_terms', 'contract'\n      ];\n\n      const stats: any = {};\n\n      for (const type of types) {\n        const typeDocs = allDocuments.filter(doc => doc.type === type);\n        stats[type] = {\n          total: typeDocs.length,\n          active: typeDocs.filter(doc => doc.isActive).length,\n          inactive: typeDocs.filter(doc => !doc.isActive).length,\n          latestVersion: typeDocs.length > 0 ? Math.max(...typeDocs.map(doc => doc.version)) : 0\n        };\n      }\n\n      return stats;\n    } catch (error) {\n      console.error('약관 통계 조회 실패:', error);\n      return {} as any;\n    }\n  }\n}"
        }
    ]
}