{
    "sourceFile": "src/utils/indexedDB.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 34,
            "patches": [
                {
                    "date": 1759899370645,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1759899583922,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,8 +15,13 @@\n   phone?: string;\n   isActive: boolean;\n }\n \n+export interface AppSettings extends DBRecord {\n+  key: string;\n+  value: string;\n+}\n+\n class IndexedDBManager {\n   private dbName: string = 'LavidaDB';\n   private version: number = 1;\n   private db: IDBDatabase | null = null;\n"
                },
                {
                    "date": 1759901587684,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,11 +20,27 @@\n   key: string;\n   value: string;\n }\n \n+export interface Staff extends DBRecord {\n+  name: string;\n+  phone: string;\n+  email: string;\n+  branchId: string;\n+  position: string; // 직급\n+  role: string; // 직책\n+  employmentType: string; // 고용형태\n+  permission: string; // 권한\n+  contractStartDate: Date;\n+  contractEndDate: Date;\n+  contractFile?: File | null; // 계약서 파일\n+  contractFileName?: string; // 계약서 파일명 저장용\n+  contractFileData?: ArrayBuffer; // 계약서 파일 데이터 저장용\n+}\n+\n class IndexedDBManager {\n   private dbName: string = 'LavidaDB';\n-  private version: number = 1;\n+  private version: number = 2; // 버전 업데이트\n   private db: IDBDatabase | null = null;\n \n   constructor() {\n     this.initDB();\n@@ -58,10 +74,23 @@\n           branchStore.createIndex('isActive', 'isActive', { unique: false });\n           branchStore.createIndex('createdAt', 'createdAt', { unique: false });\n         }\n \n+        // 직원 테이블 생성\n+        if (!db.objectStoreNames.contains('staff')) {\n+          const staffStore = db.createObjectStore('staff', { keyPath: 'id' });\n+          staffStore.createIndex('name', 'name', { unique: false });\n+          staffStore.createIndex('email', 'email', { unique: true });\n+          staffStore.createIndex('branchId', 'branchId', { unique: false });\n+          staffStore.createIndex('position', 'position', { unique: false });\n+          staffStore.createIndex('role', 'role', { unique: false });\n+          staffStore.createIndex('employmentType', 'employmentType', { unique: false });\n+          staffStore.createIndex('permission', 'permission', { unique: false });\n+          staffStore.createIndex('createdAt', 'createdAt', { unique: false });\n+        }\n+\n         // 향후 다른 테이블들도 여기에 추가 가능\n-        // 예: 회원, 직원, 방문기록 등\n+        // 예: 회원, 방문기록 등\n       };\n     });\n   }\n \n@@ -226,16 +255,193 @@\n       return [];\n     }\n   }\n \n+  // === 직원 관리 메서드들 ===\n+\n   /**\n+   * 모든 직원 조회\n+   */\n+  async getAllStaff(): Promise<Staff[]> {\n+    try {\n+      return await this.executeTransaction('staff', 'readonly', (store) => \n+        store.getAll()\n+      );\n+    } catch (error) {\n+      console.error('직원 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * ID로 직원 조회\n+   */\n+  async getStaffById(id: string): Promise<Staff | null> {\n+    try {\n+      const result = await this.executeTransaction('staff', 'readonly', (store) => \n+        store.get(id)\n+      );\n+      return result || null;\n+    } catch (error) {\n+      console.error('직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 직원 추가\n+   */\n+  async addStaff(staffData: Omit<Staff, 'id' | 'createdAt' | 'updatedAt'>): Promise<Staff> {\n+    const now = new Date();\n+    \n+    // 파일 데이터 처리\n+    let contractFileData: ArrayBuffer | undefined;\n+    let contractFileName: string | undefined;\n+    \n+    if (staffData.contractFile) {\n+      contractFileData = await this.fileToArrayBuffer(staffData.contractFile);\n+      contractFileName = staffData.contractFile.name;\n+    }\n+\n+    const newStaff: Staff = {\n+      ...staffData,\n+      id: this.generateUUID(),\n+      createdAt: now,\n+      updatedAt: now,\n+      contractFile: undefined, // File 객체는 저장하지 않음\n+      contractFileName,\n+      contractFileData,\n+    };\n+\n+    try {\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.add(newStaff)\n+      );\n+      console.log('직원 추가 성공:', newStaff);\n+      return newStaff;\n+    } catch (error) {\n+      console.error('직원 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 직원 수정\n+   */\n+  async updateStaff(id: string, updates: Partial<Omit<Staff, 'id' | 'createdAt'>>): Promise<Staff | null> {\n+    try {\n+      const existing = await this.getStaffById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 직원입니다.');\n+      }\n+\n+      // 파일 데이터 처리\n+      let contractFileData = existing.contractFileData;\n+      let contractFileName = existing.contractFileName;\n+      \n+      if (updates.contractFile) {\n+        contractFileData = await this.fileToArrayBuffer(updates.contractFile);\n+        contractFileName = updates.contractFile.name;\n+      }\n+\n+      const updatedStaff: Staff = {\n+        ...existing,\n+        ...updates,\n+        updatedAt: new Date(),\n+        contractFile: undefined, // File 객체는 저장하지 않음\n+        contractFileName,\n+        contractFileData,\n+      };\n+\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.put(updatedStaff)\n+      );\n+\n+      console.log('직원 수정 성공:', updatedStaff);\n+      return updatedStaff;\n+    } catch (error) {\n+      console.error('직원 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 직원 삭제\n+   */\n+  async deleteStaff(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+      console.log('직원 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('직원 삭제 실패:', error);\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * 지점별 직원 조회\n+   */\n+  async getStaffByBranch(branchId: string): Promise<Staff[]> {\n+    try {\n+      return await this.executeTransaction('staff', 'readonly', (store) => {\n+        const index = store.index('branchId');\n+        return index.getAll(IDBKeyRange.only(branchId));\n+      });\n+    } catch (error) {\n+      console.error('지점별 직원 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 이메일로 직원 조회\n+   */\n+  async getStaffByEmail(email: string): Promise<Staff | null> {\n+    try {\n+      const result = await this.executeTransaction('staff', 'readonly', (store) => {\n+        const index = store.index('email');\n+        return index.get(email);\n+      });\n+      return result || null;\n+    } catch (error) {\n+      console.error('이메일로 직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 파일을 ArrayBuffer로 변환\n+   */\n+  private fileToArrayBuffer(file: File): Promise<ArrayBuffer> {\n+    return new Promise((resolve, reject) => {\n+      const reader = new FileReader();\n+      reader.onload = () => resolve(reader.result as ArrayBuffer);\n+      reader.onerror = () => reject(reader.error);\n+      reader.readAsArrayBuffer(file);\n+    });\n+  }\n+\n+  /**\n+   * ArrayBuffer를 Blob으로 변환 (파일 다운로드용)\n+   */\n+  arrayBufferToBlob(buffer: ArrayBuffer, mimeType: string): Blob {\n+    return new Blob([buffer], { type: mimeType });\n+  }\n+\n+  /**\n    * 데이터베이스 초기화 (개발/테스트용)\n    */\n   async clearAllData(): Promise<void> {\n     try {\n       await this.executeTransaction('branches', 'readwrite', (store) => \n         store.clear()\n       );\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.clear()\n+      );\n       console.log('모든 데이터 삭제 완료');\n     } catch (error) {\n       console.error('데이터 삭제 실패:', error);\n       throw error;\n"
                },
                {
                    "date": 1759907307408,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,8 +22,10 @@\n }\n \n export interface Staff extends DBRecord {\n   name: string;\n+  loginId: string; // 로그인 ID\n+  password: string; // 비밀번호\n   phone: string;\n   email: string;\n   branchId: string;\n   position: string; // 직급\n@@ -78,8 +80,9 @@\n         // 직원 테이블 생성\n         if (!db.objectStoreNames.contains('staff')) {\n           const staffStore = db.createObjectStore('staff', { keyPath: 'id' });\n           staffStore.createIndex('name', 'name', { unique: false });\n+          staffStore.createIndex('loginId', 'loginId', { unique: true });\n           staffStore.createIndex('email', 'email', { unique: true });\n           staffStore.createIndex('branchId', 'branchId', { unique: false });\n           staffStore.createIndex('position', 'position', { unique: false });\n           staffStore.createIndex('role', 'role', { unique: false });\n@@ -411,8 +414,24 @@\n     }\n   }\n \n   /**\n+   * 로그인ID로 직원 조회\n+   */\n+  async getStaffByLoginId(loginId: string): Promise<Staff | null> {\n+    try {\n+      const result = await this.executeTransaction('staff', 'readonly', (store) => {\n+        const index = store.index('loginId');\n+        return index.get(loginId);\n+      });\n+      return result || null;\n+    } catch (error) {\n+      console.error('로그인ID로 직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n    * 파일을 ArrayBuffer로 변환\n    */\n   private fileToArrayBuffer(file: File): Promise<ArrayBuffer> {\n     return new Promise((resolve, reject) => {\n"
                },
                {
                    "date": 1759910414055,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,531 @@\n+/**\n+ * IndexedDB를 활용한 로컬 데이터베이스 관리 유틸리티\n+ * 백엔드 연결 전까지 브라우저에서 데이터를 영구 저장\n+ */\n+\n+import { SYSTEM_ADMIN_CONFIG } from '../constants/staffConstants';\n+\n+export interface DBRecord {\n+  id: string;\n+  createdAt: Date;\n+  updatedAt: Date;\n+}\n+\n+export interface Branch extends DBRecord {\n+  name: string;\n+  address?: string;\n+  phone?: string;\n+  isActive: boolean;\n+}\n+\n+export interface AppSettings extends DBRecord {\n+  key: string;\n+  value: string;\n+}\n+\n+export interface Staff extends DBRecord {\n+  name: string;\n+  loginId: string; // 로그인 ID\n+  password: string; // 비밀번호\n+  phone: string;\n+  email: string;\n+  branchId: string;\n+  position: string; // 직급\n+  role: string; // 직책\n+  employmentType: string; // 고용형태\n+  permission: string; // 권한\n+  contractStartDate: Date;\n+  contractEndDate: Date;\n+  contractFile?: File | null; // 계약서 파일\n+  contractFileName?: string; // 계약서 파일명 저장용\n+  contractFileData?: ArrayBuffer; // 계약서 파일 데이터 저장용\n+}\n+\n+class IndexedDBManager {\n+  private dbName: string = 'LavidaDB';\n+  private version: number = 2; // 버전 업데이트\n+  private db: IDBDatabase | null = null;\n+\n+  constructor() {\n+    this.initDB();\n+  }\n+\n+  /**\n+   * IndexedDB 초기화\n+   */\n+  private async initDB(): Promise<void> {\n+    return new Promise((resolve, reject) => {\n+      const request = indexedDB.open(this.dbName, this.version);\n+\n+      request.onerror = () => {\n+        console.error('IndexedDB 열기 실패:', request.error);\n+        reject(request.error);\n+      };\n+\n+      request.onsuccess = () => {\n+        this.db = request.result;\n+        console.log('IndexedDB 연결 성공');\n+        resolve();\n+      };\n+\n+      request.onupgradeneeded = (event) => {\n+        const db = (event.target as IDBOpenDBRequest).result;\n+\n+        // 지점 테이블 생성\n+        if (!db.objectStoreNames.contains('branches')) {\n+          const branchStore = db.createObjectStore('branches', { keyPath: 'id' });\n+          branchStore.createIndex('name', 'name', { unique: false });\n+          branchStore.createIndex('isActive', 'isActive', { unique: false });\n+          branchStore.createIndex('createdAt', 'createdAt', { unique: false });\n+        }\n+\n+        // 직원 테이블 생성\n+        if (!db.objectStoreNames.contains('staff')) {\n+          const staffStore = db.createObjectStore('staff', { keyPath: 'id' });\n+          staffStore.createIndex('name', 'name', { unique: false });\n+          staffStore.createIndex('loginId', 'loginId', { unique: true });\n+          staffStore.createIndex('email', 'email', { unique: true });\n+          staffStore.createIndex('branchId', 'branchId', { unique: false });\n+          staffStore.createIndex('position', 'position', { unique: false });\n+          staffStore.createIndex('role', 'role', { unique: false });\n+          staffStore.createIndex('employmentType', 'employmentType', { unique: false });\n+          staffStore.createIndex('permission', 'permission', { unique: false });\n+          staffStore.createIndex('createdAt', 'createdAt', { unique: false });\n+        }\n+\n+        // 향후 다른 테이블들도 여기에 추가 가능\n+        // 예: 회원, 방문기록 등\n+      };\n+    });\n+  }\n+\n+  /**\n+   * 고유 ID 생성 (UUID v4 형식)\n+   */\n+  private generateUUID(): string {\n+    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n+      const r = Math.random() * 16 | 0;\n+      const v = c === 'x' ? r : ((r & 0x3) | 0x8);\n+      return v.toString(16);\n+    });\n+  }\n+\n+  /**\n+   * 트랜잭션 실행 헬퍼\n+   */\n+  private async executeTransaction<T>(\n+    storeName: string,\n+    mode: IDBTransactionMode,\n+    operation: (store: IDBObjectStore) => IDBRequest<T>\n+  ): Promise<T> {\n+    if (!this.db) {\n+      await this.initDB();\n+    }\n+\n+    return new Promise((resolve, reject) => {\n+      const transaction = this.db!.transaction([storeName], mode);\n+      const store = transaction.objectStore(storeName);\n+      const request = operation(store);\n+\n+      request.onsuccess = () => resolve(request.result);\n+      request.onerror = () => reject(request.error);\n+    });\n+  }\n+\n+  // === 지점 관리 메서드들 ===\n+\n+  /**\n+   * 모든 지점 조회\n+   */\n+  async getAllBranches(): Promise<Branch[]> {\n+    try {\n+      return await this.executeTransaction('branches', 'readonly', (store) => \n+        store.getAll()\n+      );\n+    } catch (error) {\n+      console.error('지점 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * ID로 지점 조회\n+   */\n+  async getBranchById(id: string): Promise<Branch | null> {\n+    try {\n+      const result = await this.executeTransaction('branches', 'readonly', (store) => \n+        store.get(id)\n+      );\n+      return result || null;\n+    } catch (error) {\n+      console.error('지점 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 지점 추가\n+   */\n+  async addBranch(branchData: Omit<Branch, 'id' | 'createdAt' | 'updatedAt'>): Promise<Branch> {\n+    const now = new Date();\n+    const newBranch: Branch = {\n+      ...branchData,\n+      id: this.generateUUID(),\n+      createdAt: now,\n+      updatedAt: now,\n+    };\n+\n+    try {\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.add(newBranch)\n+      );\n+      console.log('지점 추가 성공:', newBranch);\n+      return newBranch;\n+    } catch (error) {\n+      console.error('지점 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 지점 수정\n+   */\n+  async updateBranch(id: string, updates: Partial<Omit<Branch, 'id' | 'createdAt'>>): Promise<Branch | null> {\n+    try {\n+      const existing = await this.getBranchById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 지점입니다.');\n+      }\n+\n+      const updatedBranch: Branch = {\n+        ...existing,\n+        ...updates,\n+        updatedAt: new Date(),\n+      };\n+\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.put(updatedBranch)\n+      );\n+\n+      console.log('지점 수정 성공:', updatedBranch);\n+      return updatedBranch;\n+    } catch (error) {\n+      console.error('지점 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 지점 삭제\n+   */\n+  async deleteBranch(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+      console.log('지점 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('지점 삭제 실패:', error);\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * 활성 지점만 조회\n+   */\n+  async getActiveBranches(): Promise<Branch[]> {\n+    try {\n+      return await this.executeTransaction('branches', 'readonly', (store) => {\n+        const index = store.index('isActive');\n+        return index.getAll(IDBKeyRange.only(true));\n+      });\n+    } catch (error) {\n+      console.error('활성 지점 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 지점명으로 검색\n+   */\n+  async searchBranchesByName(name: string): Promise<Branch[]> {\n+    try {\n+      const allBranches = await this.getAllBranches();\n+      return allBranches.filter(branch => \n+        branch.name.toLowerCase().includes(name.toLowerCase())\n+      );\n+    } catch (error) {\n+      console.error('지점 검색 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  // === 직원 관리 메서드들 ===\n+\n+  /**\n+   * 모든 직원 조회\n+   */\n+  async getAllStaff(): Promise<Staff[]> {\n+    try {\n+      return await this.executeTransaction('staff', 'readonly', (store) => \n+        store.getAll()\n+      );\n+    } catch (error) {\n+      console.error('직원 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * ID로 직원 조회\n+   */\n+  async getStaffById(id: string): Promise<Staff | null> {\n+    try {\n+      const result = await this.executeTransaction('staff', 'readonly', (store) => \n+        store.get(id)\n+      );\n+      return result || null;\n+    } catch (error) {\n+      console.error('직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 직원 추가\n+   */\n+  async addStaff(staffData: Omit<Staff, 'id' | 'createdAt' | 'updatedAt'>): Promise<Staff> {\n+    const now = new Date();\n+    \n+    // 파일 데이터 처리\n+    let contractFileData: ArrayBuffer | undefined;\n+    let contractFileName: string | undefined;\n+    \n+    if (staffData.contractFile) {\n+      contractFileData = await this.fileToArrayBuffer(staffData.contractFile);\n+      contractFileName = staffData.contractFile.name;\n+    }\n+\n+    const newStaff: Staff = {\n+      ...staffData,\n+      id: this.generateUUID(),\n+      createdAt: now,\n+      updatedAt: now,\n+      contractFile: undefined, // File 객체는 저장하지 않음\n+      contractFileName,\n+      contractFileData,\n+    };\n+\n+    try {\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.add(newStaff)\n+      );\n+      console.log('직원 추가 성공:', newStaff);\n+      return newStaff;\n+    } catch (error) {\n+      console.error('직원 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 시스템 관리자 계정인지 확인\n+   */\n+  private isSystemAdmin(staff: Staff): boolean {\n+    return staff.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID;\n+  }\n+\n+  /**\n+   * 시스템 관리자 보호 검증\n+   */\n+  private validateSystemAdminProtection(staff: Staff, operation: 'delete' | 'permission_change'): void {\n+    if (this.isSystemAdmin(staff)) {\n+      const message = operation === 'delete' \n+        ? '시스템 관리자 계정은 삭제할 수 없습니다.'\n+        : '시스템 관리자 계정의 권한은 변경할 수 없습니다.';\n+      throw new Error(message);\n+    }\n+  }\n+\n+  /**\n+   * 직원 수정\n+   */\n+  async updateStaff(id: string, updates: Partial<Omit<Staff, 'id' | 'createdAt'>>): Promise<Staff | null> {\n+    try {\n+      const existing = await this.getStaffById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 직원입니다.');\n+      }\n+\n+      // 시스템 관리자 권한 변경 보호\n+      if (updates.permission && updates.permission !== existing.permission) {\n+        this.validateSystemAdminProtection(existing, 'permission_change');\n+      }\n+\n+      // 파일 데이터 처리\n+      let contractFileData = existing.contractFileData;\n+      let contractFileName = existing.contractFileName;\n+      \n+      if (updates.contractFile) {\n+        contractFileData = await this.fileToArrayBuffer(updates.contractFile);\n+        contractFileName = updates.contractFile.name;\n+      }\n+\n+      const updatedStaff: Staff = {\n+        ...existing,\n+        ...updates,\n+        updatedAt: new Date(),\n+        contractFile: undefined, // File 객체는 저장하지 않음\n+        contractFileName,\n+        contractFileData,\n+      };\n+\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.put(updatedStaff)\n+      );\n+\n+      console.log('직원 수정 성공:', updatedStaff);\n+      return updatedStaff;\n+    } catch (error) {\n+      console.error('직원 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 직원 삭제\n+   */\n+  async deleteStaff(id: string): Promise<boolean> {\n+    try {\n+      const existing = await this.getStaffById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 직원입니다.');\n+      }\n+\n+      // 시스템 관리자 삭제 보호\n+      this.validateSystemAdminProtection(existing, 'delete');\n+\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+      console.log('직원 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('직원 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 지점별 직원 조회\n+   */\n+  async getStaffByBranch(branchId: string): Promise<Staff[]> {\n+    try {\n+      return await this.executeTransaction('staff', 'readonly', (store) => {\n+        const index = store.index('branchId');\n+        return index.getAll(IDBKeyRange.only(branchId));\n+      });\n+    } catch (error) {\n+      console.error('지점별 직원 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 이메일로 직원 조회\n+   */\n+  async getStaffByEmail(email: string): Promise<Staff | null> {\n+    try {\n+      const result = await this.executeTransaction('staff', 'readonly', (store) => {\n+        const index = store.index('email');\n+        return index.get(email);\n+      });\n+      return result || null;\n+    } catch (error) {\n+      console.error('이메일로 직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 로그인ID로 직원 조회\n+   */\n+  async getStaffByLoginId(loginId: string): Promise<Staff | null> {\n+    try {\n+      const result = await this.executeTransaction('staff', 'readonly', (store) => {\n+        const index = store.index('loginId');\n+        return index.get(loginId);\n+      });\n+      return result || null;\n+    } catch (error) {\n+      console.error('로그인ID로 직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 파일을 ArrayBuffer로 변환\n+   */\n+  private fileToArrayBuffer(file: File): Promise<ArrayBuffer> {\n+    return new Promise((resolve, reject) => {\n+      const reader = new FileReader();\n+      reader.onload = () => resolve(reader.result as ArrayBuffer);\n+      reader.onerror = () => reject(reader.error);\n+      reader.readAsArrayBuffer(file);\n+    });\n+  }\n+\n+  /**\n+   * ArrayBuffer를 Blob으로 변환 (파일 다운로드용)\n+   */\n+  arrayBufferToBlob(buffer: ArrayBuffer, mimeType: string): Blob {\n+    return new Blob([buffer], { type: mimeType });\n+  }\n+\n+  /**\n+   * 데이터베이스 초기화 (개발/테스트용)\n+   */\n+  async clearAllData(): Promise<void> {\n+    try {\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      console.log('모든 데이터 삭제 완료');\n+    } catch (error) {\n+      console.error('데이터 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 초기 샘플 데이터 생성\n+   */\n+  async seedSampleData(): Promise<void> {\n+    const sampleBranches = [\n+      { name: '강남점', address: '서울시 강남구', phone: '02-1234-5678', isActive: true },\n+      { name: '홍대점', address: '서울시 마포구', phone: '02-2345-6789', isActive: true },\n+      { name: '판교점', address: '경기도 성남시', phone: '031-3456-7890', isActive: true },\n+    ];\n+\n+    try {\n+      for (const branchData of sampleBranches) {\n+        await this.addBranch(branchData);\n+      }\n+      console.log('샘플 데이터 생성 완료');\n+    } catch (error) {\n+      console.error('샘플 데이터 생성 실패:', error);\n+    }\n+  }\n+}\n+\n+// 싱글톤 인스턴스 생성\n+export const dbManager = new IndexedDBManager();\n+\n+// 개발자 도구에서 사용할 수 있도록 전역 객체에 추가\n+if (typeof window !== 'undefined') {\n+  (window as any).dbManager = dbManager;\n+}\n"
                },
                {
                    "date": 1759911853295,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,9 +34,9 @@\n   role: string; // 직책\n   employmentType: string; // 고용형태\n   permission: string; // 권한\n   contractStartDate: Date;\n-  contractEndDate: Date;\n+  contractEndDate?: Date | null; // 계약종료일 (정규직은 없을 수 있음)\n   contractFile?: File | null; // 계약서 파일\n   contractFileName?: string; // 계약서 파일명 저장용\n   contractFileData?: ArrayBuffer; // 계약서 파일 데이터 저장용\n }\n@@ -528,501 +528,4 @@\n // 개발자 도구에서 사용할 수 있도록 전역 객체에 추가\n if (typeof window !== 'undefined') {\n   (window as any).dbManager = dbManager;\n }\n-/**\n- * IndexedDB를 활용한 로컬 데이터베이스 관리 유틸리티\n- * 백엔드 연결 전까지 브라우저에서 데이터를 영구 저장\n- */\n-\n-export interface DBRecord {\n-  id: string;\n-  createdAt: Date;\n-  updatedAt: Date;\n-}\n-\n-export interface Branch extends DBRecord {\n-  name: string;\n-  address?: string;\n-  phone?: string;\n-  isActive: boolean;\n-}\n-\n-export interface AppSettings extends DBRecord {\n-  key: string;\n-  value: string;\n-}\n-\n-export interface Staff extends DBRecord {\n-  name: string;\n-  loginId: string; // 로그인 ID\n-  password: string; // 비밀번호\n-  phone: string;\n-  email: string;\n-  branchId: string;\n-  position: string; // 직급\n-  role: string; // 직책\n-  employmentType: string; // 고용형태\n-  permission: string; // 권한\n-  contractStartDate: Date;\n-  contractEndDate: Date;\n-  contractFile?: File | null; // 계약서 파일\n-  contractFileName?: string; // 계약서 파일명 저장용\n-  contractFileData?: ArrayBuffer; // 계약서 파일 데이터 저장용\n-}\n-\n-class IndexedDBManager {\n-  private dbName: string = 'LavidaDB';\n-  private version: number = 2; // 버전 업데이트\n-  private db: IDBDatabase | null = null;\n-\n-  constructor() {\n-    this.initDB();\n-  }\n-\n-  /**\n-   * IndexedDB 초기화\n-   */\n-  private async initDB(): Promise<void> {\n-    return new Promise((resolve, reject) => {\n-      const request = indexedDB.open(this.dbName, this.version);\n-\n-      request.onerror = () => {\n-        console.error('IndexedDB 열기 실패:', request.error);\n-        reject(request.error);\n-      };\n-\n-      request.onsuccess = () => {\n-        this.db = request.result;\n-        console.log('IndexedDB 연결 성공');\n-        resolve();\n-      };\n-\n-      request.onupgradeneeded = (event) => {\n-        const db = (event.target as IDBOpenDBRequest).result;\n-\n-        // 지점 테이블 생성\n-        if (!db.objectStoreNames.contains('branches')) {\n-          const branchStore = db.createObjectStore('branches', { keyPath: 'id' });\n-          branchStore.createIndex('name', 'name', { unique: false });\n-          branchStore.createIndex('isActive', 'isActive', { unique: false });\n-          branchStore.createIndex('createdAt', 'createdAt', { unique: false });\n-        }\n-\n-        // 직원 테이블 생성\n-        if (!db.objectStoreNames.contains('staff')) {\n-          const staffStore = db.createObjectStore('staff', { keyPath: 'id' });\n-          staffStore.createIndex('name', 'name', { unique: false });\n-          staffStore.createIndex('loginId', 'loginId', { unique: true });\n-          staffStore.createIndex('email', 'email', { unique: true });\n-          staffStore.createIndex('branchId', 'branchId', { unique: false });\n-          staffStore.createIndex('position', 'position', { unique: false });\n-          staffStore.createIndex('role', 'role', { unique: false });\n-          staffStore.createIndex('employmentType', 'employmentType', { unique: false });\n-          staffStore.createIndex('permission', 'permission', { unique: false });\n-          staffStore.createIndex('createdAt', 'createdAt', { unique: false });\n-        }\n-\n-        // 향후 다른 테이블들도 여기에 추가 가능\n-        // 예: 회원, 방문기록 등\n-      };\n-    });\n-  }\n-\n-  /**\n-   * 고유 ID 생성 (UUID v4 형식)\n-   */\n-  private generateUUID(): string {\n-    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n-      const r = Math.random() * 16 | 0;\n-      const v = c === 'x' ? r : ((r & 0x3) | 0x8);\n-      return v.toString(16);\n-    });\n-  }\n-\n-  /**\n-   * 트랜잭션 실행 헬퍼\n-   */\n-  private async executeTransaction<T>(\n-    storeName: string,\n-    mode: IDBTransactionMode,\n-    operation: (store: IDBObjectStore) => IDBRequest<T>\n-  ): Promise<T> {\n-    if (!this.db) {\n-      await this.initDB();\n-    }\n-\n-    return new Promise((resolve, reject) => {\n-      const transaction = this.db!.transaction([storeName], mode);\n-      const store = transaction.objectStore(storeName);\n-      const request = operation(store);\n-\n-      request.onsuccess = () => resolve(request.result);\n-      request.onerror = () => reject(request.error);\n-    });\n-  }\n-\n-  // === 지점 관리 메서드들 ===\n-\n-  /**\n-   * 모든 지점 조회\n-   */\n-  async getAllBranches(): Promise<Branch[]> {\n-    try {\n-      return await this.executeTransaction('branches', 'readonly', (store) => \n-        store.getAll()\n-      );\n-    } catch (error) {\n-      console.error('지점 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * ID로 지점 조회\n-   */\n-  async getBranchById(id: string): Promise<Branch | null> {\n-    try {\n-      const result = await this.executeTransaction('branches', 'readonly', (store) => \n-        store.get(id)\n-      );\n-      return result || null;\n-    } catch (error) {\n-      console.error('지점 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 지점 추가\n-   */\n-  async addBranch(branchData: Omit<Branch, 'id' | 'createdAt' | 'updatedAt'>): Promise<Branch> {\n-    const now = new Date();\n-    const newBranch: Branch = {\n-      ...branchData,\n-      id: this.generateUUID(),\n-      createdAt: now,\n-      updatedAt: now,\n-    };\n-\n-    try {\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.add(newBranch)\n-      );\n-      console.log('지점 추가 성공:', newBranch);\n-      return newBranch;\n-    } catch (error) {\n-      console.error('지점 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 지점 수정\n-   */\n-  async updateBranch(id: string, updates: Partial<Omit<Branch, 'id' | 'createdAt'>>): Promise<Branch | null> {\n-    try {\n-      const existing = await this.getBranchById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 지점입니다.');\n-      }\n-\n-      const updatedBranch: Branch = {\n-        ...existing,\n-        ...updates,\n-        updatedAt: new Date(),\n-      };\n-\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.put(updatedBranch)\n-      );\n-\n-      console.log('지점 수정 성공:', updatedBranch);\n-      return updatedBranch;\n-    } catch (error) {\n-      console.error('지점 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 지점 삭제\n-   */\n-  async deleteBranch(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-      console.log('지점 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('지점 삭제 실패:', error);\n-      return false;\n-    }\n-  }\n-\n-  /**\n-   * 활성 지점만 조회\n-   */\n-  async getActiveBranches(): Promise<Branch[]> {\n-    try {\n-      return await this.executeTransaction('branches', 'readonly', (store) => {\n-        const index = store.index('isActive');\n-        return index.getAll(IDBKeyRange.only(true));\n-      });\n-    } catch (error) {\n-      console.error('활성 지점 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 지점명으로 검색\n-   */\n-  async searchBranchesByName(name: string): Promise<Branch[]> {\n-    try {\n-      const allBranches = await this.getAllBranches();\n-      return allBranches.filter(branch => \n-        branch.name.toLowerCase().includes(name.toLowerCase())\n-      );\n-    } catch (error) {\n-      console.error('지점 검색 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  // === 직원 관리 메서드들 ===\n-\n-  /**\n-   * 모든 직원 조회\n-   */\n-  async getAllStaff(): Promise<Staff[]> {\n-    try {\n-      return await this.executeTransaction('staff', 'readonly', (store) => \n-        store.getAll()\n-      );\n-    } catch (error) {\n-      console.error('직원 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * ID로 직원 조회\n-   */\n-  async getStaffById(id: string): Promise<Staff | null> {\n-    try {\n-      const result = await this.executeTransaction('staff', 'readonly', (store) => \n-        store.get(id)\n-      );\n-      return result || null;\n-    } catch (error) {\n-      console.error('직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 직원 추가\n-   */\n-  async addStaff(staffData: Omit<Staff, 'id' | 'createdAt' | 'updatedAt'>): Promise<Staff> {\n-    const now = new Date();\n-    \n-    // 파일 데이터 처리\n-    let contractFileData: ArrayBuffer | undefined;\n-    let contractFileName: string | undefined;\n-    \n-    if (staffData.contractFile) {\n-      contractFileData = await this.fileToArrayBuffer(staffData.contractFile);\n-      contractFileName = staffData.contractFile.name;\n-    }\n-\n-    const newStaff: Staff = {\n-      ...staffData,\n-      id: this.generateUUID(),\n-      createdAt: now,\n-      updatedAt: now,\n-      contractFile: undefined, // File 객체는 저장하지 않음\n-      contractFileName,\n-      contractFileData,\n-    };\n-\n-    try {\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.add(newStaff)\n-      );\n-      console.log('직원 추가 성공:', newStaff);\n-      return newStaff;\n-    } catch (error) {\n-      console.error('직원 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 직원 수정\n-   */\n-  async updateStaff(id: string, updates: Partial<Omit<Staff, 'id' | 'createdAt'>>): Promise<Staff | null> {\n-    try {\n-      const existing = await this.getStaffById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 직원입니다.');\n-      }\n-\n-      // 파일 데이터 처리\n-      let contractFileData = existing.contractFileData;\n-      let contractFileName = existing.contractFileName;\n-      \n-      if (updates.contractFile) {\n-        contractFileData = await this.fileToArrayBuffer(updates.contractFile);\n-        contractFileName = updates.contractFile.name;\n-      }\n-\n-      const updatedStaff: Staff = {\n-        ...existing,\n-        ...updates,\n-        updatedAt: new Date(),\n-        contractFile: undefined, // File 객체는 저장하지 않음\n-        contractFileName,\n-        contractFileData,\n-      };\n-\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.put(updatedStaff)\n-      );\n-\n-      console.log('직원 수정 성공:', updatedStaff);\n-      return updatedStaff;\n-    } catch (error) {\n-      console.error('직원 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 직원 삭제\n-   */\n-  async deleteStaff(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-      console.log('직원 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('직원 삭제 실패:', error);\n-      return false;\n-    }\n-  }\n-\n-  /**\n-   * 지점별 직원 조회\n-   */\n-  async getStaffByBranch(branchId: string): Promise<Staff[]> {\n-    try {\n-      return await this.executeTransaction('staff', 'readonly', (store) => {\n-        const index = store.index('branchId');\n-        return index.getAll(IDBKeyRange.only(branchId));\n-      });\n-    } catch (error) {\n-      console.error('지점별 직원 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 이메일로 직원 조회\n-   */\n-  async getStaffByEmail(email: string): Promise<Staff | null> {\n-    try {\n-      const result = await this.executeTransaction('staff', 'readonly', (store) => {\n-        const index = store.index('email');\n-        return index.get(email);\n-      });\n-      return result || null;\n-    } catch (error) {\n-      console.error('이메일로 직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 로그인ID로 직원 조회\n-   */\n-  async getStaffByLoginId(loginId: string): Promise<Staff | null> {\n-    try {\n-      const result = await this.executeTransaction('staff', 'readonly', (store) => {\n-        const index = store.index('loginId');\n-        return index.get(loginId);\n-      });\n-      return result || null;\n-    } catch (error) {\n-      console.error('로그인ID로 직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 파일을 ArrayBuffer로 변환\n-   */\n-  private fileToArrayBuffer(file: File): Promise<ArrayBuffer> {\n-    return new Promise((resolve, reject) => {\n-      const reader = new FileReader();\n-      reader.onload = () => resolve(reader.result as ArrayBuffer);\n-      reader.onerror = () => reject(reader.error);\n-      reader.readAsArrayBuffer(file);\n-    });\n-  }\n-\n-  /**\n-   * ArrayBuffer를 Blob으로 변환 (파일 다운로드용)\n-   */\n-  arrayBufferToBlob(buffer: ArrayBuffer, mimeType: string): Blob {\n-    return new Blob([buffer], { type: mimeType });\n-  }\n-\n-  /**\n-   * 데이터베이스 초기화 (개발/테스트용)\n-   */\n-  async clearAllData(): Promise<void> {\n-    try {\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      console.log('모든 데이터 삭제 완료');\n-    } catch (error) {\n-      console.error('데이터 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 초기 샘플 데이터 생성\n-   */\n-  async seedSampleData(): Promise<void> {\n-    const sampleBranches = [\n-      { name: '강남점', address: '서울시 강남구', phone: '02-1234-5678', isActive: true },\n-      { name: '홍대점', address: '서울시 마포구', phone: '02-2345-6789', isActive: true },\n-      { name: '판교점', address: '경기도 성남시', phone: '031-3456-7890', isActive: true },\n-    ];\n-\n-    try {\n-      for (const branchData of sampleBranches) {\n-        await this.addBranch(branchData);\n-      }\n-      console.log('샘플 데이터 생성 완료');\n-    } catch (error) {\n-      console.error('샘플 데이터 생성 실패:', error);\n-    }\n-  }\n-}\n-\n-// 싱글톤 인스턴스 생성\n-export const dbManager = new IndexedDBManager();\n-\n-// 개발자 도구에서 사용할 수 있도록 전역 객체에 추가\n-if (typeof window !== 'undefined') {\n-  (window as any).dbManager = dbManager;\n-}\n"
                },
                {
                    "date": 1759912075442,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -499,28 +499,8 @@\n       console.error('데이터 삭제 실패:', error);\n       throw error;\n     }\n   }\n-\n-  /**\n-   * 초기 샘플 데이터 생성\n-   */\n-  async seedSampleData(): Promise<void> {\n-    const sampleBranches = [\n-      { name: '강남점', address: '서울시 강남구', phone: '02-1234-5678', isActive: true },\n-      { name: '홍대점', address: '서울시 마포구', phone: '02-2345-6789', isActive: true },\n-      { name: '판교점', address: '경기도 성남시', phone: '031-3456-7890', isActive: true },\n-    ];\n-\n-    try {\n-      for (const branchData of sampleBranches) {\n-        await this.addBranch(branchData);\n-      }\n-      console.log('샘플 데이터 생성 완료');\n-    } catch (error) {\n-      console.error('샘플 데이터 생성 실패:', error);\n-    }\n-  }\n }\n \n // 싱글톤 인스턴스 생성\n export const dbManager = new IndexedDBManager();\n"
                },
                {
                    "date": 1759912582474,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -246,8 +246,22 @@\n     }\n   }\n \n   /**\n+   * 지점명으로 정확히 일치하는 지점 조회\n+   */\n+  async getBranchByName(name: string): Promise<Branch | null> {\n+    try {\n+      const allBranches = await this.getAllBranches();\n+      const branch = allBranches.find(branch => branch.name === name);\n+      return branch || null;\n+    } catch (error) {\n+      console.error('지점명으로 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n    * 지점명으로 검색\n    */\n   async searchBranchesByName(name: string): Promise<Branch[]> {\n     try {\n"
                },
                {
                    "date": 1759912714494,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,588 @@\n+/**\n+ * IndexedDB를 활용한 로컬 데이터베이스 관리 유틸리티\n+ * 백엔드 연결 전까지 브라우저에서 데이터를 영구 저장\n+ */\n+\n+import { SYSTEM_ADMIN_CONFIG } from '../constants/staffConstants';\n+\n+export interface DBRecord {\n+  id: string;\n+  createdAt: Date;\n+  updatedAt: Date;\n+}\n+\n+export interface Branch extends DBRecord {\n+  name: string;\n+  address?: string;\n+  phone?: string;\n+  isActive: boolean;\n+}\n+\n+export interface AppSettings extends DBRecord {\n+  key: string;\n+  value: string;\n+}\n+\n+export interface Staff extends DBRecord {\n+  name: string;\n+  loginId: string; // 로그인 ID\n+  password: string; // 비밀번호\n+  phone: string;\n+  email: string;\n+  branchId: string;\n+  position: string; // 직급\n+  role: string; // 직책\n+  employmentType: string; // 고용형태\n+  permission: string; // 권한\n+  contractStartDate: Date;\n+  contractEndDate?: Date | null; // 계약종료일 (정규직은 없을 수 있음)\n+  contractFile?: File | null; // 계약서 파일\n+  contractFileName?: string; // 계약서 파일명 저장용\n+  contractFileData?: ArrayBuffer; // 계약서 파일 데이터 저장용\n+}\n+\n+class IndexedDBManager {\n+  private dbName: string = 'LavidaDB';\n+  private version: number = 3; // 버전 업데이트 (지점명 unique 제약 추가)\n+  private db: IDBDatabase | null = null;\n+\n+  constructor() {\n+    this.initDB();\n+  }\n+\n+  /**\n+   * IndexedDB 초기화\n+   */\n+  private async initDB(): Promise<void> {\n+    return new Promise((resolve, reject) => {\n+      const request = indexedDB.open(this.dbName, this.version);\n+\n+      request.onerror = () => {\n+        console.error('IndexedDB 열기 실패:', request.error);\n+        reject(request.error);\n+      };\n+\n+      request.onsuccess = () => {\n+        this.db = request.result;\n+        console.log('IndexedDB 연결 성공');\n+        resolve();\n+      };\n+\n+      request.onupgradeneeded = (event) => {\n+        const db = (event.target as IDBOpenDBRequest).result;\n+\n+        // 지점 테이블 생성\n+        if (!db.objectStoreNames.contains('branches')) {\n+          const branchStore = db.createObjectStore('branches', { keyPath: 'id' });\n+          branchStore.createIndex('name', 'name', { unique: true }); // 지점명 고유 제약\n+          branchStore.createIndex('isActive', 'isActive', { unique: false });\n+          branchStore.createIndex('createdAt', 'createdAt', { unique: false });\n+        } else {\n+          // 기존 테이블이 있으면 인덱스 업데이트\n+          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n+          const branchStore = transaction.objectStore('branches');\n+          \n+          // 기존 name 인덱스 삭제 후 unique로 재생성\n+          if (branchStore.indexNames.contains('name')) {\n+            branchStore.deleteIndex('name');\n+          }\n+          branchStore.createIndex('name', 'name', { unique: true });\n+        }\n+\n+        // 직원 테이블 생성\n+        if (!db.objectStoreNames.contains('staff')) {\n+          const staffStore = db.createObjectStore('staff', { keyPath: 'id' });\n+          staffStore.createIndex('name', 'name', { unique: false });\n+          staffStore.createIndex('loginId', 'loginId', { unique: true });\n+          staffStore.createIndex('email', 'email', { unique: true });\n+          staffStore.createIndex('branchId', 'branchId', { unique: false });\n+          staffStore.createIndex('position', 'position', { unique: false });\n+          staffStore.createIndex('role', 'role', { unique: false });\n+          staffStore.createIndex('employmentType', 'employmentType', { unique: false });\n+          staffStore.createIndex('permission', 'permission', { unique: false });\n+          staffStore.createIndex('createdAt', 'createdAt', { unique: false });\n+        }\n+\n+        // 향후 다른 테이블들도 여기에 추가 가능\n+        // 예: 회원, 방문기록 등\n+      };\n+    });\n+  }\n+\n+  /**\n+   * 고유 ID 생성 (UUID v4 형식)\n+   */\n+  private generateUUID(): string {\n+    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n+      const r = Math.random() * 16 | 0;\n+      const v = c === 'x' ? r : ((r & 0x3) | 0x8);\n+      return v.toString(16);\n+    });\n+  }\n+\n+  /**\n+   * 트랜잭션 실행 헬퍼\n+   */\n+  private async executeTransaction<T>(\n+    storeName: string,\n+    mode: IDBTransactionMode,\n+    operation: (store: IDBObjectStore) => IDBRequest<T>\n+  ): Promise<T> {\n+    if (!this.db) {\n+      await this.initDB();\n+    }\n+\n+    return new Promise((resolve, reject) => {\n+      const transaction = this.db!.transaction([storeName], mode);\n+      const store = transaction.objectStore(storeName);\n+      const request = operation(store);\n+\n+      request.onsuccess = () => resolve(request.result);\n+      request.onerror = () => reject(request.error);\n+    });\n+  }\n+\n+  // === 지점 관리 메서드들 ===\n+\n+  /**\n+   * 모든 지점 조회\n+   */\n+  async getAllBranches(): Promise<Branch[]> {\n+    try {\n+      return await this.executeTransaction('branches', 'readonly', (store) => \n+        store.getAll()\n+      );\n+    } catch (error) {\n+      console.error('지점 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * ID로 지점 조회\n+   */\n+  async getBranchById(id: string): Promise<Branch | null> {\n+    try {\n+      const result = await this.executeTransaction('branches', 'readonly', (store) => \n+        store.get(id)\n+      );\n+      return result || null;\n+    } catch (error) {\n+      console.error('지점 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 지점 추가\n+   */\n+  async addBranch(branchData: Omit<Branch, 'id' | 'createdAt' | 'updatedAt'>): Promise<Branch> {\n+    const now = new Date();\n+    const newBranch: Branch = {\n+      ...branchData,\n+      id: this.generateUUID(),\n+      createdAt: now,\n+      updatedAt: now,\n+    };\n+\n+    try {\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.add(newBranch)\n+      );\n+      console.log('지점 추가 성공:', newBranch);\n+      return newBranch;\n+    } catch (error) {\n+      console.error('지점 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 지점 수정\n+   */\n+  async updateBranch(id: string, updates: Partial<Omit<Branch, 'id' | 'createdAt'>>): Promise<Branch | null> {\n+    try {\n+      const existing = await this.getBranchById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 지점입니다.');\n+      }\n+\n+      const updatedBranch: Branch = {\n+        ...existing,\n+        ...updates,\n+        updatedAt: new Date(),\n+      };\n+\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.put(updatedBranch)\n+      );\n+\n+      console.log('지점 수정 성공:', updatedBranch);\n+      return updatedBranch;\n+    } catch (error) {\n+      console.error('지점 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 지점 삭제\n+   */\n+  async deleteBranch(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+      console.log('지점 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('지점 삭제 실패:', error);\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * 활성 지점만 조회\n+   */\n+  async getActiveBranches(): Promise<Branch[]> {\n+    try {\n+      return await this.executeTransaction('branches', 'readonly', (store) => {\n+        const index = store.index('isActive');\n+        return index.getAll(IDBKeyRange.only(true));\n+      });\n+    } catch (error) {\n+      console.error('활성 지점 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 지점명으로 정확히 일치하는 지점 조회 또는 생성 (원자적 처리)\n+   * 동시 실행 시 race condition 방지\n+   */\n+  async getOrCreateBranchByName(name: string, branchData?: Omit<Branch, 'id' | 'createdAt' | 'updatedAt' | 'name'>): Promise<Branch> {\n+    if (!this.db) {\n+      await this.initDB();\n+    }\n+\n+    return new Promise((resolve, reject) => {\n+      const transaction = this.db!.transaction(['branches'], 'readwrite');\n+      const store = transaction.objectStore('branches');\n+      const index = store.index('name');\n+      \n+      // 먼저 기존 지점 확인\n+      const getRequest = index.get(name);\n+      \n+      getRequest.onsuccess = () => {\n+        if (getRequest.result) {\n+          // 이미 존재함\n+          resolve(getRequest.result);\n+        } else {\n+          // 존재하지 않음, 새로 생성\n+          const now = new Date();\n+          const newBranch: Branch = {\n+            name,\n+            address: branchData?.address || '',\n+            phone: branchData?.phone || '',\n+            isActive: branchData?.isActive ?? true,\n+            id: this.generateUUID(),\n+            createdAt: now,\n+            updatedAt: now,\n+          };\n+\n+          const addRequest = store.add(newBranch);\n+          addRequest.onsuccess = () => {\n+            console.log('새 지점 생성 완료:', newBranch);\n+            resolve(newBranch);\n+          };\n+          addRequest.onerror = () => {\n+            console.error('지점 추가 실패:', addRequest.error);\n+            reject(addRequest.error);\n+          };\n+        }\n+      };\n+      \n+      getRequest.onerror = () => {\n+        console.error('지점 조회 실패:', getRequest.error);\n+        reject(getRequest.error);\n+      };\n+    });\n+  }\n+\n+  /**\n+   * 지점명으로 정확히 일치하는 지점 조회\n+   */\n+  async getBranchByName(name: string): Promise<Branch | null> {\n+    try {\n+      const allBranches = await this.getAllBranches();\n+      const branch = allBranches.find(branch => branch.name === name);\n+      return branch || null;\n+    } catch (error) {\n+      console.error('지점명으로 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 지점명으로 검색\n+   */\n+  async searchBranchesByName(name: string): Promise<Branch[]> {\n+    try {\n+      const allBranches = await this.getAllBranches();\n+      return allBranches.filter(branch => \n+        branch.name.toLowerCase().includes(name.toLowerCase())\n+      );\n+    } catch (error) {\n+      console.error('지점 검색 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  // === 직원 관리 메서드들 ===\n+\n+  /**\n+   * 모든 직원 조회\n+   */\n+  async getAllStaff(): Promise<Staff[]> {\n+    try {\n+      return await this.executeTransaction('staff', 'readonly', (store) => \n+        store.getAll()\n+      );\n+    } catch (error) {\n+      console.error('직원 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * ID로 직원 조회\n+   */\n+  async getStaffById(id: string): Promise<Staff | null> {\n+    try {\n+      const result = await this.executeTransaction('staff', 'readonly', (store) => \n+        store.get(id)\n+      );\n+      return result || null;\n+    } catch (error) {\n+      console.error('직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 직원 추가\n+   */\n+  async addStaff(staffData: Omit<Staff, 'id' | 'createdAt' | 'updatedAt'>): Promise<Staff> {\n+    const now = new Date();\n+    \n+    // 파일 데이터 처리\n+    let contractFileData: ArrayBuffer | undefined;\n+    let contractFileName: string | undefined;\n+    \n+    if (staffData.contractFile) {\n+      contractFileData = await this.fileToArrayBuffer(staffData.contractFile);\n+      contractFileName = staffData.contractFile.name;\n+    }\n+\n+    const newStaff: Staff = {\n+      ...staffData,\n+      id: this.generateUUID(),\n+      createdAt: now,\n+      updatedAt: now,\n+      contractFile: undefined, // File 객체는 저장하지 않음\n+      contractFileName,\n+      contractFileData,\n+    };\n+\n+    try {\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.add(newStaff)\n+      );\n+      console.log('직원 추가 성공:', newStaff);\n+      return newStaff;\n+    } catch (error) {\n+      console.error('직원 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 시스템 관리자 계정인지 확인\n+   */\n+  private isSystemAdmin(staff: Staff): boolean {\n+    return staff.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID;\n+  }\n+\n+  /**\n+   * 시스템 관리자 보호 검증\n+   */\n+  private validateSystemAdminProtection(staff: Staff, operation: 'delete' | 'permission_change'): void {\n+    if (this.isSystemAdmin(staff)) {\n+      const message = operation === 'delete' \n+        ? '시스템 관리자 계정은 삭제할 수 없습니다.'\n+        : '시스템 관리자 계정의 권한은 변경할 수 없습니다.';\n+      throw new Error(message);\n+    }\n+  }\n+\n+  /**\n+   * 직원 수정\n+   */\n+  async updateStaff(id: string, updates: Partial<Omit<Staff, 'id' | 'createdAt'>>): Promise<Staff | null> {\n+    try {\n+      const existing = await this.getStaffById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 직원입니다.');\n+      }\n+\n+      // 시스템 관리자 권한 변경 보호\n+      if (updates.permission && updates.permission !== existing.permission) {\n+        this.validateSystemAdminProtection(existing, 'permission_change');\n+      }\n+\n+      // 파일 데이터 처리\n+      let contractFileData = existing.contractFileData;\n+      let contractFileName = existing.contractFileName;\n+      \n+      if (updates.contractFile) {\n+        contractFileData = await this.fileToArrayBuffer(updates.contractFile);\n+        contractFileName = updates.contractFile.name;\n+      }\n+\n+      const updatedStaff: Staff = {\n+        ...existing,\n+        ...updates,\n+        updatedAt: new Date(),\n+        contractFile: undefined, // File 객체는 저장하지 않음\n+        contractFileName,\n+        contractFileData,\n+      };\n+\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.put(updatedStaff)\n+      );\n+\n+      console.log('직원 수정 성공:', updatedStaff);\n+      return updatedStaff;\n+    } catch (error) {\n+      console.error('직원 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 직원 삭제\n+   */\n+  async deleteStaff(id: string): Promise<boolean> {\n+    try {\n+      const existing = await this.getStaffById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 직원입니다.');\n+      }\n+\n+      // 시스템 관리자 삭제 보호\n+      this.validateSystemAdminProtection(existing, 'delete');\n+\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+      console.log('직원 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('직원 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 지점별 직원 조회\n+   */\n+  async getStaffByBranch(branchId: string): Promise<Staff[]> {\n+    try {\n+      return await this.executeTransaction('staff', 'readonly', (store) => {\n+        const index = store.index('branchId');\n+        return index.getAll(IDBKeyRange.only(branchId));\n+      });\n+    } catch (error) {\n+      console.error('지점별 직원 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 이메일로 직원 조회\n+   */\n+  async getStaffByEmail(email: string): Promise<Staff | null> {\n+    try {\n+      const result = await this.executeTransaction('staff', 'readonly', (store) => {\n+        const index = store.index('email');\n+        return index.get(email);\n+      });\n+      return result || null;\n+    } catch (error) {\n+      console.error('이메일로 직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 로그인ID로 직원 조회\n+   */\n+  async getStaffByLoginId(loginId: string): Promise<Staff | null> {\n+    try {\n+      const result = await this.executeTransaction('staff', 'readonly', (store) => {\n+        const index = store.index('loginId');\n+        return index.get(loginId);\n+      });\n+      return result || null;\n+    } catch (error) {\n+      console.error('로그인ID로 직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 파일을 ArrayBuffer로 변환\n+   */\n+  private fileToArrayBuffer(file: File): Promise<ArrayBuffer> {\n+    return new Promise((resolve, reject) => {\n+      const reader = new FileReader();\n+      reader.onload = () => resolve(reader.result as ArrayBuffer);\n+      reader.onerror = () => reject(reader.error);\n+      reader.readAsArrayBuffer(file);\n+    });\n+  }\n+\n+  /**\n+   * ArrayBuffer를 Blob으로 변환 (파일 다운로드용)\n+   */\n+  arrayBufferToBlob(buffer: ArrayBuffer, mimeType: string): Blob {\n+    return new Blob([buffer], { type: mimeType });\n+  }\n+\n+  /**\n+   * 데이터베이스 초기화 (개발/테스트용)\n+   */\n+  async clearAllData(): Promise<void> {\n+    try {\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      console.log('모든 데이터 삭제 완료');\n+    } catch (error) {\n+      console.error('데이터 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+}\n+\n+// 싱글톤 인스턴스 생성\n+export const dbManager = new IndexedDBManager();\n+\n+// 개발자 도구에서 사용할 수 있도록 전역 객체에 추가\n+if (typeof window !== 'undefined') {\n+  (window as any).dbManager = dbManager;\n+}\n"
                },
                {
                    "date": 1759913964757,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -541,533 +541,68 @@\n     }\n   }\n \n   /**\n-   * 파일을 ArrayBuffer로 변환\n+   * 전화번호로 직원 조회\n    */\n-  private fileToArrayBuffer(file: File): Promise<ArrayBuffer> {\n-    return new Promise((resolve, reject) => {\n-      const reader = new FileReader();\n-      reader.onload = () => resolve(reader.result as ArrayBuffer);\n-      reader.onerror = () => reject(reader.error);\n-      reader.readAsArrayBuffer(file);\n-    });\n-  }\n-\n-  /**\n-   * ArrayBuffer를 Blob으로 변환 (파일 다운로드용)\n-   */\n-  arrayBufferToBlob(buffer: ArrayBuffer, mimeType: string): Blob {\n-    return new Blob([buffer], { type: mimeType });\n-  }\n-\n-  /**\n-   * 데이터베이스 초기화 (개발/테스트용)\n-   */\n-  async clearAllData(): Promise<void> {\n+  async getStaffByPhone(phone: string): Promise<Staff | null> {\n     try {\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      console.log('모든 데이터 삭제 완료');\n+      const allStaff = await this.getAllStaff();\n+      const found = allStaff.find(staff => staff.phone === phone);\n+      return found || null;\n     } catch (error) {\n-      console.error('데이터 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-}\n-\n-// 싱글톤 인스턴스 생성\n-export const dbManager = new IndexedDBManager();\n-\n-// 개발자 도구에서 사용할 수 있도록 전역 객체에 추가\n-if (typeof window !== 'undefined') {\n-  (window as any).dbManager = dbManager;\n-}\n-/**\n- * IndexedDB를 활용한 로컬 데이터베이스 관리 유틸리티\n- * 백엔드 연결 전까지 브라우저에서 데이터를 영구 저장\n- */\n-\n-import { SYSTEM_ADMIN_CONFIG } from '../constants/staffConstants';\n-\n-export interface DBRecord {\n-  id: string;\n-  createdAt: Date;\n-  updatedAt: Date;\n-}\n-\n-export interface Branch extends DBRecord {\n-  name: string;\n-  address?: string;\n-  phone?: string;\n-  isActive: boolean;\n-}\n-\n-export interface AppSettings extends DBRecord {\n-  key: string;\n-  value: string;\n-}\n-\n-export interface Staff extends DBRecord {\n-  name: string;\n-  loginId: string; // 로그인 ID\n-  password: string; // 비밀번호\n-  phone: string;\n-  email: string;\n-  branchId: string;\n-  position: string; // 직급\n-  role: string; // 직책\n-  employmentType: string; // 고용형태\n-  permission: string; // 권한\n-  contractStartDate: Date;\n-  contractEndDate?: Date | null; // 계약종료일 (정규직은 없을 수 있음)\n-  contractFile?: File | null; // 계약서 파일\n-  contractFileName?: string; // 계약서 파일명 저장용\n-  contractFileData?: ArrayBuffer; // 계약서 파일 데이터 저장용\n-}\n-\n-class IndexedDBManager {\n-  private dbName: string = 'LavidaDB';\n-  private version: number = 2; // 버전 업데이트\n-  private db: IDBDatabase | null = null;\n-\n-  constructor() {\n-    this.initDB();\n-  }\n-\n-  /**\n-   * IndexedDB 초기화\n-   */\n-  private async initDB(): Promise<void> {\n-    return new Promise((resolve, reject) => {\n-      const request = indexedDB.open(this.dbName, this.version);\n-\n-      request.onerror = () => {\n-        console.error('IndexedDB 열기 실패:', request.error);\n-        reject(request.error);\n-      };\n-\n-      request.onsuccess = () => {\n-        this.db = request.result;\n-        console.log('IndexedDB 연결 성공');\n-        resolve();\n-      };\n-\n-      request.onupgradeneeded = (event) => {\n-        const db = (event.target as IDBOpenDBRequest).result;\n-\n-        // 지점 테이블 생성\n-        if (!db.objectStoreNames.contains('branches')) {\n-          const branchStore = db.createObjectStore('branches', { keyPath: 'id' });\n-          branchStore.createIndex('name', 'name', { unique: false });\n-          branchStore.createIndex('isActive', 'isActive', { unique: false });\n-          branchStore.createIndex('createdAt', 'createdAt', { unique: false });\n-        }\n-\n-        // 직원 테이블 생성\n-        if (!db.objectStoreNames.contains('staff')) {\n-          const staffStore = db.createObjectStore('staff', { keyPath: 'id' });\n-          staffStore.createIndex('name', 'name', { unique: false });\n-          staffStore.createIndex('loginId', 'loginId', { unique: true });\n-          staffStore.createIndex('email', 'email', { unique: true });\n-          staffStore.createIndex('branchId', 'branchId', { unique: false });\n-          staffStore.createIndex('position', 'position', { unique: false });\n-          staffStore.createIndex('role', 'role', { unique: false });\n-          staffStore.createIndex('employmentType', 'employmentType', { unique: false });\n-          staffStore.createIndex('permission', 'permission', { unique: false });\n-          staffStore.createIndex('createdAt', 'createdAt', { unique: false });\n-        }\n-\n-        // 향후 다른 테이블들도 여기에 추가 가능\n-        // 예: 회원, 방문기록 등\n-      };\n-    });\n-  }\n-\n-  /**\n-   * 고유 ID 생성 (UUID v4 형식)\n-   */\n-  private generateUUID(): string {\n-    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n-      const r = Math.random() * 16 | 0;\n-      const v = c === 'x' ? r : ((r & 0x3) | 0x8);\n-      return v.toString(16);\n-    });\n-  }\n-\n-  /**\n-   * 트랜잭션 실행 헬퍼\n-   */\n-  private async executeTransaction<T>(\n-    storeName: string,\n-    mode: IDBTransactionMode,\n-    operation: (store: IDBObjectStore) => IDBRequest<T>\n-  ): Promise<T> {\n-    if (!this.db) {\n-      await this.initDB();\n-    }\n-\n-    return new Promise((resolve, reject) => {\n-      const transaction = this.db!.transaction([storeName], mode);\n-      const store = transaction.objectStore(storeName);\n-      const request = operation(store);\n-\n-      request.onsuccess = () => resolve(request.result);\n-      request.onerror = () => reject(request.error);\n-    });\n-  }\n-\n-  // === 지점 관리 메서드들 ===\n-\n-  /**\n-   * 모든 지점 조회\n-   */\n-  async getAllBranches(): Promise<Branch[]> {\n-    try {\n-      return await this.executeTransaction('branches', 'readonly', (store) => \n-        store.getAll()\n-      );\n-    } catch (error) {\n-      console.error('지점 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * ID로 지점 조회\n-   */\n-  async getBranchById(id: string): Promise<Branch | null> {\n-    try {\n-      const result = await this.executeTransaction('branches', 'readonly', (store) => \n-        store.get(id)\n-      );\n-      return result || null;\n-    } catch (error) {\n-      console.error('지점 조회 실패:', error);\n+      console.error('전화번호로 직원 조회 실패:', error);\n       return null;\n     }\n   }\n \n   /**\n-   * 지점 추가\n+   * 중복 체크 함수 (등록 시 사용)\n    */\n-  async addBranch(branchData: Omit<Branch, 'id' | 'createdAt' | 'updatedAt'>): Promise<Branch> {\n-    const now = new Date();\n-    const newBranch: Branch = {\n-      ...branchData,\n-      id: this.generateUUID(),\n-      createdAt: now,\n-      updatedAt: now,\n-    };\n-\n+  async checkDuplicateStaff(loginId: string, email: string, phone: string): Promise<{\n+    isDuplicate: boolean;\n+    duplicateField?: 'loginId' | 'email' | 'phone';\n+    message?: string;\n+  }> {\n     try {\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.add(newBranch)\n-      );\n-      console.log('지점 추가 성공:', newBranch);\n-      return newBranch;\n-    } catch (error) {\n-      console.error('지점 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 지점 수정\n-   */\n-  async updateBranch(id: string, updates: Partial<Omit<Branch, 'id' | 'createdAt'>>): Promise<Branch | null> {\n-    try {\n-      const existing = await this.getBranchById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 지점입니다.');\n+      // 로그인 ID 중복 체크\n+      const existingByLoginId = await this.getStaffByLoginId(loginId);\n+      if (existingByLoginId) {\n+        return {\n+          isDuplicate: true,\n+          duplicateField: 'loginId',\n+          message: '이미 사용 중인 로그인 ID입니다.'\n+        };\n       }\n \n-      const updatedBranch: Branch = {\n-        ...existing,\n-        ...updates,\n-        updatedAt: new Date(),\n-      };\n-\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.put(updatedBranch)\n-      );\n-\n-      console.log('지점 수정 성공:', updatedBranch);\n-      return updatedBranch;\n-    } catch (error) {\n-      console.error('지점 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 지점 삭제\n-   */\n-  async deleteBranch(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-      console.log('지점 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('지점 삭제 실패:', error);\n-      return false;\n-    }\n-  }\n-\n-  /**\n-   * 활성 지점만 조회\n-   */\n-  async getActiveBranches(): Promise<Branch[]> {\n-    try {\n-      return await this.executeTransaction('branches', 'readonly', (store) => {\n-        const index = store.index('isActive');\n-        return index.getAll(IDBKeyRange.only(true));\n-      });\n-    } catch (error) {\n-      console.error('활성 지점 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 지점명으로 정확히 일치하는 지점 조회\n-   */\n-  async getBranchByName(name: string): Promise<Branch | null> {\n-    try {\n-      const allBranches = await this.getAllBranches();\n-      const branch = allBranches.find(branch => branch.name === name);\n-      return branch || null;\n-    } catch (error) {\n-      console.error('지점명으로 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 지점명으로 검색\n-   */\n-  async searchBranchesByName(name: string): Promise<Branch[]> {\n-    try {\n-      const allBranches = await this.getAllBranches();\n-      return allBranches.filter(branch => \n-        branch.name.toLowerCase().includes(name.toLowerCase())\n-      );\n-    } catch (error) {\n-      console.error('지점 검색 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  // === 직원 관리 메서드들 ===\n-\n-  /**\n-   * 모든 직원 조회\n-   */\n-  async getAllStaff(): Promise<Staff[]> {\n-    try {\n-      return await this.executeTransaction('staff', 'readonly', (store) => \n-        store.getAll()\n-      );\n-    } catch (error) {\n-      console.error('직원 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * ID로 직원 조회\n-   */\n-  async getStaffById(id: string): Promise<Staff | null> {\n-    try {\n-      const result = await this.executeTransaction('staff', 'readonly', (store) => \n-        store.get(id)\n-      );\n-      return result || null;\n-    } catch (error) {\n-      console.error('직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 직원 추가\n-   */\n-  async addStaff(staffData: Omit<Staff, 'id' | 'createdAt' | 'updatedAt'>): Promise<Staff> {\n-    const now = new Date();\n-    \n-    // 파일 데이터 처리\n-    let contractFileData: ArrayBuffer | undefined;\n-    let contractFileName: string | undefined;\n-    \n-    if (staffData.contractFile) {\n-      contractFileData = await this.fileToArrayBuffer(staffData.contractFile);\n-      contractFileName = staffData.contractFile.name;\n-    }\n-\n-    const newStaff: Staff = {\n-      ...staffData,\n-      id: this.generateUUID(),\n-      createdAt: now,\n-      updatedAt: now,\n-      contractFile: undefined, // File 객체는 저장하지 않음\n-      contractFileName,\n-      contractFileData,\n-    };\n-\n-    try {\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.add(newStaff)\n-      );\n-      console.log('직원 추가 성공:', newStaff);\n-      return newStaff;\n-    } catch (error) {\n-      console.error('직원 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 시스템 관리자 계정인지 확인\n-   */\n-  private isSystemAdmin(staff: Staff): boolean {\n-    return staff.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID;\n-  }\n-\n-  /**\n-   * 시스템 관리자 보호 검증\n-   */\n-  private validateSystemAdminProtection(staff: Staff, operation: 'delete' | 'permission_change'): void {\n-    if (this.isSystemAdmin(staff)) {\n-      const message = operation === 'delete' \n-        ? '시스템 관리자 계정은 삭제할 수 없습니다.'\n-        : '시스템 관리자 계정의 권한은 변경할 수 없습니다.';\n-      throw new Error(message);\n-    }\n-  }\n-\n-  /**\n-   * 직원 수정\n-   */\n-  async updateStaff(id: string, updates: Partial<Omit<Staff, 'id' | 'createdAt'>>): Promise<Staff | null> {\n-    try {\n-      const existing = await this.getStaffById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 직원입니다.');\n+      // 이메일 중복 체크\n+      const existingByEmail = await this.getStaffByEmail(email);\n+      if (existingByEmail) {\n+        return {\n+          isDuplicate: true,\n+          duplicateField: 'email',\n+          message: '이미 사용 중인 이메일입니다.'\n+        };\n       }\n \n-      // 시스템 관리자 권한 변경 보호\n-      if (updates.permission && updates.permission !== existing.permission) {\n-        this.validateSystemAdminProtection(existing, 'permission_change');\n+      // 전화번호 중복 체크\n+      const existingByPhone = await this.getStaffByPhone(phone);\n+      if (existingByPhone) {\n+        return {\n+          isDuplicate: true,\n+          duplicateField: 'phone',\n+          message: '이미 사용 중인 전화번호입니다.'\n+        };\n       }\n \n-      // 파일 데이터 처리\n-      let contractFileData = existing.contractFileData;\n-      let contractFileName = existing.contractFileName;\n-      \n-      if (updates.contractFile) {\n-        contractFileData = await this.fileToArrayBuffer(updates.contractFile);\n-        contractFileName = updates.contractFile.name;\n-      }\n-\n-      const updatedStaff: Staff = {\n-        ...existing,\n-        ...updates,\n-        updatedAt: new Date(),\n-        contractFile: undefined, // File 객체는 저장하지 않음\n-        contractFileName,\n-        contractFileData,\n-      };\n-\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.put(updatedStaff)\n-      );\n-\n-      console.log('직원 수정 성공:', updatedStaff);\n-      return updatedStaff;\n+      return { isDuplicate: false };\n     } catch (error) {\n-      console.error('직원 수정 실패:', error);\n+      console.error('중복 체크 실패:', error);\n       throw error;\n     }\n   }\n \n   /**\n-   * 직원 삭제\n-   */\n-  async deleteStaff(id: string): Promise<boolean> {\n-    try {\n-      const existing = await this.getStaffById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 직원입니다.');\n-      }\n-\n-      // 시스템 관리자 삭제 보호\n-      this.validateSystemAdminProtection(existing, 'delete');\n-\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-      console.log('직원 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('직원 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 지점별 직원 조회\n-   */\n-  async getStaffByBranch(branchId: string): Promise<Staff[]> {\n-    try {\n-      return await this.executeTransaction('staff', 'readonly', (store) => {\n-        const index = store.index('branchId');\n-        return index.getAll(IDBKeyRange.only(branchId));\n-      });\n-    } catch (error) {\n-      console.error('지점별 직원 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 이메일로 직원 조회\n-   */\n-  async getStaffByEmail(email: string): Promise<Staff | null> {\n-    try {\n-      const result = await this.executeTransaction('staff', 'readonly', (store) => {\n-        const index = store.index('email');\n-        return index.get(email);\n-      });\n-      return result || null;\n-    } catch (error) {\n-      console.error('이메일로 직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 로그인ID로 직원 조회\n-   */\n-  async getStaffByLoginId(loginId: string): Promise<Staff | null> {\n-    try {\n-      const result = await this.executeTransaction('staff', 'readonly', (store) => {\n-        const index = store.index('loginId');\n-        return index.get(loginId);\n-      });\n-      return result || null;\n-    } catch (error) {\n-      console.error('로그인ID로 직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n    * 파일을 ArrayBuffer로 변환\n    */\n   private fileToArrayBuffer(file: File): Promise<ArrayBuffer> {\n     return new Promise((resolve, reject) => {\n"
                },
                {
                    "date": 1760074120597,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -344,11 +344,35 @@\n    * 모든 직원 조회\n    */\n   async getAllStaff(): Promise<Staff[]> {\n     try {\n-      return await this.executeTransaction('staff', 'readonly', (store) => \n+      const staffList = await this.executeTransaction('staff', 'readonly', (store) => \n         store.getAll()\n       );\n+\n+      // 저장된 파일 데이터를 File 객체로 복원\n+      return staffList.map(staff => {\n+        if (staff.contractFileData && staff.contractFileName) {\n+          // 파일 확장자로부터 MIME 타입 추정\n+          const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n+          let mimeType = 'application/octet-stream';\n+          \n+          if (extension === 'pdf') {\n+            mimeType = 'application/pdf';\n+          } else if (['jpg', 'jpeg'].includes(extension || '')) {\n+            mimeType = 'image/jpeg';\n+          } else if (extension === 'png') {\n+            mimeType = 'image/png';\n+          }\n+\n+          staff.contractFile = this.arrayBufferToFile(\n+            staff.contractFileData, \n+            staff.contractFileName, \n+            mimeType\n+          );\n+        }\n+        return staff;\n+      });\n     } catch (error) {\n       console.error('직원 조회 실패:', error);\n       return [];\n     }\n@@ -358,12 +382,35 @@\n    * ID로 직원 조회\n    */\n   async getStaffById(id: string): Promise<Staff | null> {\n     try {\n-      const result = await this.executeTransaction('staff', 'readonly', (store) => \n+      const staff = await this.executeTransaction('staff', 'readonly', (store) => \n         store.get(id)\n       );\n-      return result || null;\n+\n+      if (!staff) return null;\n+\n+      // 저장된 파일 데이터를 File 객체로 복원\n+      if (staff.contractFileData && staff.contractFileName) {\n+        const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n+        let mimeType = 'application/octet-stream';\n+        \n+        if (extension === 'pdf') {\n+          mimeType = 'application/pdf';\n+        } else if (['jpg', 'jpeg'].includes(extension || '')) {\n+          mimeType = 'image/jpeg';\n+        } else if (extension === 'png') {\n+          mimeType = 'image/png';\n+        }\n+\n+        staff.contractFile = this.arrayBufferToFile(\n+          staff.contractFileData, \n+          staff.contractFileName, \n+          mimeType\n+        );\n+      }\n+\n+      return staff;\n     } catch (error) {\n       console.error('직원 조회 실패:', error);\n       return null;\n     }\n@@ -620,8 +667,16 @@\n     return new Blob([buffer], { type: mimeType });\n   }\n \n   /**\n+   * ArrayBuffer를 File 객체로 변환\n+   */\n+  private arrayBufferToFile(buffer: ArrayBuffer, fileName: string, mimeType: string = 'application/octet-stream'): File {\n+    const blob = new Blob([buffer], { type: mimeType });\n+    return new File([blob], fileName, { type: mimeType });\n+  }\n+\n+  /**\n    * 데이터베이스 초기화 (개발/테스트용)\n    */\n   async clearAllData(): Promise<void> {\n     try {\n"
                },
                {
                    "date": 1760074449204,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,13 +38,14 @@\n   contractEndDate?: Date | null; // 계약종료일 (정규직은 없을 수 있음)\n   contractFile?: File | null; // 계약서 파일\n   contractFileName?: string; // 계약서 파일명 저장용\n   contractFileData?: ArrayBuffer; // 계약서 파일 데이터 저장용\n+  isActive: boolean; // 활성/비활성 상태\n }\n \n class IndexedDBManager {\n   private dbName: string = 'LavidaDB';\n-  private version: number = 3; // 버전 업데이트 (지점명 unique 제약 추가)\n+  private version: number = 4; // 버전 업데이트 (Staff isActive 필드 추가)\n   private db: IDBDatabase | null = null;\n \n   constructor() {\n     this.initDB();\n@@ -99,9 +100,18 @@\n           staffStore.createIndex('position', 'position', { unique: false });\n           staffStore.createIndex('role', 'role', { unique: false });\n           staffStore.createIndex('employmentType', 'employmentType', { unique: false });\n           staffStore.createIndex('permission', 'permission', { unique: false });\n+          staffStore.createIndex('isActive', 'isActive', { unique: false });\n           staffStore.createIndex('createdAt', 'createdAt', { unique: false });\n+        } else {\n+          // 기존 테이블이 있으면 인덱스 업데이트 (isActive 인덱스 추가)\n+          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n+          const staffStore = transaction.objectStore('staff');\n+          \n+          if (!staffStore.indexNames.contains('isActive')) {\n+            staffStore.createIndex('isActive', 'isActive', { unique: false });\n+          }\n         }\n \n         // 향후 다른 테이블들도 여기에 추가 가능\n         // 예: 회원, 방문기록 등\n@@ -435,8 +445,9 @@\n       ...staffData,\n       id: this.generateUUID(),\n       createdAt: now,\n       updatedAt: now,\n+      isActive: staffData.isActive !== undefined ? staffData.isActive : true, // 기본값 true\n       contractFile: undefined, // File 객체는 저장하지 않음\n       contractFileName,\n       contractFileData,\n     };\n@@ -541,8 +552,41 @@\n     }\n   }\n \n   /**\n+   * 직원 활성/비활성 상태 토글\n+   */\n+  async toggleStaffStatus(id: string): Promise<Staff | null> {\n+    try {\n+      const existing = await this.getStaffById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 직원입니다.');\n+      }\n+\n+      // 시스템 관리자 상태 변경 보호\n+      if (existing.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID) {\n+        throw new Error('시스템 관리자 계정의 상태는 변경할 수 없습니다.');\n+      }\n+\n+      const updatedStaff = {\n+        ...existing,\n+        isActive: !existing.isActive,\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.put(updatedStaff)\n+      );\n+\n+      console.log('직원 상태 변경 성공:', id, `-> ${updatedStaff.isActive ? '활성' : '비활성'}`);\n+      return updatedStaff;\n+    } catch (error) {\n+      console.error('직원 상태 변경 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n    * 지점별 직원 조회\n    */\n   async getStaffByBranch(branchId: string): Promise<Staff[]> {\n     try {\n@@ -691,8 +735,42 @@\n       console.error('데이터 삭제 실패:', error);\n       throw error;\n     }\n   }\n+\n+  /**\n+   * 기존 직원 데이터의 isActive 필드 초기화 (마이그레이션용)\n+   */\n+  async migrateStaffActiveStatus(): Promise<void> {\n+    try {\n+      const allStaff = await this.executeTransaction('staff', 'readonly', (store) => \n+        store.getAll()\n+      );\n+\n+      // isActive 필드가 없는 직원들을 찾아서 업데이트\n+      const staffToUpdate = allStaff.filter(staff => staff.isActive === undefined);\n+      \n+      if (staffToUpdate.length > 0) {\n+        console.log(`${staffToUpdate.length}명의 직원 isActive 필드를 초기화합니다.`);\n+        \n+        for (const staff of staffToUpdate) {\n+          const updatedStaff = {\n+            ...staff,\n+            isActive: true, // 기본값을 true로 설정\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('staff', 'readwrite', (store) => \n+            store.put(updatedStaff)\n+          );\n+        }\n+        \n+        console.log('직원 isActive 필드 초기화 완료');\n+      }\n+    } catch (error) {\n+      console.error('직원 isActive 필드 초기화 실패:', error);\n+    }\n+  }\n }\n \n // 싱글톤 인스턴스 생성\n export const dbManager = new IndexedDBManager();\n"
                },
                {
                    "date": 1760074699393,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -620,13 +620,36 @@\n    * 로그인ID로 직원 조회\n    */\n   async getStaffByLoginId(loginId: string): Promise<Staff | null> {\n     try {\n-      const result = await this.executeTransaction('staff', 'readonly', (store) => {\n+      const staff = await this.executeTransaction('staff', 'readonly', (store) => {\n         const index = store.index('loginId');\n         return index.get(loginId);\n       });\n-      return result || null;\n+\n+      if (!staff) return null;\n+\n+      // 저장된 파일 데이터를 File 객체로 복원\n+      if (staff.contractFileData && staff.contractFileName) {\n+        const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n+        let mimeType = 'application/octet-stream';\n+        \n+        if (extension === 'pdf') {\n+          mimeType = 'application/pdf';\n+        } else if (['jpg', 'jpeg'].includes(extension || '')) {\n+          mimeType = 'image/jpeg';\n+        } else if (extension === 'png') {\n+          mimeType = 'image/png';\n+        }\n+\n+        staff.contractFile = this.arrayBufferToFile(\n+          staff.contractFileData, \n+          staff.contractFileName, \n+          mimeType\n+        );\n+      }\n+\n+      return staff;\n     } catch (error) {\n       console.error('로그인ID로 직원 조회 실패:', error);\n       return null;\n     }\n"
                },
                {
                    "date": 1760077595008,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,11 +41,17 @@\n   contractFileData?: ArrayBuffer; // 계약서 파일 데이터 저장용\n   isActive: boolean; // 활성/비활성 상태\n }\n \n+export interface Program extends DBRecord {\n+  name: string;\n+  type: string; // '횟수제' | '기간제'\n+  isActive: boolean;\n+}\n+\n class IndexedDBManager {\n   private dbName: string = 'LavidaDB';\n-  private version: number = 4; // 버전 업데이트 (Staff isActive 필드 추가)\n+  private version: number = 5; // 버전 업데이트 (Program 테이블 추가)\n   private db: IDBDatabase | null = null;\n \n   constructor() {\n     this.initDB();\n@@ -112,8 +118,27 @@\n             staffStore.createIndex('isActive', 'isActive', { unique: false });\n           }\n         }\n \n+        // 프로그램 테이블 생성\n+        if (!db.objectStoreNames.contains('programs')) {\n+          const programStore = db.createObjectStore('programs', { keyPath: 'id' });\n+          programStore.createIndex('name', 'name', { unique: true }); // 프로그램명 고유 제약\n+          programStore.createIndex('type', 'type', { unique: false });\n+          programStore.createIndex('isActive', 'isActive', { unique: false });\n+          programStore.createIndex('createdAt', 'createdAt', { unique: false });\n+        } else {\n+          // 기존 테이블이 있으면 인덱스 업데이트\n+          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n+          const programStore = transaction.objectStore('programs');\n+          \n+          // 기존 name 인덱스 삭제 후 unique로 재생성\n+          if (programStore.indexNames.contains('name')) {\n+            programStore.deleteIndex('name');\n+          }\n+          programStore.createIndex('name', 'name', { unique: true });\n+        }\n+\n         // 향후 다른 테이블들도 여기에 추가 가능\n         // 예: 회원, 방문기록 등\n       };\n     });\n@@ -752,8 +777,11 @@\n       );\n       await this.executeTransaction('staff', 'readwrite', (store) => \n         store.clear()\n       );\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.clear()\n+      );\n       console.log('모든 데이터 삭제 완료');\n     } catch (error) {\n       console.error('데이터 삭제 실패:', error);\n       throw error;\n@@ -792,8 +820,143 @@\n     } catch (error) {\n       console.error('직원 isActive 필드 초기화 실패:', error);\n     }\n   }\n+\n+  // =================== 프로그램 관리 메서드 ===================\n+\n+  /**\n+   * 프로그램 추가\n+   */\n+  async addProgram(programData: Omit<Program, 'id' | 'createdAt' | 'updatedAt'>): Promise<Program> {\n+    try {\n+      // 프로그램명 중복 체크\n+      const existingProgram = await this.getProgramByName(programData.name);\n+      if (existingProgram) {\n+        throw new Error('이미 존재하는 프로그램명입니다.');\n+      }\n+\n+      const newProgram: Program = {\n+        id: this.generateUUID(),\n+        ...programData,\n+        createdAt: new Date(),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.add(newProgram)\n+      );\n+\n+      console.log('프로그램 추가 성공:', newProgram);\n+      return newProgram;\n+    } catch (error) {\n+      console.error('프로그램 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 프로그램 조회\n+   */\n+  async getAllPrograms(): Promise<Program[]> {\n+    try {\n+      const programs = await this.executeTransaction('programs', 'readonly', (store) => \n+        store.getAll()\n+      );\n+      \n+      return programs.map(program => ({\n+        ...program,\n+        createdAt: new Date(program.createdAt),\n+        updatedAt: new Date(program.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('프로그램 목록 조회 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 프로그램명으로 조회\n+   */\n+  async getProgramByName(name: string): Promise<Program | null> {\n+    try {\n+      const program = await this.executeTransaction('programs', 'readonly', (store) => \n+        store.index('name').get(name)\n+      );\n+      \n+      if (program) {\n+        return {\n+          ...program,\n+          createdAt: new Date(program.createdAt),\n+          updatedAt: new Date(program.updatedAt)\n+        };\n+      }\n+      \n+      return null;\n+    } catch (error) {\n+      console.error('프로그램 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 프로그램 수정\n+   */\n+  async updateProgram(id: string, updates: Partial<Omit<Program, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Program | null> {\n+    try {\n+      const existingProgram = await this.executeTransaction('programs', 'readonly', (store) => \n+        store.get(id)\n+      );\n+\n+      if (!existingProgram) {\n+        console.error('수정할 프로그램을 찾을 수 없습니다:', id);\n+        return null;\n+      }\n+\n+      // 프로그램명 변경 시 중복 체크\n+      if (updates.name && updates.name !== existingProgram.name) {\n+        const duplicateProgram = await this.getProgramByName(updates.name);\n+        if (duplicateProgram) {\n+          throw new Error('이미 존재하는 프로그램명입니다.');\n+        }\n+      }\n+\n+      const updatedProgram: Program = {\n+        ...existingProgram,\n+        ...updates,\n+        id,\n+        createdAt: new Date(existingProgram.createdAt),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.put(updatedProgram)\n+      );\n+\n+      console.log('프로그램 수정 성공:', updatedProgram);\n+      return updatedProgram;\n+    } catch (error) {\n+      console.error('프로그램 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 프로그램 삭제\n+   */\n+  async deleteProgram(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('프로그램 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('프로그램 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n }\n \n // 싱글톤 인스턴스 생성\n export const dbManager = new IndexedDBManager();\n"
                },
                {
                    "date": 1760079938556,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,11 +47,21 @@\n   type: string; // '횟수제' | '기간제'\n   isActive: boolean;\n }\n \n+export interface Product extends DBRecord {\n+  name: string;\n+  branchId: string;\n+  programId: string;\n+  programName: string; // 프로그램명 저장 (조회 성능 향상)\n+  programType: string; // 프로그램 종류 저장 (조회 성능 향상)\n+  sessions?: number; // 횟수 (횟수제인 경우에만 필요)\n+  isActive: boolean;\n+}\n+\n class IndexedDBManager {\n   private dbName: string = 'LavidaDB';\n-  private version: number = 5; // 버전 업데이트 (Program 테이블 추가)\n+  private version: number = 6; // 버전 업데이트 (Product 테이블 추가)\n   private db: IDBDatabase | null = null;\n \n   constructor() {\n     this.initDB();\n@@ -137,8 +147,21 @@\n           }\n           programStore.createIndex('name', 'name', { unique: true });\n         }\n \n+        // 상품 테이블 생성\n+        if (!db.objectStoreNames.contains('products')) {\n+          const productStore = db.createObjectStore('products', { keyPath: 'id' });\n+          productStore.createIndex('name', 'name', { unique: false });\n+          productStore.createIndex('branchId', 'branchId', { unique: false });\n+          productStore.createIndex('programId', 'programId', { unique: false });\n+          productStore.createIndex('programType', 'programType', { unique: false });\n+          productStore.createIndex('isActive', 'isActive', { unique: false });\n+          productStore.createIndex('createdAt', 'createdAt', { unique: false });\n+          // 복합 인덱스: 지점별, 프로그램별 조회 최적화\n+          productStore.createIndex('branchProgram', ['branchId', 'programId'], { unique: false });\n+        }\n+\n         // 향후 다른 테이블들도 여기에 추가 가능\n         // 예: 회원, 방문기록 등\n       };\n     });\n@@ -780,8 +803,11 @@\n       );\n       await this.executeTransaction('programs', 'readwrite', (store) => \n         store.clear()\n       );\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.clear()\n+      );\n       console.log('모든 데이터 삭제 완료');\n     } catch (error) {\n       console.error('데이터 삭제 실패:', error);\n       throw error;\n@@ -955,8 +981,228 @@\n       console.error('프로그램 삭제 실패:', error);\n       throw error;\n     }\n   }\n+\n+  // =================== 상품 관리 메서드 ===================\n+\n+  /**\n+   * 상품 추가\n+   */\n+  async addProduct(productData: Omit<Product, 'id' | 'createdAt' | 'updatedAt'>): Promise<Product> {\n+    try {\n+      const newProduct: Product = {\n+        id: this.generateUUID(),\n+        ...productData,\n+        createdAt: new Date(),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.add(newProduct)\n+      );\n+\n+      console.log('상품 추가 성공:', newProduct);\n+      return newProduct;\n+    } catch (error) {\n+      console.error('상품 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 상품 조회\n+   */\n+  async getAllProducts(): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => \n+        store.getAll()\n+      );\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('상품 목록 조회 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * ID로 상품 조회\n+   */\n+  async getProductById(id: string): Promise<Product | null> {\n+    try {\n+      const product = await this.executeTransaction('products', 'readonly', (store) => \n+        store.get(id)\n+      );\n+      \n+      if (product) {\n+        return {\n+          ...product,\n+          createdAt: new Date(product.createdAt),\n+          updatedAt: new Date(product.updatedAt)\n+        };\n+      }\n+      \n+      return null;\n+    } catch (error) {\n+      console.error('상품 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 지점별 상품 조회\n+   */\n+  async getProductsByBranch(branchId: string): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('branchId');\n+        return index.getAll(IDBKeyRange.only(branchId));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('지점별 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 프로그램별 상품 조회\n+   */\n+  async getProductsByProgram(programId: string): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('programId');\n+        return index.getAll(IDBKeyRange.only(programId));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('프로그램별 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 지점과 프로그램으로 상품 조회\n+   */\n+  async getProductsByBranchAndProgram(branchId: string, programId: string): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('branchProgram');\n+        return index.getAll(IDBKeyRange.only([branchId, programId]));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('지점-프로그램별 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 상품 수정\n+   */\n+  async updateProduct(id: string, updates: Partial<Omit<Product, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Product | null> {\n+    try {\n+      const existingProduct = await this.executeTransaction('products', 'readonly', (store) => \n+        store.get(id)\n+      );\n+\n+      if (!existingProduct) {\n+        console.error('수정할 상품을 찾을 수 없습니다:', id);\n+        return null;\n+      }\n+\n+      const updatedProduct: Product = {\n+        ...existingProduct,\n+        ...updates,\n+        id,\n+        createdAt: new Date(existingProduct.createdAt),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.put(updatedProduct)\n+      );\n+\n+      console.log('상품 수정 성공:', updatedProduct);\n+      return updatedProduct;\n+    } catch (error) {\n+      console.error('상품 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 상품 삭제\n+   */\n+  async deleteProduct(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('상품 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('상품 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 활성 상품만 조회\n+   */\n+  async getActiveProducts(): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('isActive');\n+        return index.getAll(IDBKeyRange.only(true));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('활성 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 상품명으로 검색\n+   */\n+  async searchProductsByName(name: string): Promise<Product[]> {\n+    try {\n+      const allProducts = await this.getAllProducts();\n+      return allProducts.filter(product => \n+        product.name.toLowerCase().includes(name.toLowerCase())\n+      );\n+    } catch (error) {\n+      console.error('상품 검색 실패:', error);\n+      return [];\n+    }\n+  }\n }\n \n // 싱글톤 인스턴스 생성\n export const dbManager = new IndexedDBManager();\n"
                },
                {
                    "date": 1760150546184,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,8 +33,9 @@\n   position: string; // 직급\n   role: string; // 직책\n   employmentType: string; // 고용형태\n   permission: string; // 권한\n+  program?: string; // 담당프로그램 (코치일 경우만)\n   contractStartDate: Date;\n   contractEndDate?: Date | null; // 계약종료일 (정규직은 없을 수 있음)\n   contractFile?: File | null; // 계약서 파일\n   contractFileName?: string; // 계약서 파일명 저장용\n"
                },
                {
                    "date": 1760150819903,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,8 +55,10 @@\n   programId: string;\n   programName: string; // 프로그램명 저장 (조회 성능 향상)\n   programType: string; // 프로그램 종류 저장 (조회 성능 향상)\n   sessions?: number; // 횟수 (횟수제인 경우에만 필요)\n+  price?: number; // 가격\n+  description?: string; // 상품소개\n   isActive: boolean;\n }\n \n class IndexedDBManager {\n"
                },
                {
                    "date": 1760151132681,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,8 +55,9 @@\n   programId: string;\n   programName: string; // 프로그램명 저장 (조회 성능 향상)\n   programType: string; // 프로그램 종류 저장 (조회 성능 향상)\n   sessions?: number; // 횟수 (횟수제인 경우에만 필요)\n+  duration?: number; // 소요시간 (분 단위, 횟수제인 경우에만 필요)\n   price?: number; // 가격\n   description?: string; // 상품소개\n   isActive: boolean;\n }\n"
                },
                {
                    "date": 1760157680254,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1413 @@\n+/**\n+ * IndexedDB를 활용한 로컬 데이터베이스 관리 유틸리티\n+ * 백엔드 연결 전까지 브라우저에서 데이터를 영구 저장\n+ */\n+\n+import { SYSTEM_ADMIN_CONFIG } from '../constants/staffConstants';\n+\n+export interface DBRecord {\n+  id: string;\n+  createdAt: Date;\n+  updatedAt: Date;\n+}\n+\n+export interface Branch extends DBRecord {\n+  name: string;\n+  address?: string;\n+  phone?: string;\n+  isActive: boolean;\n+}\n+\n+export interface AppSettings extends DBRecord {\n+  key: string;\n+  value: string;\n+}\n+\n+export interface Staff extends DBRecord {\n+  name: string;\n+  loginId: string; // 로그인 ID\n+  password: string; // 비밀번호\n+  phone: string;\n+  email: string;\n+  branchId: string;\n+  position: string; // 직급\n+  role: string; // 직책\n+  employmentType: string; // 고용형태\n+  permission: string; // 권한\n+  program?: string; // 담당프로그램 (코치일 경우만)\n+  contractStartDate: Date;\n+  contractEndDate?: Date | null; // 계약종료일 (정규직은 없을 수 있음)\n+  contractFile?: File | null; // 계약서 파일\n+  contractFileName?: string; // 계약서 파일명 저장용\n+  contractFileData?: ArrayBuffer; // 계약서 파일 데이터 저장용\n+  workingHours?: {\n+    start: number; // 기본 근무 시작 시간 (시)\n+    end: number; // 기본 근무 종료 시간 (시)\n+  };\n+  isActive: boolean; // 활성/비활성 상태\n+}\n+\n+export interface Program extends DBRecord {\n+  name: string;\n+  type: string; // '횟수제' | '기간제'\n+  isActive: boolean;\n+}\n+\n+export interface Product extends DBRecord {\n+  name: string;\n+  branchId: string;\n+  programId: string;\n+  programName: string; // 프로그램명 저장 (조회 성능 향상)\n+  programType: string; // 프로그램 종류 저장 (조회 성능 향상)\n+  sessions?: number; // 횟수 (횟수제인 경우에만 필요)\n+  duration?: number; // 소요시간 (분 단위, 횟수제인 경우에만 필요)\n+  price?: number; // 가격\n+  description?: string; // 상품소개\n+  isActive: boolean;\n+}\n+\n+export interface HolidaySettings extends DBRecord {\n+  staffId: string;\n+  date: string; // YYYY-MM-DD 형식\n+  isHoliday: boolean; // true: 휴일, false: 근무일\n+  workingHours?: {\n+    start: number;\n+    end: number;\n+  }; // 해당 날짜의 근무시간 (휴일이 아닌 경우)\n+}\n+\n+class IndexedDBManager {\n+  private dbName: string = 'LavidaDB';\n+  private version: number = 7; // 버전 업데이트 (HolidaySettings 테이블 추가)\n+  private db: IDBDatabase | null = null;\n+\n+  constructor() {\n+    this.initDB();\n+  }\n+\n+  /**\n+   * IndexedDB 초기화\n+   */\n+  private async initDB(): Promise<void> {\n+    return new Promise((resolve, reject) => {\n+      const request = indexedDB.open(this.dbName, this.version);\n+\n+      request.onerror = () => {\n+        console.error('IndexedDB 열기 실패:', request.error);\n+        reject(request.error);\n+      };\n+\n+      request.onsuccess = () => {\n+        this.db = request.result;\n+        console.log('IndexedDB 연결 성공');\n+        resolve();\n+      };\n+\n+      request.onupgradeneeded = (event) => {\n+        const db = (event.target as IDBOpenDBRequest).result;\n+\n+        // 지점 테이블 생성\n+        if (!db.objectStoreNames.contains('branches')) {\n+          const branchStore = db.createObjectStore('branches', { keyPath: 'id' });\n+          branchStore.createIndex('name', 'name', { unique: true }); // 지점명 고유 제약\n+          branchStore.createIndex('isActive', 'isActive', { unique: false });\n+          branchStore.createIndex('createdAt', 'createdAt', { unique: false });\n+        } else {\n+          // 기존 테이블이 있으면 인덱스 업데이트\n+          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n+          const branchStore = transaction.objectStore('branches');\n+          \n+          // 기존 name 인덱스 삭제 후 unique로 재생성\n+          if (branchStore.indexNames.contains('name')) {\n+            branchStore.deleteIndex('name');\n+          }\n+          branchStore.createIndex('name', 'name', { unique: true });\n+        }\n+\n+        // 직원 테이블 생성\n+        if (!db.objectStoreNames.contains('staff')) {\n+          const staffStore = db.createObjectStore('staff', { keyPath: 'id' });\n+          staffStore.createIndex('name', 'name', { unique: false });\n+          staffStore.createIndex('loginId', 'loginId', { unique: true });\n+          staffStore.createIndex('email', 'email', { unique: true });\n+          staffStore.createIndex('branchId', 'branchId', { unique: false });\n+          staffStore.createIndex('position', 'position', { unique: false });\n+          staffStore.createIndex('role', 'role', { unique: false });\n+          staffStore.createIndex('employmentType', 'employmentType', { unique: false });\n+          staffStore.createIndex('permission', 'permission', { unique: false });\n+          staffStore.createIndex('isActive', 'isActive', { unique: false });\n+          staffStore.createIndex('createdAt', 'createdAt', { unique: false });\n+        } else {\n+          // 기존 테이블이 있으면 인덱스 업데이트 (isActive 인덱스 추가)\n+          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n+          const staffStore = transaction.objectStore('staff');\n+          \n+          if (!staffStore.indexNames.contains('isActive')) {\n+            staffStore.createIndex('isActive', 'isActive', { unique: false });\n+          }\n+        }\n+\n+        // 프로그램 테이블 생성\n+        if (!db.objectStoreNames.contains('programs')) {\n+          const programStore = db.createObjectStore('programs', { keyPath: 'id' });\n+          programStore.createIndex('name', 'name', { unique: true }); // 프로그램명 고유 제약\n+          programStore.createIndex('type', 'type', { unique: false });\n+          programStore.createIndex('isActive', 'isActive', { unique: false });\n+          programStore.createIndex('createdAt', 'createdAt', { unique: false });\n+        } else {\n+          // 기존 테이블이 있으면 인덱스 업데이트\n+          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n+          const programStore = transaction.objectStore('programs');\n+          \n+          // 기존 name 인덱스 삭제 후 unique로 재생성\n+          if (programStore.indexNames.contains('name')) {\n+            programStore.deleteIndex('name');\n+          }\n+          programStore.createIndex('name', 'name', { unique: true });\n+        }\n+\n+        // 상품 테이블 생성\n+        if (!db.objectStoreNames.contains('products')) {\n+          const productStore = db.createObjectStore('products', { keyPath: 'id' });\n+          productStore.createIndex('name', 'name', { unique: false });\n+          productStore.createIndex('branchId', 'branchId', { unique: false });\n+          productStore.createIndex('programId', 'programId', { unique: false });\n+          productStore.createIndex('programType', 'programType', { unique: false });\n+          productStore.createIndex('isActive', 'isActive', { unique: false });\n+          productStore.createIndex('createdAt', 'createdAt', { unique: false });\n+          // 복합 인덱스: 지점별, 프로그램별 조회 최적화\n+          productStore.createIndex('branchProgram', ['branchId', 'programId'], { unique: false });\n+        }\n+\n+        // 휴일설정 테이블 생성\n+        if (!db.objectStoreNames.contains('holidaySettings')) {\n+          const holidayStore = db.createObjectStore('holidaySettings', { keyPath: 'id' });\n+          holidayStore.createIndex('staffId', 'staffId', { unique: false });\n+          holidayStore.createIndex('date', 'date', { unique: false });\n+          holidayStore.createIndex('isHoliday', 'isHoliday', { unique: false });\n+          // 복합 인덱스: 직원별, 날짜별 조회 최적화\n+          holidayStore.createIndex('staffDate', ['staffId', 'date'], { unique: true });\n+        }\n+\n+        // 향후 다른 테이블들도 여기에 추가 가능\n+        // 예: 회원, 방문기록 등\n+      };\n+    });\n+  }\n+\n+  /**\n+   * 고유 ID 생성 (UUID v4 형식)\n+   */\n+  private generateUUID(): string {\n+    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n+      const r = Math.random() * 16 | 0;\n+      const v = c === 'x' ? r : ((r & 0x3) | 0x8);\n+      return v.toString(16);\n+    });\n+  }\n+\n+  /**\n+   * 트랜잭션 실행 헬퍼\n+   */\n+  private async executeTransaction<T>(\n+    storeName: string,\n+    mode: IDBTransactionMode,\n+    operation: (store: IDBObjectStore) => IDBRequest<T>\n+  ): Promise<T> {\n+    if (!this.db) {\n+      await this.initDB();\n+    }\n+\n+    return new Promise((resolve, reject) => {\n+      const transaction = this.db!.transaction([storeName], mode);\n+      const store = transaction.objectStore(storeName);\n+      const request = operation(store);\n+\n+      request.onsuccess = () => resolve(request.result);\n+      request.onerror = () => reject(request.error);\n+    });\n+  }\n+\n+  // === 지점 관리 메서드들 ===\n+\n+  /**\n+   * 모든 지점 조회\n+   */\n+  async getAllBranches(): Promise<Branch[]> {\n+    try {\n+      return await this.executeTransaction('branches', 'readonly', (store) => \n+        store.getAll()\n+      );\n+    } catch (error) {\n+      console.error('지점 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * ID로 지점 조회\n+   */\n+  async getBranchById(id: string): Promise<Branch | null> {\n+    try {\n+      const result = await this.executeTransaction('branches', 'readonly', (store) => \n+        store.get(id)\n+      );\n+      return result || null;\n+    } catch (error) {\n+      console.error('지점 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 지점 추가\n+   */\n+  async addBranch(branchData: Omit<Branch, 'id' | 'createdAt' | 'updatedAt'>): Promise<Branch> {\n+    const now = new Date();\n+    const newBranch: Branch = {\n+      ...branchData,\n+      id: this.generateUUID(),\n+      createdAt: now,\n+      updatedAt: now,\n+    };\n+\n+    try {\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.add(newBranch)\n+      );\n+      console.log('지점 추가 성공:', newBranch);\n+      return newBranch;\n+    } catch (error) {\n+      console.error('지점 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 지점 수정\n+   */\n+  async updateBranch(id: string, updates: Partial<Omit<Branch, 'id' | 'createdAt'>>): Promise<Branch | null> {\n+    try {\n+      const existing = await this.getBranchById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 지점입니다.');\n+      }\n+\n+      const updatedBranch: Branch = {\n+        ...existing,\n+        ...updates,\n+        updatedAt: new Date(),\n+      };\n+\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.put(updatedBranch)\n+      );\n+\n+      console.log('지점 수정 성공:', updatedBranch);\n+      return updatedBranch;\n+    } catch (error) {\n+      console.error('지점 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 지점 삭제\n+   */\n+  async deleteBranch(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+      console.log('지점 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('지점 삭제 실패:', error);\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * 활성 지점만 조회\n+   */\n+  async getActiveBranches(): Promise<Branch[]> {\n+    try {\n+      return await this.executeTransaction('branches', 'readonly', (store) => {\n+        const index = store.index('isActive');\n+        return index.getAll(IDBKeyRange.only(true));\n+      });\n+    } catch (error) {\n+      console.error('활성 지점 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 지점명으로 정확히 일치하는 지점 조회 또는 생성 (원자적 처리)\n+   * 동시 실행 시 race condition 방지\n+   */\n+  async getOrCreateBranchByName(name: string, branchData?: Omit<Branch, 'id' | 'createdAt' | 'updatedAt' | 'name'>): Promise<Branch> {\n+    if (!this.db) {\n+      await this.initDB();\n+    }\n+\n+    return new Promise((resolve, reject) => {\n+      const transaction = this.db!.transaction(['branches'], 'readwrite');\n+      const store = transaction.objectStore('branches');\n+      const index = store.index('name');\n+      \n+      // 먼저 기존 지점 확인\n+      const getRequest = index.get(name);\n+      \n+      getRequest.onsuccess = () => {\n+        if (getRequest.result) {\n+          // 이미 존재함\n+          resolve(getRequest.result);\n+        } else {\n+          // 존재하지 않음, 새로 생성\n+          const now = new Date();\n+          const newBranch: Branch = {\n+            name,\n+            address: branchData?.address || '',\n+            phone: branchData?.phone || '',\n+            isActive: branchData?.isActive ?? true,\n+            id: this.generateUUID(),\n+            createdAt: now,\n+            updatedAt: now,\n+          };\n+\n+          const addRequest = store.add(newBranch);\n+          addRequest.onsuccess = () => {\n+            console.log('새 지점 생성 완료:', newBranch);\n+            resolve(newBranch);\n+          };\n+          addRequest.onerror = () => {\n+            console.error('지점 추가 실패:', addRequest.error);\n+            reject(addRequest.error);\n+          };\n+        }\n+      };\n+      \n+      getRequest.onerror = () => {\n+        console.error('지점 조회 실패:', getRequest.error);\n+        reject(getRequest.error);\n+      };\n+    });\n+  }\n+\n+  /**\n+   * 지점명으로 정확히 일치하는 지점 조회\n+   */\n+  async getBranchByName(name: string): Promise<Branch | null> {\n+    try {\n+      const allBranches = await this.getAllBranches();\n+      const branch = allBranches.find(branch => branch.name === name);\n+      return branch || null;\n+    } catch (error) {\n+      console.error('지점명으로 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 지점명으로 검색\n+   */\n+  async searchBranchesByName(name: string): Promise<Branch[]> {\n+    try {\n+      const allBranches = await this.getAllBranches();\n+      return allBranches.filter(branch => \n+        branch.name.toLowerCase().includes(name.toLowerCase())\n+      );\n+    } catch (error) {\n+      console.error('지점 검색 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  // === 직원 관리 메서드들 ===\n+\n+  /**\n+   * 모든 직원 조회\n+   */\n+  async getAllStaff(): Promise<Staff[]> {\n+    try {\n+      const staffList = await this.executeTransaction('staff', 'readonly', (store) => \n+        store.getAll()\n+      );\n+\n+      // 저장된 파일 데이터를 File 객체로 복원\n+      return staffList.map(staff => {\n+        if (staff.contractFileData && staff.contractFileName) {\n+          // 파일 확장자로부터 MIME 타입 추정\n+          const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n+          let mimeType = 'application/octet-stream';\n+          \n+          if (extension === 'pdf') {\n+            mimeType = 'application/pdf';\n+          } else if (['jpg', 'jpeg'].includes(extension || '')) {\n+            mimeType = 'image/jpeg';\n+          } else if (extension === 'png') {\n+            mimeType = 'image/png';\n+          }\n+\n+          staff.contractFile = this.arrayBufferToFile(\n+            staff.contractFileData, \n+            staff.contractFileName, \n+            mimeType\n+          );\n+        }\n+        return staff;\n+      });\n+    } catch (error) {\n+      console.error('직원 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * ID로 직원 조회\n+   */\n+  async getStaffById(id: string): Promise<Staff | null> {\n+    try {\n+      const staff = await this.executeTransaction('staff', 'readonly', (store) => \n+        store.get(id)\n+      );\n+\n+      if (!staff) return null;\n+\n+      // 저장된 파일 데이터를 File 객체로 복원\n+      if (staff.contractFileData && staff.contractFileName) {\n+        const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n+        let mimeType = 'application/octet-stream';\n+        \n+        if (extension === 'pdf') {\n+          mimeType = 'application/pdf';\n+        } else if (['jpg', 'jpeg'].includes(extension || '')) {\n+          mimeType = 'image/jpeg';\n+        } else if (extension === 'png') {\n+          mimeType = 'image/png';\n+        }\n+\n+        staff.contractFile = this.arrayBufferToFile(\n+          staff.contractFileData, \n+          staff.contractFileName, \n+          mimeType\n+        );\n+      }\n+\n+      return staff;\n+    } catch (error) {\n+      console.error('직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 직원 추가\n+   */\n+  async addStaff(staffData: Omit<Staff, 'id' | 'createdAt' | 'updatedAt'>): Promise<Staff> {\n+    const now = new Date();\n+    \n+    // 파일 데이터 처리\n+    let contractFileData: ArrayBuffer | undefined;\n+    let contractFileName: string | undefined;\n+    \n+    if (staffData.contractFile) {\n+      contractFileData = await this.fileToArrayBuffer(staffData.contractFile);\n+      contractFileName = staffData.contractFile.name;\n+    }\n+\n+    const newStaff: Staff = {\n+      ...staffData,\n+      id: this.generateUUID(),\n+      createdAt: now,\n+      updatedAt: now,\n+      isActive: staffData.isActive !== undefined ? staffData.isActive : true, // 기본값 true\n+      contractFile: undefined, // File 객체는 저장하지 않음\n+      contractFileName,\n+      contractFileData,\n+    };\n+\n+    try {\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.add(newStaff)\n+      );\n+      console.log('직원 추가 성공:', newStaff);\n+      return newStaff;\n+    } catch (error) {\n+      console.error('직원 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 시스템 관리자 계정인지 확인\n+   */\n+  private isSystemAdmin(staff: Staff): boolean {\n+    return staff.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID;\n+  }\n+\n+  /**\n+   * 시스템 관리자 보호 검증\n+   */\n+  private validateSystemAdminProtection(staff: Staff, operation: 'delete' | 'permission_change'): void {\n+    if (this.isSystemAdmin(staff)) {\n+      const message = operation === 'delete' \n+        ? '시스템 관리자 계정은 삭제할 수 없습니다.'\n+        : '시스템 관리자 계정의 권한은 변경할 수 없습니다.';\n+      throw new Error(message);\n+    }\n+  }\n+\n+  /**\n+   * 직원 수정\n+   */\n+  async updateStaff(id: string, updates: Partial<Omit<Staff, 'id' | 'createdAt'>>): Promise<Staff | null> {\n+    try {\n+      const existing = await this.getStaffById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 직원입니다.');\n+      }\n+\n+      // 시스템 관리자 권한 변경 보호\n+      if (updates.permission && updates.permission !== existing.permission) {\n+        this.validateSystemAdminProtection(existing, 'permission_change');\n+      }\n+\n+      // 파일 데이터 처리\n+      let contractFileData = existing.contractFileData;\n+      let contractFileName = existing.contractFileName;\n+      \n+      if (updates.contractFile) {\n+        contractFileData = await this.fileToArrayBuffer(updates.contractFile);\n+        contractFileName = updates.contractFile.name;\n+      }\n+\n+      const updatedStaff: Staff = {\n+        ...existing,\n+        ...updates,\n+        updatedAt: new Date(),\n+        contractFile: undefined, // File 객체는 저장하지 않음\n+        contractFileName,\n+        contractFileData,\n+      };\n+\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.put(updatedStaff)\n+      );\n+\n+      console.log('직원 수정 성공:', updatedStaff);\n+      return updatedStaff;\n+    } catch (error) {\n+      console.error('직원 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 직원 삭제\n+   */\n+  async deleteStaff(id: string): Promise<boolean> {\n+    try {\n+      const existing = await this.getStaffById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 직원입니다.');\n+      }\n+\n+      // 시스템 관리자 삭제 보호\n+      this.validateSystemAdminProtection(existing, 'delete');\n+\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+      console.log('직원 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('직원 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 직원 활성/비활성 상태 토글\n+   */\n+  async toggleStaffStatus(id: string): Promise<Staff | null> {\n+    try {\n+      const existing = await this.getStaffById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 직원입니다.');\n+      }\n+\n+      // 시스템 관리자 상태 변경 보호\n+      if (existing.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID) {\n+        throw new Error('시스템 관리자 계정의 상태는 변경할 수 없습니다.');\n+      }\n+\n+      const updatedStaff = {\n+        ...existing,\n+        isActive: !existing.isActive,\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.put(updatedStaff)\n+      );\n+\n+      console.log('직원 상태 변경 성공:', id, `-> ${updatedStaff.isActive ? '활성' : '비활성'}`);\n+      return updatedStaff;\n+    } catch (error) {\n+      console.error('직원 상태 변경 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 지점별 직원 조회\n+   */\n+  async getStaffByBranch(branchId: string): Promise<Staff[]> {\n+    try {\n+      return await this.executeTransaction('staff', 'readonly', (store) => {\n+        const index = store.index('branchId');\n+        return index.getAll(IDBKeyRange.only(branchId));\n+      });\n+    } catch (error) {\n+      console.error('지점별 직원 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 이메일로 직원 조회\n+   */\n+  async getStaffByEmail(email: string): Promise<Staff | null> {\n+    try {\n+      const result = await this.executeTransaction('staff', 'readonly', (store) => {\n+        const index = store.index('email');\n+        return index.get(email);\n+      });\n+      return result || null;\n+    } catch (error) {\n+      console.error('이메일로 직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 로그인ID로 직원 조회\n+   */\n+  async getStaffByLoginId(loginId: string): Promise<Staff | null> {\n+    try {\n+      const staff = await this.executeTransaction('staff', 'readonly', (store) => {\n+        const index = store.index('loginId');\n+        return index.get(loginId);\n+      });\n+\n+      if (!staff) return null;\n+\n+      // 저장된 파일 데이터를 File 객체로 복원\n+      if (staff.contractFileData && staff.contractFileName) {\n+        const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n+        let mimeType = 'application/octet-stream';\n+        \n+        if (extension === 'pdf') {\n+          mimeType = 'application/pdf';\n+        } else if (['jpg', 'jpeg'].includes(extension || '')) {\n+          mimeType = 'image/jpeg';\n+        } else if (extension === 'png') {\n+          mimeType = 'image/png';\n+        }\n+\n+        staff.contractFile = this.arrayBufferToFile(\n+          staff.contractFileData, \n+          staff.contractFileName, \n+          mimeType\n+        );\n+      }\n+\n+      return staff;\n+    } catch (error) {\n+      console.error('로그인ID로 직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 전화번호로 직원 조회\n+   */\n+  async getStaffByPhone(phone: string): Promise<Staff | null> {\n+    try {\n+      const allStaff = await this.getAllStaff();\n+      const found = allStaff.find(staff => staff.phone === phone);\n+      return found || null;\n+    } catch (error) {\n+      console.error('전화번호로 직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 중복 체크 함수 (등록 시 사용)\n+   */\n+  async checkDuplicateStaff(loginId: string, email: string, phone: string): Promise<{\n+    isDuplicate: boolean;\n+    duplicateField?: 'loginId' | 'email' | 'phone';\n+    message?: string;\n+  }> {\n+    try {\n+      // 로그인 ID 중복 체크\n+      const existingByLoginId = await this.getStaffByLoginId(loginId);\n+      if (existingByLoginId) {\n+        return {\n+          isDuplicate: true,\n+          duplicateField: 'loginId',\n+          message: '이미 사용 중인 로그인 ID입니다.'\n+        };\n+      }\n+\n+      // 이메일 중복 체크\n+      const existingByEmail = await this.getStaffByEmail(email);\n+      if (existingByEmail) {\n+        return {\n+          isDuplicate: true,\n+          duplicateField: 'email',\n+          message: '이미 사용 중인 이메일입니다.'\n+        };\n+      }\n+\n+      // 전화번호 중복 체크\n+      const existingByPhone = await this.getStaffByPhone(phone);\n+      if (existingByPhone) {\n+        return {\n+          isDuplicate: true,\n+          duplicateField: 'phone',\n+          message: '이미 사용 중인 전화번호입니다.'\n+        };\n+      }\n+\n+      return { isDuplicate: false };\n+    } catch (error) {\n+      console.error('중복 체크 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 파일을 ArrayBuffer로 변환\n+   */\n+  private fileToArrayBuffer(file: File): Promise<ArrayBuffer> {\n+    return new Promise((resolve, reject) => {\n+      const reader = new FileReader();\n+      reader.onload = () => resolve(reader.result as ArrayBuffer);\n+      reader.onerror = () => reject(reader.error);\n+      reader.readAsArrayBuffer(file);\n+    });\n+  }\n+\n+  /**\n+   * ArrayBuffer를 Blob으로 변환 (파일 다운로드용)\n+   */\n+  arrayBufferToBlob(buffer: ArrayBuffer, mimeType: string): Blob {\n+    return new Blob([buffer], { type: mimeType });\n+  }\n+\n+  /**\n+   * ArrayBuffer를 File 객체로 변환\n+   */\n+  private arrayBufferToFile(buffer: ArrayBuffer, fileName: string, mimeType: string = 'application/octet-stream'): File {\n+    const blob = new Blob([buffer], { type: mimeType });\n+    return new File([blob], fileName, { type: mimeType });\n+  }\n+\n+  /**\n+   * 데이터베이스 초기화 (개발/테스트용)\n+   */\n+  async clearAllData(): Promise<void> {\n+    try {\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      console.log('모든 데이터 삭제 완료');\n+    } catch (error) {\n+      console.error('데이터 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 기존 직원 데이터의 isActive 필드 초기화 (마이그레이션용)\n+   */\n+  async migrateStaffActiveStatus(): Promise<void> {\n+    try {\n+      const allStaff = await this.executeTransaction('staff', 'readonly', (store) => \n+        store.getAll()\n+      );\n+\n+      // isActive 필드가 없는 직원들을 찾아서 업데이트\n+      const staffToUpdate = allStaff.filter(staff => staff.isActive === undefined);\n+      \n+      if (staffToUpdate.length > 0) {\n+        console.log(`${staffToUpdate.length}명의 직원 isActive 필드를 초기화합니다.`);\n+        \n+        for (const staff of staffToUpdate) {\n+          const updatedStaff = {\n+            ...staff,\n+            isActive: true, // 기본값을 true로 설정\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('staff', 'readwrite', (store) => \n+            store.put(updatedStaff)\n+          );\n+        }\n+        \n+        console.log('직원 isActive 필드 초기화 완료');\n+      }\n+    } catch (error) {\n+      console.error('직원 isActive 필드 초기화 실패:', error);\n+    }\n+  }\n+\n+  // =================== 프로그램 관리 메서드 ===================\n+\n+  /**\n+   * 프로그램 추가\n+   */\n+  async addProgram(programData: Omit<Program, 'id' | 'createdAt' | 'updatedAt'>): Promise<Program> {\n+    try {\n+      // 프로그램명 중복 체크\n+      const existingProgram = await this.getProgramByName(programData.name);\n+      if (existingProgram) {\n+        throw new Error('이미 존재하는 프로그램명입니다.');\n+      }\n+\n+      const newProgram: Program = {\n+        id: this.generateUUID(),\n+        ...programData,\n+        createdAt: new Date(),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.add(newProgram)\n+      );\n+\n+      console.log('프로그램 추가 성공:', newProgram);\n+      return newProgram;\n+    } catch (error) {\n+      console.error('프로그램 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 프로그램 조회\n+   */\n+  async getAllPrograms(): Promise<Program[]> {\n+    try {\n+      const programs = await this.executeTransaction('programs', 'readonly', (store) => \n+        store.getAll()\n+      );\n+      \n+      return programs.map(program => ({\n+        ...program,\n+        createdAt: new Date(program.createdAt),\n+        updatedAt: new Date(program.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('프로그램 목록 조회 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 프로그램명으로 조회\n+   */\n+  async getProgramByName(name: string): Promise<Program | null> {\n+    try {\n+      const program = await this.executeTransaction('programs', 'readonly', (store) => \n+        store.index('name').get(name)\n+      );\n+      \n+      if (program) {\n+        return {\n+          ...program,\n+          createdAt: new Date(program.createdAt),\n+          updatedAt: new Date(program.updatedAt)\n+        };\n+      }\n+      \n+      return null;\n+    } catch (error) {\n+      console.error('프로그램 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 프로그램 수정\n+   */\n+  async updateProgram(id: string, updates: Partial<Omit<Program, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Program | null> {\n+    try {\n+      const existingProgram = await this.executeTransaction('programs', 'readonly', (store) => \n+        store.get(id)\n+      );\n+\n+      if (!existingProgram) {\n+        console.error('수정할 프로그램을 찾을 수 없습니다:', id);\n+        return null;\n+      }\n+\n+      // 프로그램명 변경 시 중복 체크\n+      if (updates.name && updates.name !== existingProgram.name) {\n+        const duplicateProgram = await this.getProgramByName(updates.name);\n+        if (duplicateProgram) {\n+          throw new Error('이미 존재하는 프로그램명입니다.');\n+        }\n+      }\n+\n+      const updatedProgram: Program = {\n+        ...existingProgram,\n+        ...updates,\n+        id,\n+        createdAt: new Date(existingProgram.createdAt),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.put(updatedProgram)\n+      );\n+\n+      console.log('프로그램 수정 성공:', updatedProgram);\n+      return updatedProgram;\n+    } catch (error) {\n+      console.error('프로그램 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 프로그램 삭제\n+   */\n+  async deleteProgram(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('프로그램 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('프로그램 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  // =================== 상품 관리 메서드 ===================\n+\n+  /**\n+   * 상품 추가\n+   */\n+  async addProduct(productData: Omit<Product, 'id' | 'createdAt' | 'updatedAt'>): Promise<Product> {\n+    try {\n+      const newProduct: Product = {\n+        id: this.generateUUID(),\n+        ...productData,\n+        createdAt: new Date(),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.add(newProduct)\n+      );\n+\n+      console.log('상품 추가 성공:', newProduct);\n+      return newProduct;\n+    } catch (error) {\n+      console.error('상품 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 상품 조회\n+   */\n+  async getAllProducts(): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => \n+        store.getAll()\n+      );\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('상품 목록 조회 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * ID로 상품 조회\n+   */\n+  async getProductById(id: string): Promise<Product | null> {\n+    try {\n+      const product = await this.executeTransaction('products', 'readonly', (store) => \n+        store.get(id)\n+      );\n+      \n+      if (product) {\n+        return {\n+          ...product,\n+          createdAt: new Date(product.createdAt),\n+          updatedAt: new Date(product.updatedAt)\n+        };\n+      }\n+      \n+      return null;\n+    } catch (error) {\n+      console.error('상품 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 지점별 상품 조회\n+   */\n+  async getProductsByBranch(branchId: string): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('branchId');\n+        return index.getAll(IDBKeyRange.only(branchId));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('지점별 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 프로그램별 상품 조회\n+   */\n+  async getProductsByProgram(programId: string): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('programId');\n+        return index.getAll(IDBKeyRange.only(programId));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('프로그램별 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 지점과 프로그램으로 상품 조회\n+   */\n+  async getProductsByBranchAndProgram(branchId: string, programId: string): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('branchProgram');\n+        return index.getAll(IDBKeyRange.only([branchId, programId]));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('지점-프로그램별 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 상품 수정\n+   */\n+  async updateProduct(id: string, updates: Partial<Omit<Product, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Product | null> {\n+    try {\n+      const existingProduct = await this.executeTransaction('products', 'readonly', (store) => \n+        store.get(id)\n+      );\n+\n+      if (!existingProduct) {\n+        console.error('수정할 상품을 찾을 수 없습니다:', id);\n+        return null;\n+      }\n+\n+      const updatedProduct: Product = {\n+        ...existingProduct,\n+        ...updates,\n+        id,\n+        createdAt: new Date(existingProduct.createdAt),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.put(updatedProduct)\n+      );\n+\n+      console.log('상품 수정 성공:', updatedProduct);\n+      return updatedProduct;\n+    } catch (error) {\n+      console.error('상품 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 상품 삭제\n+   */\n+  async deleteProduct(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('상품 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('상품 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 활성 상품만 조회\n+   */\n+  async getActiveProducts(): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('isActive');\n+        return index.getAll(IDBKeyRange.only(true));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('활성 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 상품명으로 검색\n+   */\n+  async searchProductsByName(name: string): Promise<Product[]> {\n+    try {\n+      const allProducts = await this.getAllProducts();\n+      return allProducts.filter(product => \n+        product.name.toLowerCase().includes(name.toLowerCase())\n+      );\n+    } catch (error) {\n+      console.error('상품 검색 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  // ==================== 휴일설정 관련 메서드 ====================\n+\n+  /**\n+   * 휴일설정 추가/업데이트\n+   */\n+  async saveHolidaySettings(settingsArray: Omit<HolidaySettings, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<HolidaySettings[]> {\n+    try {\n+      const savedSettings: HolidaySettings[] = [];\n+      \n+      for (const setting of settingsArray) {\n+        // 기존 설정이 있는지 확인\n+        const existingSettings = await this.getHolidaySettingsByStaffAndDate(setting.staffId, setting.date);\n+        \n+        let savedSetting: HolidaySettings;\n+        \n+        if (existingSettings.length > 0) {\n+          // 업데이트\n+          const existing = existingSettings[0];\n+          savedSetting = {\n+            ...existing,\n+            ...setting,\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n+            store.put(savedSetting)\n+          );\n+        } else {\n+          // 새로 추가\n+          savedSetting = {\n+            ...setting,\n+            id: this.generateUUID(),\n+            createdAt: new Date(),\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n+            store.add(savedSetting)\n+          );\n+        }\n+        \n+        savedSettings.push(savedSetting);\n+      }\n+\n+      console.log('휴일설정 저장 성공:', savedSettings.length);\n+      return savedSettings;\n+    } catch (error) {\n+      console.error('휴일설정 저장 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 모든 휴일설정 조회\n+   */\n+  async getHolidaySettingsByStaff(staffId: string): Promise<HolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n+        const index = store.index('staffId');\n+        return index.getAll(IDBKeyRange.only(staffId));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('직원별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 특정 날짜 휴일설정 조회\n+   */\n+  async getHolidaySettingsByStaffAndDate(staffId: string, date: string): Promise<HolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n+        const index = store.index('staffDate');\n+        return index.getAll(IDBKeyRange.only([staffId, date]));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('직원별 날짜별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 특정 날짜의 모든 휴일설정 조회\n+   */\n+  async getHolidaySettingsByDate(date: string): Promise<HolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n+        const index = store.index('date');\n+        return index.getAll(IDBKeyRange.only(date));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('날짜별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 날짜 범위의 휴일설정 조회\n+   */\n+  async getHolidaySettingsByDateRange(startDate: string, endDate: string): Promise<HolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n+        const index = store.index('date');\n+        return index.getAll(IDBKeyRange.bound(startDate, endDate));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('날짜 범위별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 휴일설정 삭제\n+   */\n+  async deleteHolidaySettings(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('휴일설정 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('휴일설정 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 모든 휴일설정 삭제\n+   */\n+  async deleteHolidaySettingsByStaff(staffId: string): Promise<boolean> {\n+    try {\n+      const settings = await this.getHolidaySettingsByStaff(staffId);\n+      \n+      for (const setting of settings) {\n+        await this.deleteHolidaySettings(setting.id);\n+      }\n+\n+      console.log('직원 휴일설정 전체 삭제 성공:', staffId);\n+      return true;\n+    } catch (error) {\n+      console.error('직원 휴일설정 전체 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+}\n+\n+// 싱글톤 인스턴스 생성\n+export const dbManager = new IndexedDBManager();\n+\n+// 개발자 도구에서 사용할 수 있도록 전역 객체에 추가\n+if (typeof window !== 'undefined') {\n+  (window as any).dbManager = dbManager;\n+}\n"
                },
                {
                    "date": 1760164637631,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,11 +75,20 @@\n     end: number;\n   }; // 해당 날짜의 근무시간 (휴일이 아닌 경우)\n }\n \n+export interface TermsDocument extends DBRecord {\n+  type: 'privacy_policy' | 'terms_of_service' | 'business_info' | 'marketing_consent' | 'member_terms' | 'contract';\n+  title: string;\n+  content: string;\n+  version: number; // 버전 관리\n+  isActive: boolean;\n+  publishedAt?: Date | null; // 발행일\n+}\n+\n class IndexedDBManager {\n   private dbName: string = 'LavidaDB';\n-  private version: number = 7; // 버전 업데이트 (HolidaySettings 테이블 추가)\n+  private version: number = 8; // 버전 업데이트 (TermsDocument 테이블 추가)\n   private db: IDBDatabase | null = null;\n \n   constructor() {\n     this.initDB();\n@@ -188,8 +197,24 @@\n           // 복합 인덱스: 직원별, 날짜별 조회 최적화\n           holidayStore.createIndex('staffDate', ['staffId', 'date'], { unique: true });\n         }\n \n+        // 약관/문서 테이블 생성\n+        if (!db.objectStoreNames.contains('termsDocuments')) {\n+          const termsStore = db.createObjectStore('termsDocuments', { keyPath: 'id' });\n+          termsStore.createIndex('type', 'type', { unique: false });\n+          termsStore.createIndex('language', 'language', { unique: false });\n+          termsStore.createIndex('title', 'title', { unique: false });\n+          termsStore.createIndex('version', 'version', { unique: false });\n+          termsStore.createIndex('isActive', 'isActive', { unique: false });\n+          termsStore.createIndex('publishedAt', 'publishedAt', { unique: false });\n+          termsStore.createIndex('createdAt', 'createdAt', { unique: false });\n+          // 복합 인덱스: 타입별, 언어별 조회 최적화\n+          termsStore.createIndex('typeLanguage', ['type', 'language'], { unique: false });\n+          // 활성 상태 및 최신 버전 조회 최적화\n+          termsStore.createIndex('typeLanguageActive', ['type', 'language', 'isActive'], { unique: false });\n+        }\n+\n         // 향후 다른 테이블들도 여기에 추가 가능\n         // 예: 회원, 방문기록 등\n       };\n     });\n@@ -834,8 +859,14 @@\n       );\n       await this.executeTransaction('products', 'readwrite', (store) => \n         store.clear()\n       );\n+      await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n+        store.clear()\n+      );\n       console.log('모든 데이터 삭제 완료');\n     } catch (error) {\n       console.error('데이터 삭제 실패:', error);\n       throw error;\n@@ -1401,1222 +1432,222 @@\n       console.error('직원 휴일설정 전체 삭제 실패:', error);\n       throw error;\n     }\n   }\n-}\n \n-// 싱글톤 인스턴스 생성\n-export const dbManager = new IndexedDBManager();\n+  // ==================== 약관/문서 관련 메서드 ====================\n \n-// 개발자 도구에서 사용할 수 있도록 전역 객체에 추가\n-if (typeof window !== 'undefined') {\n-  (window as any).dbManager = dbManager;\n-}\n-/**\n- * IndexedDB를 활용한 로컬 데이터베이스 관리 유틸리티\n- * 백엔드 연결 전까지 브라우저에서 데이터를 영구 저장\n- */\n-\n-import { SYSTEM_ADMIN_CONFIG } from '../constants/staffConstants';\n-\n-export interface DBRecord {\n-  id: string;\n-  createdAt: Date;\n-  updatedAt: Date;\n-}\n-\n-export interface Branch extends DBRecord {\n-  name: string;\n-  address?: string;\n-  phone?: string;\n-  isActive: boolean;\n-}\n-\n-export interface AppSettings extends DBRecord {\n-  key: string;\n-  value: string;\n-}\n-\n-export interface Staff extends DBRecord {\n-  name: string;\n-  loginId: string; // 로그인 ID\n-  password: string; // 비밀번호\n-  phone: string;\n-  email: string;\n-  branchId: string;\n-  position: string; // 직급\n-  role: string; // 직책\n-  employmentType: string; // 고용형태\n-  permission: string; // 권한\n-  program?: string; // 담당프로그램 (코치일 경우만)\n-  contractStartDate: Date;\n-  contractEndDate?: Date | null; // 계약종료일 (정규직은 없을 수 있음)\n-  contractFile?: File | null; // 계약서 파일\n-  contractFileName?: string; // 계약서 파일명 저장용\n-  contractFileData?: ArrayBuffer; // 계약서 파일 데이터 저장용\n-  isActive: boolean; // 활성/비활성 상태\n-}\n-\n-export interface Program extends DBRecord {\n-  name: string;\n-  type: string; // '횟수제' | '기간제'\n-  isActive: boolean;\n-}\n-\n-export interface Product extends DBRecord {\n-  name: string;\n-  branchId: string;\n-  programId: string;\n-  programName: string; // 프로그램명 저장 (조회 성능 향상)\n-  programType: string; // 프로그램 종류 저장 (조회 성능 향상)\n-  sessions?: number; // 횟수 (횟수제인 경우에만 필요)\n-  duration?: number; // 소요시간 (분 단위, 횟수제인 경우에만 필요)\n-  price?: number; // 가격\n-  description?: string; // 상품소개\n-  isActive: boolean;\n-}\n-\n-class IndexedDBManager {\n-  private dbName: string = 'LavidaDB';\n-  private version: number = 6; // 버전 업데이트 (Product 테이블 추가)\n-  private db: IDBDatabase | null = null;\n-\n-  constructor() {\n-    this.initDB();\n-  }\n-\n   /**\n-   * IndexedDB 초기화\n+   * 약관/문서 추가\n    */\n-  private async initDB(): Promise<void> {\n-    return new Promise((resolve, reject) => {\n-      const request = indexedDB.open(this.dbName, this.version);\n-\n-      request.onerror = () => {\n-        console.error('IndexedDB 열기 실패:', request.error);\n-        reject(request.error);\n-      };\n-\n-      request.onsuccess = () => {\n-        this.db = request.result;\n-        console.log('IndexedDB 연결 성공');\n-        resolve();\n-      };\n-\n-      request.onupgradeneeded = (event) => {\n-        const db = (event.target as IDBOpenDBRequest).result;\n-\n-        // 지점 테이블 생성\n-        if (!db.objectStoreNames.contains('branches')) {\n-          const branchStore = db.createObjectStore('branches', { keyPath: 'id' });\n-          branchStore.createIndex('name', 'name', { unique: true }); // 지점명 고유 제약\n-          branchStore.createIndex('isActive', 'isActive', { unique: false });\n-          branchStore.createIndex('createdAt', 'createdAt', { unique: false });\n-        } else {\n-          // 기존 테이블이 있으면 인덱스 업데이트\n-          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n-          const branchStore = transaction.objectStore('branches');\n-          \n-          // 기존 name 인덱스 삭제 후 unique로 재생성\n-          if (branchStore.indexNames.contains('name')) {\n-            branchStore.deleteIndex('name');\n-          }\n-          branchStore.createIndex('name', 'name', { unique: true });\n-        }\n-\n-        // 직원 테이블 생성\n-        if (!db.objectStoreNames.contains('staff')) {\n-          const staffStore = db.createObjectStore('staff', { keyPath: 'id' });\n-          staffStore.createIndex('name', 'name', { unique: false });\n-          staffStore.createIndex('loginId', 'loginId', { unique: true });\n-          staffStore.createIndex('email', 'email', { unique: true });\n-          staffStore.createIndex('branchId', 'branchId', { unique: false });\n-          staffStore.createIndex('position', 'position', { unique: false });\n-          staffStore.createIndex('role', 'role', { unique: false });\n-          staffStore.createIndex('employmentType', 'employmentType', { unique: false });\n-          staffStore.createIndex('permission', 'permission', { unique: false });\n-          staffStore.createIndex('isActive', 'isActive', { unique: false });\n-          staffStore.createIndex('createdAt', 'createdAt', { unique: false });\n-        } else {\n-          // 기존 테이블이 있으면 인덱스 업데이트 (isActive 인덱스 추가)\n-          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n-          const staffStore = transaction.objectStore('staff');\n-          \n-          if (!staffStore.indexNames.contains('isActive')) {\n-            staffStore.createIndex('isActive', 'isActive', { unique: false });\n-          }\n-        }\n-\n-        // 프로그램 테이블 생성\n-        if (!db.objectStoreNames.contains('programs')) {\n-          const programStore = db.createObjectStore('programs', { keyPath: 'id' });\n-          programStore.createIndex('name', 'name', { unique: true }); // 프로그램명 고유 제약\n-          programStore.createIndex('type', 'type', { unique: false });\n-          programStore.createIndex('isActive', 'isActive', { unique: false });\n-          programStore.createIndex('createdAt', 'createdAt', { unique: false });\n-        } else {\n-          // 기존 테이블이 있으면 인덱스 업데이트\n-          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n-          const programStore = transaction.objectStore('programs');\n-          \n-          // 기존 name 인덱스 삭제 후 unique로 재생성\n-          if (programStore.indexNames.contains('name')) {\n-            programStore.deleteIndex('name');\n-          }\n-          programStore.createIndex('name', 'name', { unique: true });\n-        }\n-\n-        // 상품 테이블 생성\n-        if (!db.objectStoreNames.contains('products')) {\n-          const productStore = db.createObjectStore('products', { keyPath: 'id' });\n-          productStore.createIndex('name', 'name', { unique: false });\n-          productStore.createIndex('branchId', 'branchId', { unique: false });\n-          productStore.createIndex('programId', 'programId', { unique: false });\n-          productStore.createIndex('programType', 'programType', { unique: false });\n-          productStore.createIndex('isActive', 'isActive', { unique: false });\n-          productStore.createIndex('createdAt', 'createdAt', { unique: false });\n-          // 복합 인덱스: 지점별, 프로그램별 조회 최적화\n-          productStore.createIndex('branchProgram', ['branchId', 'programId'], { unique: false });\n-        }\n-\n-        // 향후 다른 테이블들도 여기에 추가 가능\n-        // 예: 회원, 방문기록 등\n-      };\n-    });\n-  }\n-\n-  /**\n-   * 고유 ID 생성 (UUID v4 형식)\n-   */\n-  private generateUUID(): string {\n-    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n-      const r = Math.random() * 16 | 0;\n-      const v = c === 'x' ? r : ((r & 0x3) | 0x8);\n-      return v.toString(16);\n-    });\n-  }\n-\n-  /**\n-   * 트랜잭션 실행 헬퍼\n-   */\n-  private async executeTransaction<T>(\n-    storeName: string,\n-    mode: IDBTransactionMode,\n-    operation: (store: IDBObjectStore) => IDBRequest<T>\n-  ): Promise<T> {\n-    if (!this.db) {\n-      await this.initDB();\n-    }\n-\n-    return new Promise((resolve, reject) => {\n-      const transaction = this.db!.transaction([storeName], mode);\n-      const store = transaction.objectStore(storeName);\n-      const request = operation(store);\n-\n-      request.onsuccess = () => resolve(request.result);\n-      request.onerror = () => reject(request.error);\n-    });\n-  }\n-\n-  // === 지점 관리 메서드들 ===\n-\n-  /**\n-   * 모든 지점 조회\n-   */\n-  async getAllBranches(): Promise<Branch[]> {\n+  async addTermsDocument(documentData: Omit<TermsDocument, 'id' | 'createdAt' | 'updatedAt' | 'version'>): Promise<TermsDocument> {\n     try {\n-      return await this.executeTransaction('branches', 'readonly', (store) => \n-        store.getAll()\n-      );\n-    } catch (error) {\n-      console.error('지점 조회 실패:', error);\n-      return [];\n-    }\n-  }\n+      // 같은 타입의 기존 문서들의 최대 버전 찾기\n+      const existingDocs = await this.getTermsDocumentsByType(documentData.type);\n+      const maxVersion = existingDocs.length > 0 ? Math.max(...existingDocs.map(doc => doc.version)) : 0;\n \n-  /**\n-   * ID로 지점 조회\n-   */\n-  async getBranchById(id: string): Promise<Branch | null> {\n-    try {\n-      const result = await this.executeTransaction('branches', 'readonly', (store) => \n-        store.get(id)\n-      );\n-      return result || null;\n-    } catch (error) {\n-      console.error('지점 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 지점 추가\n-   */\n-  async addBranch(branchData: Omit<Branch, 'id' | 'createdAt' | 'updatedAt'>): Promise<Branch> {\n-    const now = new Date();\n-    const newBranch: Branch = {\n-      ...branchData,\n-      id: this.generateUUID(),\n-      createdAt: now,\n-      updatedAt: now,\n-    };\n-\n-    try {\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.add(newBranch)\n-      );\n-      console.log('지점 추가 성공:', newBranch);\n-      return newBranch;\n-    } catch (error) {\n-      console.error('지점 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 지점 수정\n-   */\n-  async updateBranch(id: string, updates: Partial<Omit<Branch, 'id' | 'createdAt'>>): Promise<Branch | null> {\n-    try {\n-      const existing = await this.getBranchById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 지점입니다.');\n+      // 기존 활성 문서들 비활성화\n+      for (const doc of existingDocs.filter(d => d.isActive)) {\n+        await this.updateTermsDocument(doc.id, { isActive: false });\n       }\n \n-      const updatedBranch: Branch = {\n-        ...existing,\n-        ...updates,\n-        updatedAt: new Date(),\n-      };\n-\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.put(updatedBranch)\n-      );\n-\n-      console.log('지점 수정 성공:', updatedBranch);\n-      return updatedBranch;\n-    } catch (error) {\n-      console.error('지점 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 지점 삭제\n-   */\n-  async deleteBranch(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-      console.log('지점 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('지점 삭제 실패:', error);\n-      return false;\n-    }\n-  }\n-\n-  /**\n-   * 활성 지점만 조회\n-   */\n-  async getActiveBranches(): Promise<Branch[]> {\n-    try {\n-      return await this.executeTransaction('branches', 'readonly', (store) => {\n-        const index = store.index('isActive');\n-        return index.getAll(IDBKeyRange.only(true));\n-      });\n-    } catch (error) {\n-      console.error('활성 지점 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 지점명으로 정확히 일치하는 지점 조회 또는 생성 (원자적 처리)\n-   * 동시 실행 시 race condition 방지\n-   */\n-  async getOrCreateBranchByName(name: string, branchData?: Omit<Branch, 'id' | 'createdAt' | 'updatedAt' | 'name'>): Promise<Branch> {\n-    if (!this.db) {\n-      await this.initDB();\n-    }\n-\n-    return new Promise((resolve, reject) => {\n-      const transaction = this.db!.transaction(['branches'], 'readwrite');\n-      const store = transaction.objectStore('branches');\n-      const index = store.index('name');\n-      \n-      // 먼저 기존 지점 확인\n-      const getRequest = index.get(name);\n-      \n-      getRequest.onsuccess = () => {\n-        if (getRequest.result) {\n-          // 이미 존재함\n-          resolve(getRequest.result);\n-        } else {\n-          // 존재하지 않음, 새로 생성\n-          const now = new Date();\n-          const newBranch: Branch = {\n-            name,\n-            address: branchData?.address || '',\n-            phone: branchData?.phone || '',\n-            isActive: branchData?.isActive ?? true,\n-            id: this.generateUUID(),\n-            createdAt: now,\n-            updatedAt: now,\n-          };\n-\n-          const addRequest = store.add(newBranch);\n-          addRequest.onsuccess = () => {\n-            console.log('새 지점 생성 완료:', newBranch);\n-            resolve(newBranch);\n-          };\n-          addRequest.onerror = () => {\n-            console.error('지점 추가 실패:', addRequest.error);\n-            reject(addRequest.error);\n-          };\n-        }\n-      };\n-      \n-      getRequest.onerror = () => {\n-        console.error('지점 조회 실패:', getRequest.error);\n-        reject(getRequest.error);\n-      };\n-    });\n-  }\n-\n-  /**\n-   * 지점명으로 정확히 일치하는 지점 조회\n-   */\n-  async getBranchByName(name: string): Promise<Branch | null> {\n-    try {\n-      const allBranches = await this.getAllBranches();\n-      const branch = allBranches.find(branch => branch.name === name);\n-      return branch || null;\n-    } catch (error) {\n-      console.error('지점명으로 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 지점명으로 검색\n-   */\n-  async searchBranchesByName(name: string): Promise<Branch[]> {\n-    try {\n-      const allBranches = await this.getAllBranches();\n-      return allBranches.filter(branch => \n-        branch.name.toLowerCase().includes(name.toLowerCase())\n-      );\n-    } catch (error) {\n-      console.error('지점 검색 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  // === 직원 관리 메서드들 ===\n-\n-  /**\n-   * 모든 직원 조회\n-   */\n-  async getAllStaff(): Promise<Staff[]> {\n-    try {\n-      const staffList = await this.executeTransaction('staff', 'readonly', (store) => \n-        store.getAll()\n-      );\n-\n-      // 저장된 파일 데이터를 File 객체로 복원\n-      return staffList.map(staff => {\n-        if (staff.contractFileData && staff.contractFileName) {\n-          // 파일 확장자로부터 MIME 타입 추정\n-          const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n-          let mimeType = 'application/octet-stream';\n-          \n-          if (extension === 'pdf') {\n-            mimeType = 'application/pdf';\n-          } else if (['jpg', 'jpeg'].includes(extension || '')) {\n-            mimeType = 'image/jpeg';\n-          } else if (extension === 'png') {\n-            mimeType = 'image/png';\n-          }\n-\n-          staff.contractFile = this.arrayBufferToFile(\n-            staff.contractFileData, \n-            staff.contractFileName, \n-            mimeType\n-          );\n-        }\n-        return staff;\n-      });\n-    } catch (error) {\n-      console.error('직원 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * ID로 직원 조회\n-   */\n-  async getStaffById(id: string): Promise<Staff | null> {\n-    try {\n-      const staff = await this.executeTransaction('staff', 'readonly', (store) => \n-        store.get(id)\n-      );\n-\n-      if (!staff) return null;\n-\n-      // 저장된 파일 데이터를 File 객체로 복원\n-      if (staff.contractFileData && staff.contractFileName) {\n-        const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n-        let mimeType = 'application/octet-stream';\n-        \n-        if (extension === 'pdf') {\n-          mimeType = 'application/pdf';\n-        } else if (['jpg', 'jpeg'].includes(extension || '')) {\n-          mimeType = 'image/jpeg';\n-        } else if (extension === 'png') {\n-          mimeType = 'image/png';\n-        }\n-\n-        staff.contractFile = this.arrayBufferToFile(\n-          staff.contractFileData, \n-          staff.contractFileName, \n-          mimeType\n-        );\n-      }\n-\n-      return staff;\n-    } catch (error) {\n-      console.error('직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 직원 추가\n-   */\n-  async addStaff(staffData: Omit<Staff, 'id' | 'createdAt' | 'updatedAt'>): Promise<Staff> {\n-    const now = new Date();\n-    \n-    // 파일 데이터 처리\n-    let contractFileData: ArrayBuffer | undefined;\n-    let contractFileName: string | undefined;\n-    \n-    if (staffData.contractFile) {\n-      contractFileData = await this.fileToArrayBuffer(staffData.contractFile);\n-      contractFileName = staffData.contractFile.name;\n-    }\n-\n-    const newStaff: Staff = {\n-      ...staffData,\n-      id: this.generateUUID(),\n-      createdAt: now,\n-      updatedAt: now,\n-      isActive: staffData.isActive !== undefined ? staffData.isActive : true, // 기본값 true\n-      contractFile: undefined, // File 객체는 저장하지 않음\n-      contractFileName,\n-      contractFileData,\n-    };\n-\n-    try {\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.add(newStaff)\n-      );\n-      console.log('직원 추가 성공:', newStaff);\n-      return newStaff;\n-    } catch (error) {\n-      console.error('직원 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 시스템 관리자 계정인지 확인\n-   */\n-  private isSystemAdmin(staff: Staff): boolean {\n-    return staff.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID;\n-  }\n-\n-  /**\n-   * 시스템 관리자 보호 검증\n-   */\n-  private validateSystemAdminProtection(staff: Staff, operation: 'delete' | 'permission_change'): void {\n-    if (this.isSystemAdmin(staff)) {\n-      const message = operation === 'delete' \n-        ? '시스템 관리자 계정은 삭제할 수 없습니다.'\n-        : '시스템 관리자 계정의 권한은 변경할 수 없습니다.';\n-      throw new Error(message);\n-    }\n-  }\n-\n-  /**\n-   * 직원 수정\n-   */\n-  async updateStaff(id: string, updates: Partial<Omit<Staff, 'id' | 'createdAt'>>): Promise<Staff | null> {\n-    try {\n-      const existing = await this.getStaffById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 직원입니다.');\n-      }\n-\n-      // 시스템 관리자 권한 변경 보호\n-      if (updates.permission && updates.permission !== existing.permission) {\n-        this.validateSystemAdminProtection(existing, 'permission_change');\n-      }\n-\n-      // 파일 데이터 처리\n-      let contractFileData = existing.contractFileData;\n-      let contractFileName = existing.contractFileName;\n-      \n-      if (updates.contractFile) {\n-        contractFileData = await this.fileToArrayBuffer(updates.contractFile);\n-        contractFileName = updates.contractFile.name;\n-      }\n-\n-      const updatedStaff: Staff = {\n-        ...existing,\n-        ...updates,\n-        updatedAt: new Date(),\n-        contractFile: undefined, // File 객체는 저장하지 않음\n-        contractFileName,\n-        contractFileData,\n-      };\n-\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.put(updatedStaff)\n-      );\n-\n-      console.log('직원 수정 성공:', updatedStaff);\n-      return updatedStaff;\n-    } catch (error) {\n-      console.error('직원 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 직원 삭제\n-   */\n-  async deleteStaff(id: string): Promise<boolean> {\n-    try {\n-      const existing = await this.getStaffById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 직원입니다.');\n-      }\n-\n-      // 시스템 관리자 삭제 보호\n-      this.validateSystemAdminProtection(existing, 'delete');\n-\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-      console.log('직원 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('직원 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 직원 활성/비활성 상태 토글\n-   */\n-  async toggleStaffStatus(id: string): Promise<Staff | null> {\n-    try {\n-      const existing = await this.getStaffById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 직원입니다.');\n-      }\n-\n-      // 시스템 관리자 상태 변경 보호\n-      if (existing.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID) {\n-        throw new Error('시스템 관리자 계정의 상태는 변경할 수 없습니다.');\n-      }\n-\n-      const updatedStaff = {\n-        ...existing,\n-        isActive: !existing.isActive,\n-        updatedAt: new Date()\n-      };\n-\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.put(updatedStaff)\n-      );\n-\n-      console.log('직원 상태 변경 성공:', id, `-> ${updatedStaff.isActive ? '활성' : '비활성'}`);\n-      return updatedStaff;\n-    } catch (error) {\n-      console.error('직원 상태 변경 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 지점별 직원 조회\n-   */\n-  async getStaffByBranch(branchId: string): Promise<Staff[]> {\n-    try {\n-      return await this.executeTransaction('staff', 'readonly', (store) => {\n-        const index = store.index('branchId');\n-        return index.getAll(IDBKeyRange.only(branchId));\n-      });\n-    } catch (error) {\n-      console.error('지점별 직원 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 이메일로 직원 조회\n-   */\n-  async getStaffByEmail(email: string): Promise<Staff | null> {\n-    try {\n-      const result = await this.executeTransaction('staff', 'readonly', (store) => {\n-        const index = store.index('email');\n-        return index.get(email);\n-      });\n-      return result || null;\n-    } catch (error) {\n-      console.error('이메일로 직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 로그인ID로 직원 조회\n-   */\n-  async getStaffByLoginId(loginId: string): Promise<Staff | null> {\n-    try {\n-      const staff = await this.executeTransaction('staff', 'readonly', (store) => {\n-        const index = store.index('loginId');\n-        return index.get(loginId);\n-      });\n-\n-      if (!staff) return null;\n-\n-      // 저장된 파일 데이터를 File 객체로 복원\n-      if (staff.contractFileData && staff.contractFileName) {\n-        const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n-        let mimeType = 'application/octet-stream';\n-        \n-        if (extension === 'pdf') {\n-          mimeType = 'application/pdf';\n-        } else if (['jpg', 'jpeg'].includes(extension || '')) {\n-          mimeType = 'image/jpeg';\n-        } else if (extension === 'png') {\n-          mimeType = 'image/png';\n-        }\n-\n-        staff.contractFile = this.arrayBufferToFile(\n-          staff.contractFileData, \n-          staff.contractFileName, \n-          mimeType\n-        );\n-      }\n-\n-      return staff;\n-    } catch (error) {\n-      console.error('로그인ID로 직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 전화번호로 직원 조회\n-   */\n-  async getStaffByPhone(phone: string): Promise<Staff | null> {\n-    try {\n-      const allStaff = await this.getAllStaff();\n-      const found = allStaff.find(staff => staff.phone === phone);\n-      return found || null;\n-    } catch (error) {\n-      console.error('전화번호로 직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 중복 체크 함수 (등록 시 사용)\n-   */\n-  async checkDuplicateStaff(loginId: string, email: string, phone: string): Promise<{\n-    isDuplicate: boolean;\n-    duplicateField?: 'loginId' | 'email' | 'phone';\n-    message?: string;\n-  }> {\n-    try {\n-      // 로그인 ID 중복 체크\n-      const existingByLoginId = await this.getStaffByLoginId(loginId);\n-      if (existingByLoginId) {\n-        return {\n-          isDuplicate: true,\n-          duplicateField: 'loginId',\n-          message: '이미 사용 중인 로그인 ID입니다.'\n-        };\n-      }\n-\n-      // 이메일 중복 체크\n-      const existingByEmail = await this.getStaffByEmail(email);\n-      if (existingByEmail) {\n-        return {\n-          isDuplicate: true,\n-          duplicateField: 'email',\n-          message: '이미 사용 중인 이메일입니다.'\n-        };\n-      }\n-\n-      // 전화번호 중복 체크\n-      const existingByPhone = await this.getStaffByPhone(phone);\n-      if (existingByPhone) {\n-        return {\n-          isDuplicate: true,\n-          duplicateField: 'phone',\n-          message: '이미 사용 중인 전화번호입니다.'\n-        };\n-      }\n-\n-      return { isDuplicate: false };\n-    } catch (error) {\n-      console.error('중복 체크 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 파일을 ArrayBuffer로 변환\n-   */\n-  private fileToArrayBuffer(file: File): Promise<ArrayBuffer> {\n-    return new Promise((resolve, reject) => {\n-      const reader = new FileReader();\n-      reader.onload = () => resolve(reader.result as ArrayBuffer);\n-      reader.onerror = () => reject(reader.error);\n-      reader.readAsArrayBuffer(file);\n-    });\n-  }\n-\n-  /**\n-   * ArrayBuffer를 Blob으로 변환 (파일 다운로드용)\n-   */\n-  arrayBufferToBlob(buffer: ArrayBuffer, mimeType: string): Blob {\n-    return new Blob([buffer], { type: mimeType });\n-  }\n-\n-  /**\n-   * ArrayBuffer를 File 객체로 변환\n-   */\n-  private arrayBufferToFile(buffer: ArrayBuffer, fileName: string, mimeType: string = 'application/octet-stream'): File {\n-    const blob = new Blob([buffer], { type: mimeType });\n-    return new File([blob], fileName, { type: mimeType });\n-  }\n-\n-  /**\n-   * 데이터베이스 초기화 (개발/테스트용)\n-   */\n-  async clearAllData(): Promise<void> {\n-    try {\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('programs', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('products', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      console.log('모든 데이터 삭제 완료');\n-    } catch (error) {\n-      console.error('데이터 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 기존 직원 데이터의 isActive 필드 초기화 (마이그레이션용)\n-   */\n-  async migrateStaffActiveStatus(): Promise<void> {\n-    try {\n-      const allStaff = await this.executeTransaction('staff', 'readonly', (store) => \n-        store.getAll()\n-      );\n-\n-      // isActive 필드가 없는 직원들을 찾아서 업데이트\n-      const staffToUpdate = allStaff.filter(staff => staff.isActive === undefined);\n-      \n-      if (staffToUpdate.length > 0) {\n-        console.log(`${staffToUpdate.length}명의 직원 isActive 필드를 초기화합니다.`);\n-        \n-        for (const staff of staffToUpdate) {\n-          const updatedStaff = {\n-            ...staff,\n-            isActive: true, // 기본값을 true로 설정\n-            updatedAt: new Date()\n-          };\n-          \n-          await this.executeTransaction('staff', 'readwrite', (store) => \n-            store.put(updatedStaff)\n-          );\n-        }\n-        \n-        console.log('직원 isActive 필드 초기화 완료');\n-      }\n-    } catch (error) {\n-      console.error('직원 isActive 필드 초기화 실패:', error);\n-    }\n-  }\n-\n-  // =================== 프로그램 관리 메서드 ===================\n-\n-  /**\n-   * 프로그램 추가\n-   */\n-  async addProgram(programData: Omit<Program, 'id' | 'createdAt' | 'updatedAt'>): Promise<Program> {\n-    try {\n-      // 프로그램명 중복 체크\n-      const existingProgram = await this.getProgramByName(programData.name);\n-      if (existingProgram) {\n-        throw new Error('이미 존재하는 프로그램명입니다.');\n-      }\n-\n-      const newProgram: Program = {\n+      const newDocument: TermsDocument = {\n+        ...documentData,\n         id: this.generateUUID(),\n-        ...programData,\n+        version: maxVersion + 1,\n         createdAt: new Date(),\n-        updatedAt: new Date()\n+        updatedAt: new Date(),\n+        publishedAt: documentData.isActive ? new Date() : null\n       };\n \n-      await this.executeTransaction('programs', 'readwrite', (store) => \n-        store.add(newProgram)\n+      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n+        store.add(newDocument)\n       );\n \n-      console.log('프로그램 추가 성공:', newProgram);\n-      return newProgram;\n+      console.log('약관/문서 추가 성공:', newDocument);\n+      return newDocument;\n     } catch (error) {\n-      console.error('프로그램 추가 실패:', error);\n+      console.error('약관/문서 추가 실패:', error);\n       throw error;\n     }\n   }\n \n   /**\n-   * 모든 프로그램 조회\n+   * 모든 약관/문서 조회\n    */\n-  async getAllPrograms(): Promise<Program[]> {\n+  async getAllTermsDocuments(): Promise<TermsDocument[]> {\n     try {\n-      const programs = await this.executeTransaction('programs', 'readonly', (store) => \n+      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n         store.getAll()\n       );\n       \n-      return programs.map(program => ({\n-        ...program,\n-        createdAt: new Date(program.createdAt),\n-        updatedAt: new Date(program.updatedAt)\n+      return documents.map(doc => ({\n+        ...doc,\n+        createdAt: new Date(doc.createdAt),\n+        updatedAt: new Date(doc.updatedAt),\n+        publishedAt: doc.publishedAt ? new Date(doc.publishedAt) : null\n       }));\n     } catch (error) {\n-      console.error('프로그램 목록 조회 실패:', error);\n-      throw error;\n+      console.error('약관/문서 목록 조회 실패:', error);\n+      return [];\n     }\n   }\n \n   /**\n-   * 프로그램명으로 조회\n+   * ID로 약관/문서 조회\n    */\n-  async getProgramByName(name: string): Promise<Program | null> {\n+  async getTermsDocumentById(id: string): Promise<TermsDocument | null> {\n     try {\n-      const program = await this.executeTransaction('programs', 'readonly', (store) => \n-        store.index('name').get(name)\n-      );\n-      \n-      if (program) {\n-        return {\n-          ...program,\n-          createdAt: new Date(program.createdAt),\n-          updatedAt: new Date(program.updatedAt)\n-        };\n-      }\n-      \n-      return null;\n-    } catch (error) {\n-      console.error('프로그램 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 프로그램 수정\n-   */\n-  async updateProgram(id: string, updates: Partial<Omit<Program, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Program | null> {\n-    try {\n-      const existingProgram = await this.executeTransaction('programs', 'readonly', (store) => \n+      const document = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n         store.get(id)\n       );\n-\n-      if (!existingProgram) {\n-        console.error('수정할 프로그램을 찾을 수 없습니다:', id);\n-        return null;\n-      }\n-\n-      // 프로그램명 변경 시 중복 체크\n-      if (updates.name && updates.name !== existingProgram.name) {\n-        const duplicateProgram = await this.getProgramByName(updates.name);\n-        if (duplicateProgram) {\n-          throw new Error('이미 존재하는 프로그램명입니다.');\n-        }\n-      }\n-\n-      const updatedProgram: Program = {\n-        ...existingProgram,\n-        ...updates,\n-        id,\n-        createdAt: new Date(existingProgram.createdAt),\n-        updatedAt: new Date()\n-      };\n-\n-      await this.executeTransaction('programs', 'readwrite', (store) => \n-        store.put(updatedProgram)\n-      );\n-\n-      console.log('프로그램 수정 성공:', updatedProgram);\n-      return updatedProgram;\n-    } catch (error) {\n-      console.error('프로그램 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 프로그램 삭제\n-   */\n-  async deleteProgram(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('programs', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-\n-      console.log('프로그램 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('프로그램 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  // =================== 상품 관리 메서드 ===================\n-\n-  /**\n-   * 상품 추가\n-   */\n-  async addProduct(productData: Omit<Product, 'id' | 'createdAt' | 'updatedAt'>): Promise<Product> {\n-    try {\n-      const newProduct: Product = {\n-        id: this.generateUUID(),\n-        ...productData,\n-        createdAt: new Date(),\n-        updatedAt: new Date()\n-      };\n-\n-      await this.executeTransaction('products', 'readwrite', (store) => \n-        store.add(newProduct)\n-      );\n-\n-      console.log('상품 추가 성공:', newProduct);\n-      return newProduct;\n-    } catch (error) {\n-      console.error('상품 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 모든 상품 조회\n-   */\n-  async getAllProducts(): Promise<Product[]> {\n-    try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => \n-        store.getAll()\n-      );\n       \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('상품 목록 조회 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * ID로 상품 조회\n-   */\n-  async getProductById(id: string): Promise<Product | null> {\n-    try {\n-      const product = await this.executeTransaction('products', 'readonly', (store) => \n-        store.get(id)\n-      );\n-      \n-      if (product) {\n+      if (document) {\n         return {\n-          ...product,\n-          createdAt: new Date(product.createdAt),\n-          updatedAt: new Date(product.updatedAt)\n+          ...document,\n+          createdAt: new Date(document.createdAt),\n+          updatedAt: new Date(document.updatedAt),\n+          publishedAt: document.publishedAt ? new Date(document.publishedAt) : null\n         };\n       }\n       \n       return null;\n     } catch (error) {\n-      console.error('상품 조회 실패:', error);\n+      console.error('약관/문서 조회 실패:', error);\n       return null;\n     }\n   }\n \n   /**\n-   * 지점별 상품 조회\n+   * 타입별 약관/문서 조회\n    */\n-  async getProductsByBranch(branchId: string): Promise<Product[]> {\n+  async getTermsDocumentsByType(type: TermsDocument['type']): Promise<TermsDocument[]> {\n     try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => {\n-        const index = store.index('branchId');\n-        return index.getAll(IDBKeyRange.only(branchId));\n+      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => {\n+        return store.getAll();\n       });\n       \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n+      const filteredDocs = documents.filter(doc => doc.type === type);\n+      \n+      return filteredDocs.map(doc => ({\n+        ...doc,\n+        createdAt: new Date(doc.createdAt),\n+        updatedAt: new Date(doc.updatedAt),\n+        publishedAt: doc.publishedAt ? new Date(doc.publishedAt) : null\n+      })).sort((a, b) => b.version - a.version); // 최신 버전부터\n     } catch (error) {\n-      console.error('지점별 상품 조회 실패:', error);\n+      console.error('타입별 약관/문서 조회 실패:', error);\n       return [];\n     }\n   }\n \n   /**\n-   * 프로그램별 상품 조회\n+   * 활성화된 약관/문서만 조회 (타입별)\n    */\n-  async getProductsByProgram(programId: string): Promise<Product[]> {\n+  async getActiveTermsDocument(type: TermsDocument['type']): Promise<TermsDocument | null> {\n     try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => {\n-        const index = store.index('programId');\n-        return index.getAll(IDBKeyRange.only(programId));\n+      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => {\n+        return store.getAll();\n       });\n       \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('프로그램별 상품 조회 실패:', error);\n-      return [];\n-    }\n-  }\n+      const activeDoc = documents.find(doc => doc.type === type && doc.isActive);\n+      \n+      if (!activeDoc) return null;\n \n-  /**\n-   * 지점과 프로그램으로 상품 조회\n-   */\n-  async getProductsByBranchAndProgram(branchId: string, programId: string): Promise<Product[]> {\n-    try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => {\n-        const index = store.index('branchProgram');\n-        return index.getAll(IDBKeyRange.only([branchId, programId]));\n-      });\n-      \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n+      return {\n+        ...activeDoc,\n+        createdAt: new Date(activeDoc.createdAt),\n+        updatedAt: new Date(activeDoc.updatedAt),\n+        publishedAt: activeDoc.publishedAt ? new Date(activeDoc.publishedAt) : null\n+      };\n     } catch (error) {\n-      console.error('지점-프로그램별 상품 조회 실패:', error);\n-      return [];\n+      console.error('활성 약관/문서 조회 실패:', error);\n+      return null;\n     }\n   }\n \n   /**\n-   * 상품 수정\n+   * 약관/문서 수정\n    */\n-  async updateProduct(id: string, updates: Partial<Omit<Product, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Product | null> {\n+  async updateTermsDocument(id: string, updates: Partial<Omit<TermsDocument, 'id' | 'createdAt' | 'updatedAt' | 'version'>>): Promise<TermsDocument | null> {\n     try {\n-      const existingProduct = await this.executeTransaction('products', 'readonly', (store) => \n+      const existingDocument = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n         store.get(id)\n       );\n \n-      if (!existingProduct) {\n-        console.error('수정할 상품을 찾을 수 없습니다:', id);\n+      if (!existingDocument) {\n+        console.error('수정할 약관/문서를 찾을 수 없습니다:', id);\n         return null;\n       }\n \n-      const updatedProduct: Product = {\n-        ...existingProduct,\n+      // 활성화 시 같은 타입의 다른 문서들 비활성화\n+      if (updates.isActive === true && !existingDocument.isActive) {\n+        const otherDocs = await this.getTermsDocumentsByType(existingDocument.type);\n+        for (const doc of otherDocs.filter((d: TermsDocument) => d.id !== id && d.isActive)) {\n+          await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n+            store.put({\n+              ...doc,\n+              isActive: false,\n+              updatedAt: new Date()\n+            })\n+          );\n+        }\n+      }\n+\n+      const updatedDocument: TermsDocument = {\n+        ...existingDocument,\n         ...updates,\n         id,\n-        createdAt: new Date(existingProduct.createdAt),\n-        updatedAt: new Date()\n+        createdAt: new Date(existingDocument.createdAt),\n+        updatedAt: new Date(),\n+        publishedAt: updates.isActive === true && !existingDocument.isActive ? new Date() : \n+                    updates.isActive === false ? null : \n+                    existingDocument.publishedAt\n       };\n \n-      await this.executeTransaction('products', 'readwrite', (store) => \n-        store.put(updatedProduct)\n+      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n+        store.put(updatedDocument)\n       );\n \n-      console.log('상품 수정 성공:', updatedProduct);\n-      return updatedProduct;\n+      console.log('약관/문서 수정 성공:', updatedDocument);\n+      return updatedDocument;\n     } catch (error) {\n-      console.error('상품 수정 실패:', error);\n+      console.error('약관/문서 수정 실패:', error);\n       throw error;\n     }\n   }\n \n   /**\n-   * 상품 삭제\n+   * 약관/문서 삭제\n    */\n-  async deleteProduct(id: string): Promise<boolean> {\n+  async deleteTermsDocument(id: string): Promise<boolean> {\n     try {\n-      await this.executeTransaction('products', 'readwrite', (store) => \n+      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n         store.delete(id)\n       );\n \n-      console.log('상품 삭제 성공:', id);\n+      console.log('약관/문서 삭제 성공:', id);\n       return true;\n     } catch (error) {\n-      console.error('상품 삭제 실패:', error);\n+      console.error('약관/문서 삭제 실패:', error);\n       throw error;\n     }\n   }\n \n   /**\n-   * 활성 상품만 조회\n+   * 약관/문서 검색 (제목, 내용)\n    */\n-  async getActiveProducts(): Promise<Product[]> {\n+  async searchTermsDocuments(searchTerm: string): Promise<TermsDocument[]> {\n     try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => {\n-        const index = store.index('isActive');\n-        return index.getAll(IDBKeyRange.only(true));\n-      });\n+      const allDocuments = await this.getAllTermsDocuments();\n+      const lowerSearchTerm = searchTerm.toLowerCase();\n       \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('활성 상품 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 상품명으로 검색\n-   */\n-  async searchProductsByName(name: string): Promise<Product[]> {\n-    try {\n-      const allProducts = await this.getAllProducts();\n-      return allProducts.filter(product => \n-        product.name.toLowerCase().includes(name.toLowerCase())\n+      return allDocuments.filter(doc => \n+        doc.title.toLowerCase().includes(lowerSearchTerm) ||\n+        doc.content.toLowerCase().includes(lowerSearchTerm)\n       );\n     } catch (error) {\n-      console.error('상품 검색 실패:', error);\n+      console.error('약관/문서 검색 실패:', error);\n       return [];\n     }\n   }\n }\n"
                },
                {
                    "date": 1760253496922,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1997 @@\n+/**\n+ * IndexedDB를 활용한 로컬 데이터베이스 관리 유틸리티\n+ * 백엔드 연결 전까지 브라우저에서 데이터를 영구 저장\n+ */\n+\n+import { SYSTEM_ADMIN_CONFIG } from '../constants/staffConstants';\n+\n+export interface DBRecord {\n+  id: string;\n+  createdAt: Date;\n+  updatedAt: Date;\n+}\n+\n+export interface Branch extends DBRecord {\n+  name: string;\n+  address?: string;\n+  phone?: string;\n+  isActive: boolean;\n+}\n+\n+export interface AppSettings extends DBRecord {\n+  key: string;\n+  value: string;\n+}\n+\n+export interface Staff extends DBRecord {\n+  name: string;\n+  loginId: string; // 로그인 ID\n+  password: string; // 비밀번호\n+  phone: string;\n+  email: string;\n+  branchId: string;\n+  position: string; // 직급\n+  role: string; // 직책\n+  employmentType: string; // 고용형태\n+  permission: string; // 권한\n+  program?: string; // 담당프로그램 (코치일 경우만)\n+  contractStartDate: Date;\n+  contractEndDate?: Date | null; // 계약종료일 (정규직은 없을 수 있음)\n+  contractFile?: File | null; // 계약서 파일\n+  contractFileName?: string; // 계약서 파일명 저장용\n+  contractFileData?: ArrayBuffer; // 계약서 파일 데이터 저장용\n+  workingHours?: {\n+    start: number; // 기본 근무 시작 시간 (시)\n+    end: number; // 기본 근무 종료 시간 (시)\n+  };\n+  isActive: boolean; // 활성/비활성 상태\n+}\n+\n+export interface Program extends DBRecord {\n+  name: string;\n+  type: string; // '횟수제' | '기간제'\n+  isActive: boolean;\n+}\n+\n+export interface Product extends DBRecord {\n+  name: string;\n+  branchId: string;\n+  programId: string;\n+  programName: string; // 프로그램명 저장 (조회 성능 향상)\n+  programType: string; // 프로그램 종류 저장 (조회 성능 향상)\n+  sessions?: number; // 횟수 (횟수제인 경우에만 필요)\n+  duration?: number; // 소요시간 (분 단위, 횟수제인 경우에만 필요)\n+  price?: number; // 가격\n+  description?: string; // 상품소개\n+  isActive: boolean;\n+}\n+\n+export interface HolidaySettings extends DBRecord {\n+  staffId: string;\n+  date: string; // YYYY-MM-DD 형식\n+  isHoliday: boolean; // true: 휴일, false: 근무일\n+  workingHours?: {\n+    start: number;\n+    end: number;\n+  }; // 해당 날짜의 근무시간 (휴일이 아닌 경우)\n+}\n+\n+export interface TermsDocument extends DBRecord {\n+  type: 'privacy_policy' | 'terms_of_service' | 'business_info' | 'marketing_consent' | 'member_terms' | 'contract';\n+  title: string;\n+  content: string;\n+  version: number; // 버전 관리\n+  isActive: boolean;\n+  publishedAt?: Date | null; // 발행일\n+}\n+\n+export interface Member extends DBRecord {\n+  name: string;\n+  phone: string;\n+  email: string;\n+  birth: string;\n+  gender: 'male' | 'female' | '';\n+  address: string;\n+  sigunguCode: string;\n+  dong: string;\n+  roadAddress: string;\n+  jibunAddress: string;\n+  branchId: string;\n+  branchName: string; // 조회 성능을 위해 저장\n+  coach: string; // 담당 코치 ID\n+  coachName: string; // 조회 성능을 위해 저장\n+  joinPath: string;\n+  loginId: string;\n+  loginPassword: string;\n+  enableLogin: boolean;\n+  agreementInfo: {\n+    agreements: Array<{\n+      id: string;\n+      title: string;\n+      content: string;\n+      required: boolean;\n+      agreed: boolean;\n+    }>;\n+    customerSignature: string;\n+    staffSignature: string;\n+  };\n+  isActive: boolean;\n+}\n+\n+export interface Payment extends DBRecord {\n+  memberId: string;\n+  memberName: string; // 조회 성능을 위해 저장\n+  products: Array<{\n+    id: string;\n+    name: string;\n+    price: number;\n+    description?: string;\n+  }>;\n+  totalAmount: number;\n+  paymentStatus: 'pending' | 'completed' | 'cancelled' | 'refunded';\n+  paymentMethod?: string;\n+  paymentDate?: Date | null;\n+  notes?: string;\n+}\n+\n+class IndexedDBManager {\n+  private dbName: string = 'LavidaDB';\n+  private version: number = 9; // 버전 업데이트 (Member, Payment 테이블 추가)\n+  private db: IDBDatabase | null = null;\n+\n+  constructor() {\n+    this.initDB();\n+  }\n+\n+  /**\n+   * IndexedDB 초기화\n+   */\n+  private async initDB(): Promise<void> {\n+    return new Promise((resolve, reject) => {\n+      const request = indexedDB.open(this.dbName, this.version);\n+\n+      request.onerror = () => {\n+        console.error('IndexedDB 열기 실패:', request.error);\n+        reject(request.error);\n+      };\n+\n+      request.onsuccess = () => {\n+        this.db = request.result;\n+        console.log('IndexedDB 연결 성공');\n+        resolve();\n+      };\n+\n+      request.onupgradeneeded = (event) => {\n+        const db = (event.target as IDBOpenDBRequest).result;\n+\n+        // 지점 테이블 생성\n+        if (!db.objectStoreNames.contains('branches')) {\n+          const branchStore = db.createObjectStore('branches', { keyPath: 'id' });\n+          branchStore.createIndex('name', 'name', { unique: true }); // 지점명 고유 제약\n+          branchStore.createIndex('isActive', 'isActive', { unique: false });\n+          branchStore.createIndex('createdAt', 'createdAt', { unique: false });\n+        } else {\n+          // 기존 테이블이 있으면 인덱스 업데이트\n+          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n+          const branchStore = transaction.objectStore('branches');\n+          \n+          // 기존 name 인덱스 삭제 후 unique로 재생성\n+          if (branchStore.indexNames.contains('name')) {\n+            branchStore.deleteIndex('name');\n+          }\n+          branchStore.createIndex('name', 'name', { unique: true });\n+        }\n+\n+        // 직원 테이블 생성\n+        if (!db.objectStoreNames.contains('staff')) {\n+          const staffStore = db.createObjectStore('staff', { keyPath: 'id' });\n+          staffStore.createIndex('name', 'name', { unique: false });\n+          staffStore.createIndex('loginId', 'loginId', { unique: true });\n+          staffStore.createIndex('email', 'email', { unique: true });\n+          staffStore.createIndex('branchId', 'branchId', { unique: false });\n+          staffStore.createIndex('position', 'position', { unique: false });\n+          staffStore.createIndex('role', 'role', { unique: false });\n+          staffStore.createIndex('employmentType', 'employmentType', { unique: false });\n+          staffStore.createIndex('permission', 'permission', { unique: false });\n+          staffStore.createIndex('isActive', 'isActive', { unique: false });\n+          staffStore.createIndex('createdAt', 'createdAt', { unique: false });\n+        } else {\n+          // 기존 테이블이 있으면 인덱스 업데이트 (isActive 인덱스 추가)\n+          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n+          const staffStore = transaction.objectStore('staff');\n+          \n+          if (!staffStore.indexNames.contains('isActive')) {\n+            staffStore.createIndex('isActive', 'isActive', { unique: false });\n+          }\n+        }\n+\n+        // 프로그램 테이블 생성\n+        if (!db.objectStoreNames.contains('programs')) {\n+          const programStore = db.createObjectStore('programs', { keyPath: 'id' });\n+          programStore.createIndex('name', 'name', { unique: true }); // 프로그램명 고유 제약\n+          programStore.createIndex('type', 'type', { unique: false });\n+          programStore.createIndex('isActive', 'isActive', { unique: false });\n+          programStore.createIndex('createdAt', 'createdAt', { unique: false });\n+        } else {\n+          // 기존 테이블이 있으면 인덱스 업데이트\n+          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n+          const programStore = transaction.objectStore('programs');\n+          \n+          // 기존 name 인덱스 삭제 후 unique로 재생성\n+          if (programStore.indexNames.contains('name')) {\n+            programStore.deleteIndex('name');\n+          }\n+          programStore.createIndex('name', 'name', { unique: true });\n+        }\n+\n+        // 상품 테이블 생성\n+        if (!db.objectStoreNames.contains('products')) {\n+          const productStore = db.createObjectStore('products', { keyPath: 'id' });\n+          productStore.createIndex('name', 'name', { unique: false });\n+          productStore.createIndex('branchId', 'branchId', { unique: false });\n+          productStore.createIndex('programId', 'programId', { unique: false });\n+          productStore.createIndex('programType', 'programType', { unique: false });\n+          productStore.createIndex('isActive', 'isActive', { unique: false });\n+          productStore.createIndex('createdAt', 'createdAt', { unique: false });\n+          // 복합 인덱스: 지점별, 프로그램별 조회 최적화\n+          productStore.createIndex('branchProgram', ['branchId', 'programId'], { unique: false });\n+        }\n+\n+        // 휴일설정 테이블 생성\n+        if (!db.objectStoreNames.contains('holidaySettings')) {\n+          const holidayStore = db.createObjectStore('holidaySettings', { keyPath: 'id' });\n+          holidayStore.createIndex('staffId', 'staffId', { unique: false });\n+          holidayStore.createIndex('date', 'date', { unique: false });\n+          holidayStore.createIndex('isHoliday', 'isHoliday', { unique: false });\n+          // 복합 인덱스: 직원별, 날짜별 조회 최적화\n+          holidayStore.createIndex('staffDate', ['staffId', 'date'], { unique: true });\n+        }\n+\n+        // 약관/문서 테이블 생성\n+        if (!db.objectStoreNames.contains('termsDocuments')) {\n+          const termsStore = db.createObjectStore('termsDocuments', { keyPath: 'id' });\n+          termsStore.createIndex('type', 'type', { unique: false });\n+          termsStore.createIndex('language', 'language', { unique: false });\n+          termsStore.createIndex('title', 'title', { unique: false });\n+          termsStore.createIndex('version', 'version', { unique: false });\n+          termsStore.createIndex('isActive', 'isActive', { unique: false });\n+          termsStore.createIndex('publishedAt', 'publishedAt', { unique: false });\n+          termsStore.createIndex('createdAt', 'createdAt', { unique: false });\n+          // 복합 인덱스: 타입별, 언어별 조회 최적화\n+          termsStore.createIndex('typeLanguage', ['type', 'language'], { unique: false });\n+          // 활성 상태 및 최신 버전 조회 최적화\n+          termsStore.createIndex('typeLanguageActive', ['type', 'language', 'isActive'], { unique: false });\n+        }\n+\n+        // 회원 테이블 생성\n+        if (!db.objectStoreNames.contains('members')) {\n+          const memberStore = db.createObjectStore('members', { keyPath: 'id' });\n+          memberStore.createIndex('name', 'name', { unique: false });\n+          memberStore.createIndex('phone', 'phone', { unique: true }); // 전화번호는 고유\n+          memberStore.createIndex('email', 'email', { unique: false });\n+          memberStore.createIndex('branchId', 'branchId', { unique: false });\n+          memberStore.createIndex('coach', 'coach', { unique: false });\n+          memberStore.createIndex('loginId', 'loginId', { unique: true }); // 로그인 ID는 고유\n+          memberStore.createIndex('isActive', 'isActive', { unique: false });\n+          memberStore.createIndex('createdAt', 'createdAt', { unique: false });\n+          // 복합 인덱스: 지점별 회원 조회 최적화\n+          memberStore.createIndex('branchActive', ['branchId', 'isActive'], { unique: false });\n+        }\n+\n+        // 결제 테이블 생성\n+        if (!db.objectStoreNames.contains('payments')) {\n+          const paymentStore = db.createObjectStore('payments', { keyPath: 'id' });\n+          paymentStore.createIndex('memberId', 'memberId', { unique: false });\n+          paymentStore.createIndex('memberName', 'memberName', { unique: false });\n+          paymentStore.createIndex('paymentStatus', 'paymentStatus', { unique: false });\n+          paymentStore.createIndex('paymentDate', 'paymentDate', { unique: false });\n+          paymentStore.createIndex('totalAmount', 'totalAmount', { unique: false });\n+          paymentStore.createIndex('createdAt', 'createdAt', { unique: false });\n+          // 복합 인덱스: 회원별 결제 조회 최적화\n+          paymentStore.createIndex('memberStatus', ['memberId', 'paymentStatus'], { unique: false });\n+        }\n+\n+        // 향후 다른 테이블들도 여기에 추가 가능\n+        // 예: 회원, 방문기록 등\n+      };\n+    });\n+  }\n+\n+  /**\n+   * 고유 ID 생성 (UUID v4 형식)\n+   */\n+  private generateUUID(): string {\n+    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n+      const r = Math.random() * 16 | 0;\n+      const v = c === 'x' ? r : ((r & 0x3) | 0x8);\n+      return v.toString(16);\n+    });\n+  }\n+\n+  /**\n+   * 트랜잭션 실행 헬퍼\n+   */\n+  private async executeTransaction<T>(\n+    storeName: string,\n+    mode: IDBTransactionMode,\n+    operation: (store: IDBObjectStore) => IDBRequest<T>\n+  ): Promise<T> {\n+    if (!this.db) {\n+      await this.initDB();\n+    }\n+\n+    return new Promise((resolve, reject) => {\n+      const transaction = this.db!.transaction([storeName], mode);\n+      const store = transaction.objectStore(storeName);\n+      const request = operation(store);\n+\n+      request.onsuccess = () => resolve(request.result);\n+      request.onerror = () => reject(request.error);\n+    });\n+  }\n+\n+  // === 지점 관리 메서드들 ===\n+\n+  /**\n+   * 모든 지점 조회\n+   */\n+  async getAllBranches(): Promise<Branch[]> {\n+    try {\n+      return await this.executeTransaction('branches', 'readonly', (store) => \n+        store.getAll()\n+      );\n+    } catch (error) {\n+      console.error('지점 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * ID로 지점 조회\n+   */\n+  async getBranchById(id: string): Promise<Branch | null> {\n+    try {\n+      const result = await this.executeTransaction('branches', 'readonly', (store) => \n+        store.get(id)\n+      );\n+      return result || null;\n+    } catch (error) {\n+      console.error('지점 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 지점 추가\n+   */\n+  async addBranch(branchData: Omit<Branch, 'id' | 'createdAt' | 'updatedAt'>): Promise<Branch> {\n+    const now = new Date();\n+    const newBranch: Branch = {\n+      ...branchData,\n+      id: this.generateUUID(),\n+      createdAt: now,\n+      updatedAt: now,\n+    };\n+\n+    try {\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.add(newBranch)\n+      );\n+      console.log('지점 추가 성공:', newBranch);\n+      return newBranch;\n+    } catch (error) {\n+      console.error('지점 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 지점 수정\n+   */\n+  async updateBranch(id: string, updates: Partial<Omit<Branch, 'id' | 'createdAt'>>): Promise<Branch | null> {\n+    try {\n+      const existing = await this.getBranchById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 지점입니다.');\n+      }\n+\n+      const updatedBranch: Branch = {\n+        ...existing,\n+        ...updates,\n+        updatedAt: new Date(),\n+      };\n+\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.put(updatedBranch)\n+      );\n+\n+      console.log('지점 수정 성공:', updatedBranch);\n+      return updatedBranch;\n+    } catch (error) {\n+      console.error('지점 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 지점 삭제\n+   */\n+  async deleteBranch(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+      console.log('지점 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('지점 삭제 실패:', error);\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * 활성 지점만 조회\n+   */\n+  async getActiveBranches(): Promise<Branch[]> {\n+    try {\n+      return await this.executeTransaction('branches', 'readonly', (store) => {\n+        const index = store.index('isActive');\n+        return index.getAll(IDBKeyRange.only(true));\n+      });\n+    } catch (error) {\n+      console.error('활성 지점 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 지점명으로 정확히 일치하는 지점 조회 또는 생성 (원자적 처리)\n+   * 동시 실행 시 race condition 방지\n+   */\n+  async getOrCreateBranchByName(name: string, branchData?: Omit<Branch, 'id' | 'createdAt' | 'updatedAt' | 'name'>): Promise<Branch> {\n+    if (!this.db) {\n+      await this.initDB();\n+    }\n+\n+    return new Promise((resolve, reject) => {\n+      const transaction = this.db!.transaction(['branches'], 'readwrite');\n+      const store = transaction.objectStore('branches');\n+      const index = store.index('name');\n+      \n+      // 먼저 기존 지점 확인\n+      const getRequest = index.get(name);\n+      \n+      getRequest.onsuccess = () => {\n+        if (getRequest.result) {\n+          // 이미 존재함\n+          resolve(getRequest.result);\n+        } else {\n+          // 존재하지 않음, 새로 생성\n+          const now = new Date();\n+          const newBranch: Branch = {\n+            name,\n+            address: branchData?.address || '',\n+            phone: branchData?.phone || '',\n+            isActive: branchData?.isActive ?? true,\n+            id: this.generateUUID(),\n+            createdAt: now,\n+            updatedAt: now,\n+          };\n+\n+          const addRequest = store.add(newBranch);\n+          addRequest.onsuccess = () => {\n+            console.log('새 지점 생성 완료:', newBranch);\n+            resolve(newBranch);\n+          };\n+          addRequest.onerror = () => {\n+            console.error('지점 추가 실패:', addRequest.error);\n+            reject(addRequest.error);\n+          };\n+        }\n+      };\n+      \n+      getRequest.onerror = () => {\n+        console.error('지점 조회 실패:', getRequest.error);\n+        reject(getRequest.error);\n+      };\n+    });\n+  }\n+\n+  /**\n+   * 지점명으로 정확히 일치하는 지점 조회\n+   */\n+  async getBranchByName(name: string): Promise<Branch | null> {\n+    try {\n+      const allBranches = await this.getAllBranches();\n+      const branch = allBranches.find(branch => branch.name === name);\n+      return branch || null;\n+    } catch (error) {\n+      console.error('지점명으로 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 지점명으로 검색\n+   */\n+  async searchBranchesByName(name: string): Promise<Branch[]> {\n+    try {\n+      const allBranches = await this.getAllBranches();\n+      return allBranches.filter(branch => \n+        branch.name.toLowerCase().includes(name.toLowerCase())\n+      );\n+    } catch (error) {\n+      console.error('지점 검색 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  // === 직원 관리 메서드들 ===\n+\n+  /**\n+   * 모든 직원 조회\n+   */\n+  async getAllStaff(): Promise<Staff[]> {\n+    try {\n+      const staffList = await this.executeTransaction('staff', 'readonly', (store) => \n+        store.getAll()\n+      );\n+\n+      // 저장된 파일 데이터를 File 객체로 복원\n+      return staffList.map(staff => {\n+        if (staff.contractFileData && staff.contractFileName) {\n+          // 파일 확장자로부터 MIME 타입 추정\n+          const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n+          let mimeType = 'application/octet-stream';\n+          \n+          if (extension === 'pdf') {\n+            mimeType = 'application/pdf';\n+          } else if (['jpg', 'jpeg'].includes(extension || '')) {\n+            mimeType = 'image/jpeg';\n+          } else if (extension === 'png') {\n+            mimeType = 'image/png';\n+          }\n+\n+          staff.contractFile = this.arrayBufferToFile(\n+            staff.contractFileData, \n+            staff.contractFileName, \n+            mimeType\n+          );\n+        }\n+        return staff;\n+      });\n+    } catch (error) {\n+      console.error('직원 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * ID로 직원 조회\n+   */\n+  async getStaffById(id: string): Promise<Staff | null> {\n+    try {\n+      const staff = await this.executeTransaction('staff', 'readonly', (store) => \n+        store.get(id)\n+      );\n+\n+      if (!staff) return null;\n+\n+      // 저장된 파일 데이터를 File 객체로 복원\n+      if (staff.contractFileData && staff.contractFileName) {\n+        const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n+        let mimeType = 'application/octet-stream';\n+        \n+        if (extension === 'pdf') {\n+          mimeType = 'application/pdf';\n+        } else if (['jpg', 'jpeg'].includes(extension || '')) {\n+          mimeType = 'image/jpeg';\n+        } else if (extension === 'png') {\n+          mimeType = 'image/png';\n+        }\n+\n+        staff.contractFile = this.arrayBufferToFile(\n+          staff.contractFileData, \n+          staff.contractFileName, \n+          mimeType\n+        );\n+      }\n+\n+      return staff;\n+    } catch (error) {\n+      console.error('직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 직원 추가\n+   */\n+  async addStaff(staffData: Omit<Staff, 'id' | 'createdAt' | 'updatedAt'>): Promise<Staff> {\n+    const now = new Date();\n+    \n+    // 파일 데이터 처리\n+    let contractFileData: ArrayBuffer | undefined;\n+    let contractFileName: string | undefined;\n+    \n+    if (staffData.contractFile) {\n+      contractFileData = await this.fileToArrayBuffer(staffData.contractFile);\n+      contractFileName = staffData.contractFile.name;\n+    }\n+\n+    const newStaff: Staff = {\n+      ...staffData,\n+      id: this.generateUUID(),\n+      createdAt: now,\n+      updatedAt: now,\n+      isActive: staffData.isActive !== undefined ? staffData.isActive : true, // 기본값 true\n+      contractFile: undefined, // File 객체는 저장하지 않음\n+      contractFileName,\n+      contractFileData,\n+    };\n+\n+    try {\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.add(newStaff)\n+      );\n+      console.log('직원 추가 성공:', newStaff);\n+      return newStaff;\n+    } catch (error) {\n+      console.error('직원 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 시스템 관리자 계정인지 확인\n+   */\n+  private isSystemAdmin(staff: Staff): boolean {\n+    return staff.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID;\n+  }\n+\n+  /**\n+   * 시스템 관리자 보호 검증\n+   */\n+  private validateSystemAdminProtection(staff: Staff, operation: 'delete' | 'permission_change'): void {\n+    if (this.isSystemAdmin(staff)) {\n+      const message = operation === 'delete' \n+        ? '시스템 관리자 계정은 삭제할 수 없습니다.'\n+        : '시스템 관리자 계정의 권한은 변경할 수 없습니다.';\n+      throw new Error(message);\n+    }\n+  }\n+\n+  /**\n+   * 직원 수정\n+   */\n+  async updateStaff(id: string, updates: Partial<Omit<Staff, 'id' | 'createdAt'>>): Promise<Staff | null> {\n+    try {\n+      const existing = await this.getStaffById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 직원입니다.');\n+      }\n+\n+      // 시스템 관리자 권한 변경 보호\n+      if (updates.permission && updates.permission !== existing.permission) {\n+        this.validateSystemAdminProtection(existing, 'permission_change');\n+      }\n+\n+      // 파일 데이터 처리\n+      let contractFileData = existing.contractFileData;\n+      let contractFileName = existing.contractFileName;\n+      \n+      if (updates.contractFile) {\n+        contractFileData = await this.fileToArrayBuffer(updates.contractFile);\n+        contractFileName = updates.contractFile.name;\n+      }\n+\n+      const updatedStaff: Staff = {\n+        ...existing,\n+        ...updates,\n+        updatedAt: new Date(),\n+        contractFile: undefined, // File 객체는 저장하지 않음\n+        contractFileName,\n+        contractFileData,\n+      };\n+\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.put(updatedStaff)\n+      );\n+\n+      console.log('직원 수정 성공:', updatedStaff);\n+      return updatedStaff;\n+    } catch (error) {\n+      console.error('직원 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 직원 삭제\n+   */\n+  async deleteStaff(id: string): Promise<boolean> {\n+    try {\n+      const existing = await this.getStaffById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 직원입니다.');\n+      }\n+\n+      // 시스템 관리자 삭제 보호\n+      this.validateSystemAdminProtection(existing, 'delete');\n+\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+      console.log('직원 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('직원 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 직원 활성/비활성 상태 토글\n+   */\n+  async toggleStaffStatus(id: string): Promise<Staff | null> {\n+    try {\n+      const existing = await this.getStaffById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 직원입니다.');\n+      }\n+\n+      // 시스템 관리자 상태 변경 보호\n+      if (existing.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID) {\n+        throw new Error('시스템 관리자 계정의 상태는 변경할 수 없습니다.');\n+      }\n+\n+      const updatedStaff = {\n+        ...existing,\n+        isActive: !existing.isActive,\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.put(updatedStaff)\n+      );\n+\n+      console.log('직원 상태 변경 성공:', id, `-> ${updatedStaff.isActive ? '활성' : '비활성'}`);\n+      return updatedStaff;\n+    } catch (error) {\n+      console.error('직원 상태 변경 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 지점별 직원 조회\n+   */\n+  async getStaffByBranch(branchId: string): Promise<Staff[]> {\n+    try {\n+      return await this.executeTransaction('staff', 'readonly', (store) => {\n+        const index = store.index('branchId');\n+        return index.getAll(IDBKeyRange.only(branchId));\n+      });\n+    } catch (error) {\n+      console.error('지점별 직원 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 이메일로 직원 조회\n+   */\n+  async getStaffByEmail(email: string): Promise<Staff | null> {\n+    try {\n+      const result = await this.executeTransaction('staff', 'readonly', (store) => {\n+        const index = store.index('email');\n+        return index.get(email);\n+      });\n+      return result || null;\n+    } catch (error) {\n+      console.error('이메일로 직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 로그인ID로 직원 조회\n+   */\n+  async getStaffByLoginId(loginId: string): Promise<Staff | null> {\n+    try {\n+      const staff = await this.executeTransaction('staff', 'readonly', (store) => {\n+        const index = store.index('loginId');\n+        return index.get(loginId);\n+      });\n+\n+      if (!staff) return null;\n+\n+      // 저장된 파일 데이터를 File 객체로 복원\n+      if (staff.contractFileData && staff.contractFileName) {\n+        const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n+        let mimeType = 'application/octet-stream';\n+        \n+        if (extension === 'pdf') {\n+          mimeType = 'application/pdf';\n+        } else if (['jpg', 'jpeg'].includes(extension || '')) {\n+          mimeType = 'image/jpeg';\n+        } else if (extension === 'png') {\n+          mimeType = 'image/png';\n+        }\n+\n+        staff.contractFile = this.arrayBufferToFile(\n+          staff.contractFileData, \n+          staff.contractFileName, \n+          mimeType\n+        );\n+      }\n+\n+      return staff;\n+    } catch (error) {\n+      console.error('로그인ID로 직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 전화번호로 직원 조회\n+   */\n+  async getStaffByPhone(phone: string): Promise<Staff | null> {\n+    try {\n+      const allStaff = await this.getAllStaff();\n+      const found = allStaff.find(staff => staff.phone === phone);\n+      return found || null;\n+    } catch (error) {\n+      console.error('전화번호로 직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 중복 체크 함수 (등록 시 사용)\n+   */\n+  async checkDuplicateStaff(loginId: string, email: string, phone: string): Promise<{\n+    isDuplicate: boolean;\n+    duplicateField?: 'loginId' | 'email' | 'phone';\n+    message?: string;\n+  }> {\n+    try {\n+      // 로그인 ID 중복 체크\n+      const existingByLoginId = await this.getStaffByLoginId(loginId);\n+      if (existingByLoginId) {\n+        return {\n+          isDuplicate: true,\n+          duplicateField: 'loginId',\n+          message: '이미 사용 중인 로그인 ID입니다.'\n+        };\n+      }\n+\n+      // 이메일 중복 체크\n+      const existingByEmail = await this.getStaffByEmail(email);\n+      if (existingByEmail) {\n+        return {\n+          isDuplicate: true,\n+          duplicateField: 'email',\n+          message: '이미 사용 중인 이메일입니다.'\n+        };\n+      }\n+\n+      // 전화번호 중복 체크\n+      const existingByPhone = await this.getStaffByPhone(phone);\n+      if (existingByPhone) {\n+        return {\n+          isDuplicate: true,\n+          duplicateField: 'phone',\n+          message: '이미 사용 중인 전화번호입니다.'\n+        };\n+      }\n+\n+      return { isDuplicate: false };\n+    } catch (error) {\n+      console.error('중복 체크 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 파일을 ArrayBuffer로 변환\n+   */\n+  private fileToArrayBuffer(file: File): Promise<ArrayBuffer> {\n+    return new Promise((resolve, reject) => {\n+      const reader = new FileReader();\n+      reader.onload = () => resolve(reader.result as ArrayBuffer);\n+      reader.onerror = () => reject(reader.error);\n+      reader.readAsArrayBuffer(file);\n+    });\n+  }\n+\n+  /**\n+   * ArrayBuffer를 Blob으로 변환 (파일 다운로드용)\n+   */\n+  arrayBufferToBlob(buffer: ArrayBuffer, mimeType: string): Blob {\n+    return new Blob([buffer], { type: mimeType });\n+  }\n+\n+  /**\n+   * ArrayBuffer를 File 객체로 변환\n+   */\n+  private arrayBufferToFile(buffer: ArrayBuffer, fileName: string, mimeType: string = 'application/octet-stream'): File {\n+    const blob = new Blob([buffer], { type: mimeType });\n+    return new File([blob], fileName, { type: mimeType });\n+  }\n+\n+  /**\n+   * 데이터베이스 초기화 (개발/테스트용)\n+   */\n+  async clearAllData(): Promise<void> {\n+    try {\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      console.log('모든 데이터 삭제 완료');\n+    } catch (error) {\n+      console.error('데이터 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 기존 직원 데이터의 isActive 필드 초기화 (마이그레이션용)\n+   */\n+  async migrateStaffActiveStatus(): Promise<void> {\n+    try {\n+      const allStaff = await this.executeTransaction('staff', 'readonly', (store) => \n+        store.getAll()\n+      );\n+\n+      // isActive 필드가 없는 직원들을 찾아서 업데이트\n+      const staffToUpdate = allStaff.filter(staff => staff.isActive === undefined);\n+      \n+      if (staffToUpdate.length > 0) {\n+        console.log(`${staffToUpdate.length}명의 직원 isActive 필드를 초기화합니다.`);\n+        \n+        for (const staff of staffToUpdate) {\n+          const updatedStaff = {\n+            ...staff,\n+            isActive: true, // 기본값을 true로 설정\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('staff', 'readwrite', (store) => \n+            store.put(updatedStaff)\n+          );\n+        }\n+        \n+        console.log('직원 isActive 필드 초기화 완료');\n+      }\n+    } catch (error) {\n+      console.error('직원 isActive 필드 초기화 실패:', error);\n+    }\n+  }\n+\n+  // =================== 프로그램 관리 메서드 ===================\n+\n+  /**\n+   * 프로그램 추가\n+   */\n+  async addProgram(programData: Omit<Program, 'id' | 'createdAt' | 'updatedAt'>): Promise<Program> {\n+    try {\n+      // 프로그램명 중복 체크\n+      const existingProgram = await this.getProgramByName(programData.name);\n+      if (existingProgram) {\n+        throw new Error('이미 존재하는 프로그램명입니다.');\n+      }\n+\n+      const newProgram: Program = {\n+        id: this.generateUUID(),\n+        ...programData,\n+        createdAt: new Date(),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.add(newProgram)\n+      );\n+\n+      console.log('프로그램 추가 성공:', newProgram);\n+      return newProgram;\n+    } catch (error) {\n+      console.error('프로그램 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 프로그램 조회\n+   */\n+  async getAllPrograms(): Promise<Program[]> {\n+    try {\n+      const programs = await this.executeTransaction('programs', 'readonly', (store) => \n+        store.getAll()\n+      );\n+      \n+      return programs.map(program => ({\n+        ...program,\n+        createdAt: new Date(program.createdAt),\n+        updatedAt: new Date(program.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('프로그램 목록 조회 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 프로그램명으로 조회\n+   */\n+  async getProgramByName(name: string): Promise<Program | null> {\n+    try {\n+      const program = await this.executeTransaction('programs', 'readonly', (store) => \n+        store.index('name').get(name)\n+      );\n+      \n+      if (program) {\n+        return {\n+          ...program,\n+          createdAt: new Date(program.createdAt),\n+          updatedAt: new Date(program.updatedAt)\n+        };\n+      }\n+      \n+      return null;\n+    } catch (error) {\n+      console.error('프로그램 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 프로그램 수정\n+   */\n+  async updateProgram(id: string, updates: Partial<Omit<Program, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Program | null> {\n+    try {\n+      const existingProgram = await this.executeTransaction('programs', 'readonly', (store) => \n+        store.get(id)\n+      );\n+\n+      if (!existingProgram) {\n+        console.error('수정할 프로그램을 찾을 수 없습니다:', id);\n+        return null;\n+      }\n+\n+      // 프로그램명 변경 시 중복 체크\n+      if (updates.name && updates.name !== existingProgram.name) {\n+        const duplicateProgram = await this.getProgramByName(updates.name);\n+        if (duplicateProgram) {\n+          throw new Error('이미 존재하는 프로그램명입니다.');\n+        }\n+      }\n+\n+      const updatedProgram: Program = {\n+        ...existingProgram,\n+        ...updates,\n+        id,\n+        createdAt: new Date(existingProgram.createdAt),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.put(updatedProgram)\n+      );\n+\n+      console.log('프로그램 수정 성공:', updatedProgram);\n+      return updatedProgram;\n+    } catch (error) {\n+      console.error('프로그램 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 프로그램 삭제\n+   */\n+  async deleteProgram(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('프로그램 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('프로그램 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  // =================== 상품 관리 메서드 ===================\n+\n+  /**\n+   * 상품 추가\n+   */\n+  async addProduct(productData: Omit<Product, 'id' | 'createdAt' | 'updatedAt'>): Promise<Product> {\n+    try {\n+      const newProduct: Product = {\n+        id: this.generateUUID(),\n+        ...productData,\n+        createdAt: new Date(),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.add(newProduct)\n+      );\n+\n+      console.log('상품 추가 성공:', newProduct);\n+      return newProduct;\n+    } catch (error) {\n+      console.error('상품 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 상품 조회\n+   */\n+  async getAllProducts(): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => \n+        store.getAll()\n+      );\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('상품 목록 조회 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * ID로 상품 조회\n+   */\n+  async getProductById(id: string): Promise<Product | null> {\n+    try {\n+      const product = await this.executeTransaction('products', 'readonly', (store) => \n+        store.get(id)\n+      );\n+      \n+      if (product) {\n+        return {\n+          ...product,\n+          createdAt: new Date(product.createdAt),\n+          updatedAt: new Date(product.updatedAt)\n+        };\n+      }\n+      \n+      return null;\n+    } catch (error) {\n+      console.error('상품 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 지점별 상품 조회\n+   */\n+  async getProductsByBranch(branchId: string): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('branchId');\n+        return index.getAll(IDBKeyRange.only(branchId));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('지점별 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 프로그램별 상품 조회\n+   */\n+  async getProductsByProgram(programId: string): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('programId');\n+        return index.getAll(IDBKeyRange.only(programId));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('프로그램별 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 지점과 프로그램으로 상품 조회\n+   */\n+  async getProductsByBranchAndProgram(branchId: string, programId: string): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('branchProgram');\n+        return index.getAll(IDBKeyRange.only([branchId, programId]));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('지점-프로그램별 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 상품 수정\n+   */\n+  async updateProduct(id: string, updates: Partial<Omit<Product, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Product | null> {\n+    try {\n+      const existingProduct = await this.executeTransaction('products', 'readonly', (store) => \n+        store.get(id)\n+      );\n+\n+      if (!existingProduct) {\n+        console.error('수정할 상품을 찾을 수 없습니다:', id);\n+        return null;\n+      }\n+\n+      const updatedProduct: Product = {\n+        ...existingProduct,\n+        ...updates,\n+        id,\n+        createdAt: new Date(existingProduct.createdAt),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.put(updatedProduct)\n+      );\n+\n+      console.log('상품 수정 성공:', updatedProduct);\n+      return updatedProduct;\n+    } catch (error) {\n+      console.error('상품 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 상품 삭제\n+   */\n+  async deleteProduct(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('상품 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('상품 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 활성 상품만 조회\n+   */\n+  async getActiveProducts(): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('isActive');\n+        return index.getAll(IDBKeyRange.only(true));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('활성 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 상품명으로 검색\n+   */\n+  async searchProductsByName(name: string): Promise<Product[]> {\n+    try {\n+      const allProducts = await this.getAllProducts();\n+      return allProducts.filter(product => \n+        product.name.toLowerCase().includes(name.toLowerCase())\n+      );\n+    } catch (error) {\n+      console.error('상품 검색 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  // ==================== 휴일설정 관련 메서드 ====================\n+\n+  /**\n+   * 휴일설정 추가/업데이트\n+   */\n+  async saveHolidaySettings(settingsArray: Omit<HolidaySettings, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<HolidaySettings[]> {\n+    try {\n+      const savedSettings: HolidaySettings[] = [];\n+      \n+      for (const setting of settingsArray) {\n+        // 기존 설정이 있는지 확인\n+        const existingSettings = await this.getHolidaySettingsByStaffAndDate(setting.staffId, setting.date);\n+        \n+        let savedSetting: HolidaySettings;\n+        \n+        if (existingSettings.length > 0) {\n+          // 업데이트\n+          const existing = existingSettings[0];\n+          savedSetting = {\n+            ...existing,\n+            ...setting,\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n+            store.put(savedSetting)\n+          );\n+        } else {\n+          // 새로 추가\n+          savedSetting = {\n+            ...setting,\n+            id: this.generateUUID(),\n+            createdAt: new Date(),\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n+            store.add(savedSetting)\n+          );\n+        }\n+        \n+        savedSettings.push(savedSetting);\n+      }\n+\n+      console.log('휴일설정 저장 성공:', savedSettings.length);\n+      return savedSettings;\n+    } catch (error) {\n+      console.error('휴일설정 저장 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 모든 휴일설정 조회\n+   */\n+  async getHolidaySettingsByStaff(staffId: string): Promise<HolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n+        const index = store.index('staffId');\n+        return index.getAll(IDBKeyRange.only(staffId));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('직원별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 특정 날짜 휴일설정 조회\n+   */\n+  async getHolidaySettingsByStaffAndDate(staffId: string, date: string): Promise<HolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n+        const index = store.index('staffDate');\n+        return index.getAll(IDBKeyRange.only([staffId, date]));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('직원별 날짜별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 특정 날짜의 모든 휴일설정 조회\n+   */\n+  async getHolidaySettingsByDate(date: string): Promise<HolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n+        const index = store.index('date');\n+        return index.getAll(IDBKeyRange.only(date));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('날짜별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 날짜 범위의 휴일설정 조회\n+   */\n+  async getHolidaySettingsByDateRange(startDate: string, endDate: string): Promise<HolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n+        const index = store.index('date');\n+        return index.getAll(IDBKeyRange.bound(startDate, endDate));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('날짜 범위별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 휴일설정 삭제\n+   */\n+  async deleteHolidaySettings(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('휴일설정 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('휴일설정 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 모든 휴일설정 삭제\n+   */\n+  async deleteHolidaySettingsByStaff(staffId: string): Promise<boolean> {\n+    try {\n+      const settings = await this.getHolidaySettingsByStaff(staffId);\n+      \n+      for (const setting of settings) {\n+        await this.deleteHolidaySettings(setting.id);\n+      }\n+\n+      console.log('직원 휴일설정 전체 삭제 성공:', staffId);\n+      return true;\n+    } catch (error) {\n+      console.error('직원 휴일설정 전체 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  // ==================== 약관/문서 관련 메서드 ====================\n+\n+  /**\n+   * 약관/문서 추가\n+   */\n+  async addTermsDocument(documentData: Omit<TermsDocument, 'id' | 'createdAt' | 'updatedAt' | 'version'>): Promise<TermsDocument> {\n+    try {\n+      // 같은 타입의 기존 문서들의 최대 버전 찾기\n+      const existingDocs = await this.getTermsDocumentsByType(documentData.type);\n+      const maxVersion = existingDocs.length > 0 ? Math.max(...existingDocs.map(doc => doc.version)) : 0;\n+\n+      // 기존 활성 문서들 비활성화\n+      for (const doc of existingDocs.filter(d => d.isActive)) {\n+        await this.updateTermsDocument(doc.id, { isActive: false });\n+      }\n+\n+      const newDocument: TermsDocument = {\n+        ...documentData,\n+        id: this.generateUUID(),\n+        version: maxVersion + 1,\n+        createdAt: new Date(),\n+        updatedAt: new Date(),\n+        publishedAt: documentData.isActive ? new Date() : null\n+      };\n+\n+      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n+        store.add(newDocument)\n+      );\n+\n+      console.log('약관/문서 추가 성공:', newDocument);\n+      return newDocument;\n+    } catch (error) {\n+      console.error('약관/문서 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 약관/문서 조회\n+   */\n+  async getAllTermsDocuments(): Promise<TermsDocument[]> {\n+    try {\n+      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n+        store.getAll()\n+      );\n+      \n+      return documents.map(doc => ({\n+        ...doc,\n+        createdAt: new Date(doc.createdAt),\n+        updatedAt: new Date(doc.updatedAt),\n+        publishedAt: doc.publishedAt ? new Date(doc.publishedAt) : null\n+      }));\n+    } catch (error) {\n+      console.error('약관/문서 목록 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * ID로 약관/문서 조회\n+   */\n+  async getTermsDocumentById(id: string): Promise<TermsDocument | null> {\n+    try {\n+      const document = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n+        store.get(id)\n+      );\n+      \n+      if (document) {\n+        return {\n+          ...document,\n+          createdAt: new Date(document.createdAt),\n+          updatedAt: new Date(document.updatedAt),\n+          publishedAt: document.publishedAt ? new Date(document.publishedAt) : null\n+        };\n+      }\n+      \n+      return null;\n+    } catch (error) {\n+      console.error('약관/문서 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 타입별 약관/문서 조회\n+   */\n+  async getTermsDocumentsByType(type: TermsDocument['type']): Promise<TermsDocument[]> {\n+    try {\n+      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => {\n+        return store.getAll();\n+      });\n+      \n+      const filteredDocs = documents.filter(doc => doc.type === type);\n+      \n+      return filteredDocs.map(doc => ({\n+        ...doc,\n+        createdAt: new Date(doc.createdAt),\n+        updatedAt: new Date(doc.updatedAt),\n+        publishedAt: doc.publishedAt ? new Date(doc.publishedAt) : null\n+      })).sort((a, b) => b.version - a.version); // 최신 버전부터\n+    } catch (error) {\n+      console.error('타입별 약관/문서 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 활성화된 약관/문서만 조회 (타입별)\n+   */\n+  async getActiveTermsDocument(type: TermsDocument['type']): Promise<TermsDocument | null> {\n+    try {\n+      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => {\n+        return store.getAll();\n+      });\n+      \n+      const activeDoc = documents.find(doc => doc.type === type && doc.isActive);\n+      \n+      if (!activeDoc) return null;\n+\n+      return {\n+        ...activeDoc,\n+        createdAt: new Date(activeDoc.createdAt),\n+        updatedAt: new Date(activeDoc.updatedAt),\n+        publishedAt: activeDoc.publishedAt ? new Date(activeDoc.publishedAt) : null\n+      };\n+    } catch (error) {\n+      console.error('활성 약관/문서 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 약관/문서 수정\n+   */\n+  async updateTermsDocument(id: string, updates: Partial<Omit<TermsDocument, 'id' | 'createdAt' | 'updatedAt' | 'version'>>): Promise<TermsDocument | null> {\n+    try {\n+      const existingDocument = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n+        store.get(id)\n+      );\n+\n+      if (!existingDocument) {\n+        console.error('수정할 약관/문서를 찾을 수 없습니다:', id);\n+        return null;\n+      }\n+\n+      // 활성화 시 같은 타입의 다른 문서들 비활성화\n+      if (updates.isActive === true && !existingDocument.isActive) {\n+        const otherDocs = await this.getTermsDocumentsByType(existingDocument.type);\n+        for (const doc of otherDocs.filter((d: TermsDocument) => d.id !== id && d.isActive)) {\n+          await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n+            store.put({\n+              ...doc,\n+              isActive: false,\n+              updatedAt: new Date()\n+            })\n+          );\n+        }\n+      }\n+\n+      const updatedDocument: TermsDocument = {\n+        ...existingDocument,\n+        ...updates,\n+        id,\n+        createdAt: new Date(existingDocument.createdAt),\n+        updatedAt: new Date(),\n+        publishedAt: updates.isActive === true && !existingDocument.isActive ? new Date() : \n+                    updates.isActive === false ? null : \n+                    existingDocument.publishedAt\n+      };\n+\n+      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n+        store.put(updatedDocument)\n+      );\n+\n+      console.log('약관/문서 수정 성공:', updatedDocument);\n+      return updatedDocument;\n+    } catch (error) {\n+      console.error('약관/문서 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 약관/문서 삭제\n+   */\n+  async deleteTermsDocument(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('약관/문서 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('약관/문서 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 약관/문서 검색 (제목, 내용)\n+   */\n+  async searchTermsDocuments(searchTerm: string): Promise<TermsDocument[]> {\n+    try {\n+      const allDocuments = await this.getAllTermsDocuments();\n+      const lowerSearchTerm = searchTerm.toLowerCase();\n+      \n+      return allDocuments.filter(doc => \n+        doc.title.toLowerCase().includes(lowerSearchTerm) ||\n+        doc.content.toLowerCase().includes(lowerSearchTerm)\n+      );\n+    } catch (error) {\n+      console.error('약관/문서 검색 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  // ==================== 회원 관리 ====================\n+\n+  /**\n+   * 회원 추가\n+   */\n+  async addMember(memberData: Omit<Member, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n+    try {\n+      const member: Member = {\n+        id: this.generateUUID(),\n+        ...memberData,\n+        createdAt: new Date(),\n+        updatedAt: new Date(),\n+      };\n+\n+      await this.executeTransaction('members', 'readwrite', (store) => \n+        store.add(member)\n+      );\n+\n+      console.log('회원 추가 성공:', member.id);\n+      return member.id;\n+    } catch (error) {\n+      console.error('회원 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 회원 조회\n+   */\n+  async getAllMembers(): Promise<Member[]> {\n+    try {\n+      return await this.executeTransaction('members', 'readonly', (store) => \n+        store.getAll()\n+      );\n+    } catch (error) {\n+      console.error('회원 목록 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * ID로 회원 조회\n+   */\n+  async getMemberById(id: string): Promise<Member | null> {\n+    try {\n+      return await this.executeTransaction('members', 'readonly', (store) => \n+        store.get(id)\n+      ) || null;\n+    } catch (error) {\n+      console.error('회원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 전화번호로 회원 조회\n+   */\n+  async getMemberByPhone(phone: string): Promise<Member | null> {\n+    try {\n+      return await this.executeTransaction('members', 'readonly', (store) => {\n+        const index = store.index('phone');\n+        return index.get(phone);\n+      }) || null;\n+    } catch (error) {\n+      console.error('전화번호로 회원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 지점별 회원 조회\n+   */\n+  async getMembersByBranch(branchId: string): Promise<Member[]> {\n+    try {\n+      return await this.executeTransaction('members', 'readonly', (store) => {\n+        const index = store.index('branchId');\n+        return index.getAll(branchId);\n+      });\n+    } catch (error) {\n+      console.error('지점별 회원 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 회원 정보 수정\n+   */\n+  async updateMember(id: string, updates: Partial<Omit<Member, 'id' | 'createdAt'>>): Promise<boolean> {\n+    try {\n+      const existingMember = await this.getMemberById(id);\n+      if (!existingMember) {\n+        throw new Error('수정할 회원을 찾을 수 없습니다.');\n+      }\n+\n+      const updatedMember: Member = {\n+        ...existingMember,\n+        ...updates,\n+        updatedAt: new Date(),\n+      };\n+\n+      await this.executeTransaction('members', 'readwrite', (store) => \n+        store.put(updatedMember)\n+      );\n+\n+      console.log('회원 정보 수정 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('회원 정보 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 회원 삭제 (비활성화)\n+   */\n+  async deleteMember(id: string): Promise<boolean> {\n+    try {\n+      await this.updateMember(id, { isActive: false });\n+      console.log('회원 삭제(비활성화) 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('회원 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 회원 검색 (이름, 전화번호, 이메일)\n+   */\n+  async searchMembers(searchTerm: string): Promise<Member[]> {\n+    try {\n+      const allMembers = await this.getAllMembers();\n+      const lowerSearchTerm = searchTerm.toLowerCase();\n+      \n+      return allMembers.filter(member => \n+        member.name.toLowerCase().includes(lowerSearchTerm) ||\n+        member.phone.includes(searchTerm) ||\n+        member.email.toLowerCase().includes(lowerSearchTerm)\n+      );\n+    } catch (error) {\n+      console.error('회원 검색 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  // ==================== 결제 관리 ====================\n+\n+  /**\n+   * 결제 정보 추가\n+   */\n+  async addPayment(paymentData: Omit<Payment, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n+    try {\n+      const payment: Payment = {\n+        id: this.generateUUID(),\n+        ...paymentData,\n+        createdAt: new Date(),\n+        updatedAt: new Date(),\n+      };\n+\n+      await this.executeTransaction('payments', 'readwrite', (store) => \n+        store.add(payment)\n+      );\n+\n+      console.log('결제 정보 추가 성공:', payment.id);\n+      return payment.id;\n+    } catch (error) {\n+      console.error('결제 정보 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 결제 정보 조회\n+   */\n+  async getAllPayments(): Promise<Payment[]> {\n+    try {\n+      return await this.executeTransaction('payments', 'readonly', (store) => \n+        store.getAll()\n+      );\n+    } catch (error) {\n+      console.error('결제 목록 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * ID로 결제 정보 조회\n+   */\n+  async getPaymentById(id: string): Promise<Payment | null> {\n+    try {\n+      return await this.executeTransaction('payments', 'readonly', (store) => \n+        store.get(id)\n+      ) || null;\n+    } catch (error) {\n+      console.error('결제 정보 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 회원별 결제 정보 조회\n+   */\n+  async getPaymentsByMember(memberId: string): Promise<Payment[]> {\n+    try {\n+      return await this.executeTransaction('payments', 'readonly', (store) => {\n+        const index = store.index('memberId');\n+        return index.getAll(memberId);\n+      });\n+    } catch (error) {\n+      console.error('회원별 결제 정보 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 결제 정보 수정\n+   */\n+  async updatePayment(id: string, updates: Partial<Omit<Payment, 'id' | 'createdAt'>>): Promise<boolean> {\n+    try {\n+      const existingPayment = await this.getPaymentById(id);\n+      if (!existingPayment) {\n+        throw new Error('수정할 결제 정보를 찾을 수 없습니다.');\n+      }\n+\n+      const updatedPayment: Payment = {\n+        ...existingPayment,\n+        ...updates,\n+        updatedAt: new Date(),\n+      };\n+\n+      await this.executeTransaction('payments', 'readwrite', (store) => \n+        store.put(updatedPayment)\n+      );\n+\n+      console.log('결제 정보 수정 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('결제 정보 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 결제 정보 삭제\n+   */\n+  async deletePayment(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('payments', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('결제 정보 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('결제 정보 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+}\n+\n+// 싱글톤 인스턴스 생성\n+export const dbManager = new IndexedDBManager();\n+\n+// 개발자 도구에서 사용할 수 있도록 전역 객체에 추가\n+if (typeof window !== 'undefined') {\n+  (window as any).dbManager = dbManager;\n+}\n"
                },
                {
                    "date": 1760254633382,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -115,8 +115,24 @@\n     customerSignature: string;\n     staffSignature: string;\n   };\n   isActive: boolean;\n+  // 추가 회원 정보 필드들\n+  registrationDate: string;\n+  agreementDate: string;\n+  signatureData: string;\n+  membershipType: string;\n+  duration: number;\n+  durationUnit: string;\n+  startDate: string;\n+  endDate: string;\n+  monthlyFee: number;\n+  totalAmount: number;\n+  discountAmount: number;\n+  finalAmount: number;\n+  paymentMethod: string;\n+  paymentDate: string;\n+  remarks: string;\n }\n \n export interface Payment extends DBRecord {\n   memberId: string;\n@@ -316,18 +332,42 @@\n     mode: IDBTransactionMode,\n     operation: (store: IDBObjectStore) => IDBRequest<T>\n   ): Promise<T> {\n     if (!this.db) {\n+      console.log('executeTransaction: DB가 없어서 초기화 시도');\n       await this.initDB();\n     }\n \n     return new Promise((resolve, reject) => {\n+      console.log(`executeTransaction 시작: store=${storeName}, mode=${mode}`);\n+      \n       const transaction = this.db!.transaction([storeName], mode);\n       const store = transaction.objectStore(storeName);\n+      \n+      // 트랜잭션 이벤트 리스너 추가\n+      transaction.oncomplete = () => {\n+        console.log(`트랜잭션 완료: ${storeName}`);\n+      };\n+      \n+      transaction.onerror = (event) => {\n+        console.error(`트랜잭션 오류: ${storeName}`, event);\n+      };\n+      \n+      transaction.onabort = (event) => {\n+        console.error(`트랜잭션 중단: ${storeName}`, event);\n+      };\n+      \n       const request = operation(store);\n \n-      request.onsuccess = () => resolve(request.result);\n-      request.onerror = () => reject(request.error);\n+      request.onsuccess = () => {\n+        console.log(`operation 성공: ${storeName}`);\n+        resolve(request.result);\n+      };\n+      \n+      request.onerror = () => {\n+        console.error(`operation 실패: ${storeName}`, request.error);\n+        reject(request.error);\n+      };\n     });\n   }\n \n   // === 지점 관리 메서드들 ===\n@@ -1734,23 +1774,52 @@\n    * 회원 추가\n    */\n   async addMember(memberData: Omit<Member, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n     try {\n+      console.log('=== addMember 함수 시작 ===');\n+      console.log('받은 memberData:', memberData);\n+      \n+      // 데이터베이스 연결 확인\n+      if (!this.db) {\n+        console.log('데이터베이스가 연결되지 않음, 초기화 시도...');\n+        await this.initDB();\n+      }\n+      console.log('데이터베이스 연결 상태:', this.db ? '연결됨' : '연결 안됨');\n+      \n       const member: Member = {\n         id: this.generateUUID(),\n         ...memberData,\n         createdAt: new Date(),\n         updatedAt: new Date(),\n       };\n \n-      await this.executeTransaction('members', 'readwrite', (store) => \n-        store.add(member)\n+      console.log('생성할 회원 객체:', member);\n+      console.log('회원 ID:', member.id);\n+      \n+      console.log('트랜잭션 시작...');\n+      await this.executeTransaction('members', 'readwrite', (store) => {\n+        console.log('store.add 실행 중...');\n+        return store.add(member);\n+      });\n+\n+      console.log('✅ 회원 추가 성공:', member.id);\n+      \n+      // 즉시 확인\n+      console.log('=== 저장 확인 ===');\n+      const savedMember = await this.executeTransaction('members', 'readonly', (store) => \n+        store.get(member.id)\n       );\n-\n-      console.log('회원 추가 성공:', member.id);\n+      \n+      if (savedMember) {\n+        console.log('✅ 저장된 회원 확인됨:', savedMember);\n+      } else {\n+        console.error('❌ 방금 저장한 회원을 찾을 수 없음');\n+      }\n+      \n       return member.id;\n     } catch (error) {\n-      console.error('회원 추가 실패:', error);\n+      console.error('❌ 회원 추가 실패:', error);\n+      console.error('에러 상세:', error);\n       throw error;\n     }\n   }\n \n@@ -1994,1665 +2063,4 @@\n // 개발자 도구에서 사용할 수 있도록 전역 객체에 추가\n if (typeof window !== 'undefined') {\n   (window as any).dbManager = dbManager;\n }\n-/**\n- * IndexedDB를 활용한 로컬 데이터베이스 관리 유틸리티\n- * 백엔드 연결 전까지 브라우저에서 데이터를 영구 저장\n- */\n-\n-import { SYSTEM_ADMIN_CONFIG } from '../constants/staffConstants';\n-\n-export interface DBRecord {\n-  id: string;\n-  createdAt: Date;\n-  updatedAt: Date;\n-}\n-\n-export interface Branch extends DBRecord {\n-  name: string;\n-  address?: string;\n-  phone?: string;\n-  isActive: boolean;\n-}\n-\n-export interface AppSettings extends DBRecord {\n-  key: string;\n-  value: string;\n-}\n-\n-export interface Staff extends DBRecord {\n-  name: string;\n-  loginId: string; // 로그인 ID\n-  password: string; // 비밀번호\n-  phone: string;\n-  email: string;\n-  branchId: string;\n-  position: string; // 직급\n-  role: string; // 직책\n-  employmentType: string; // 고용형태\n-  permission: string; // 권한\n-  program?: string; // 담당프로그램 (코치일 경우만)\n-  contractStartDate: Date;\n-  contractEndDate?: Date | null; // 계약종료일 (정규직은 없을 수 있음)\n-  contractFile?: File | null; // 계약서 파일\n-  contractFileName?: string; // 계약서 파일명 저장용\n-  contractFileData?: ArrayBuffer; // 계약서 파일 데이터 저장용\n-  workingHours?: {\n-    start: number; // 기본 근무 시작 시간 (시)\n-    end: number; // 기본 근무 종료 시간 (시)\n-  };\n-  isActive: boolean; // 활성/비활성 상태\n-}\n-\n-export interface Program extends DBRecord {\n-  name: string;\n-  type: string; // '횟수제' | '기간제'\n-  isActive: boolean;\n-}\n-\n-export interface Product extends DBRecord {\n-  name: string;\n-  branchId: string;\n-  programId: string;\n-  programName: string; // 프로그램명 저장 (조회 성능 향상)\n-  programType: string; // 프로그램 종류 저장 (조회 성능 향상)\n-  sessions?: number; // 횟수 (횟수제인 경우에만 필요)\n-  duration?: number; // 소요시간 (분 단위, 횟수제인 경우에만 필요)\n-  price?: number; // 가격\n-  description?: string; // 상품소개\n-  isActive: boolean;\n-}\n-\n-export interface HolidaySettings extends DBRecord {\n-  staffId: string;\n-  date: string; // YYYY-MM-DD 형식\n-  isHoliday: boolean; // true: 휴일, false: 근무일\n-  workingHours?: {\n-    start: number;\n-    end: number;\n-  }; // 해당 날짜의 근무시간 (휴일이 아닌 경우)\n-}\n-\n-export interface TermsDocument extends DBRecord {\n-  type: 'privacy_policy' | 'terms_of_service' | 'business_info' | 'marketing_consent' | 'member_terms' | 'contract';\n-  title: string;\n-  content: string;\n-  version: number; // 버전 관리\n-  isActive: boolean;\n-  publishedAt?: Date | null; // 발행일\n-}\n-\n-class IndexedDBManager {\n-  private dbName: string = 'LavidaDB';\n-  private version: number = 8; // 버전 업데이트 (TermsDocument 테이블 추가)\n-  private db: IDBDatabase | null = null;\n-\n-  constructor() {\n-    this.initDB();\n-  }\n-\n-  /**\n-   * IndexedDB 초기화\n-   */\n-  private async initDB(): Promise<void> {\n-    return new Promise((resolve, reject) => {\n-      const request = indexedDB.open(this.dbName, this.version);\n-\n-      request.onerror = () => {\n-        console.error('IndexedDB 열기 실패:', request.error);\n-        reject(request.error);\n-      };\n-\n-      request.onsuccess = () => {\n-        this.db = request.result;\n-        console.log('IndexedDB 연결 성공');\n-        resolve();\n-      };\n-\n-      request.onupgradeneeded = (event) => {\n-        const db = (event.target as IDBOpenDBRequest).result;\n-\n-        // 지점 테이블 생성\n-        if (!db.objectStoreNames.contains('branches')) {\n-          const branchStore = db.createObjectStore('branches', { keyPath: 'id' });\n-          branchStore.createIndex('name', 'name', { unique: true }); // 지점명 고유 제약\n-          branchStore.createIndex('isActive', 'isActive', { unique: false });\n-          branchStore.createIndex('createdAt', 'createdAt', { unique: false });\n-        } else {\n-          // 기존 테이블이 있으면 인덱스 업데이트\n-          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n-          const branchStore = transaction.objectStore('branches');\n-          \n-          // 기존 name 인덱스 삭제 후 unique로 재생성\n-          if (branchStore.indexNames.contains('name')) {\n-            branchStore.deleteIndex('name');\n-          }\n-          branchStore.createIndex('name', 'name', { unique: true });\n-        }\n-\n-        // 직원 테이블 생성\n-        if (!db.objectStoreNames.contains('staff')) {\n-          const staffStore = db.createObjectStore('staff', { keyPath: 'id' });\n-          staffStore.createIndex('name', 'name', { unique: false });\n-          staffStore.createIndex('loginId', 'loginId', { unique: true });\n-          staffStore.createIndex('email', 'email', { unique: true });\n-          staffStore.createIndex('branchId', 'branchId', { unique: false });\n-          staffStore.createIndex('position', 'position', { unique: false });\n-          staffStore.createIndex('role', 'role', { unique: false });\n-          staffStore.createIndex('employmentType', 'employmentType', { unique: false });\n-          staffStore.createIndex('permission', 'permission', { unique: false });\n-          staffStore.createIndex('isActive', 'isActive', { unique: false });\n-          staffStore.createIndex('createdAt', 'createdAt', { unique: false });\n-        } else {\n-          // 기존 테이블이 있으면 인덱스 업데이트 (isActive 인덱스 추가)\n-          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n-          const staffStore = transaction.objectStore('staff');\n-          \n-          if (!staffStore.indexNames.contains('isActive')) {\n-            staffStore.createIndex('isActive', 'isActive', { unique: false });\n-          }\n-        }\n-\n-        // 프로그램 테이블 생성\n-        if (!db.objectStoreNames.contains('programs')) {\n-          const programStore = db.createObjectStore('programs', { keyPath: 'id' });\n-          programStore.createIndex('name', 'name', { unique: true }); // 프로그램명 고유 제약\n-          programStore.createIndex('type', 'type', { unique: false });\n-          programStore.createIndex('isActive', 'isActive', { unique: false });\n-          programStore.createIndex('createdAt', 'createdAt', { unique: false });\n-        } else {\n-          // 기존 테이블이 있으면 인덱스 업데이트\n-          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n-          const programStore = transaction.objectStore('programs');\n-          \n-          // 기존 name 인덱스 삭제 후 unique로 재생성\n-          if (programStore.indexNames.contains('name')) {\n-            programStore.deleteIndex('name');\n-          }\n-          programStore.createIndex('name', 'name', { unique: true });\n-        }\n-\n-        // 상품 테이블 생성\n-        if (!db.objectStoreNames.contains('products')) {\n-          const productStore = db.createObjectStore('products', { keyPath: 'id' });\n-          productStore.createIndex('name', 'name', { unique: false });\n-          productStore.createIndex('branchId', 'branchId', { unique: false });\n-          productStore.createIndex('programId', 'programId', { unique: false });\n-          productStore.createIndex('programType', 'programType', { unique: false });\n-          productStore.createIndex('isActive', 'isActive', { unique: false });\n-          productStore.createIndex('createdAt', 'createdAt', { unique: false });\n-          // 복합 인덱스: 지점별, 프로그램별 조회 최적화\n-          productStore.createIndex('branchProgram', ['branchId', 'programId'], { unique: false });\n-        }\n-\n-        // 휴일설정 테이블 생성\n-        if (!db.objectStoreNames.contains('holidaySettings')) {\n-          const holidayStore = db.createObjectStore('holidaySettings', { keyPath: 'id' });\n-          holidayStore.createIndex('staffId', 'staffId', { unique: false });\n-          holidayStore.createIndex('date', 'date', { unique: false });\n-          holidayStore.createIndex('isHoliday', 'isHoliday', { unique: false });\n-          // 복합 인덱스: 직원별, 날짜별 조회 최적화\n-          holidayStore.createIndex('staffDate', ['staffId', 'date'], { unique: true });\n-        }\n-\n-        // 약관/문서 테이블 생성\n-        if (!db.objectStoreNames.contains('termsDocuments')) {\n-          const termsStore = db.createObjectStore('termsDocuments', { keyPath: 'id' });\n-          termsStore.createIndex('type', 'type', { unique: false });\n-          termsStore.createIndex('language', 'language', { unique: false });\n-          termsStore.createIndex('title', 'title', { unique: false });\n-          termsStore.createIndex('version', 'version', { unique: false });\n-          termsStore.createIndex('isActive', 'isActive', { unique: false });\n-          termsStore.createIndex('publishedAt', 'publishedAt', { unique: false });\n-          termsStore.createIndex('createdAt', 'createdAt', { unique: false });\n-          // 복합 인덱스: 타입별, 언어별 조회 최적화\n-          termsStore.createIndex('typeLanguage', ['type', 'language'], { unique: false });\n-          // 활성 상태 및 최신 버전 조회 최적화\n-          termsStore.createIndex('typeLanguageActive', ['type', 'language', 'isActive'], { unique: false });\n-        }\n-\n-        // 향후 다른 테이블들도 여기에 추가 가능\n-        // 예: 회원, 방문기록 등\n-      };\n-    });\n-  }\n-\n-  /**\n-   * 고유 ID 생성 (UUID v4 형식)\n-   */\n-  private generateUUID(): string {\n-    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n-      const r = Math.random() * 16 | 0;\n-      const v = c === 'x' ? r : ((r & 0x3) | 0x8);\n-      return v.toString(16);\n-    });\n-  }\n-\n-  /**\n-   * 트랜잭션 실행 헬퍼\n-   */\n-  private async executeTransaction<T>(\n-    storeName: string,\n-    mode: IDBTransactionMode,\n-    operation: (store: IDBObjectStore) => IDBRequest<T>\n-  ): Promise<T> {\n-    if (!this.db) {\n-      await this.initDB();\n-    }\n-\n-    return new Promise((resolve, reject) => {\n-      const transaction = this.db!.transaction([storeName], mode);\n-      const store = transaction.objectStore(storeName);\n-      const request = operation(store);\n-\n-      request.onsuccess = () => resolve(request.result);\n-      request.onerror = () => reject(request.error);\n-    });\n-  }\n-\n-  // === 지점 관리 메서드들 ===\n-\n-  /**\n-   * 모든 지점 조회\n-   */\n-  async getAllBranches(): Promise<Branch[]> {\n-    try {\n-      return await this.executeTransaction('branches', 'readonly', (store) => \n-        store.getAll()\n-      );\n-    } catch (error) {\n-      console.error('지점 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * ID로 지점 조회\n-   */\n-  async getBranchById(id: string): Promise<Branch | null> {\n-    try {\n-      const result = await this.executeTransaction('branches', 'readonly', (store) => \n-        store.get(id)\n-      );\n-      return result || null;\n-    } catch (error) {\n-      console.error('지점 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 지점 추가\n-   */\n-  async addBranch(branchData: Omit<Branch, 'id' | 'createdAt' | 'updatedAt'>): Promise<Branch> {\n-    const now = new Date();\n-    const newBranch: Branch = {\n-      ...branchData,\n-      id: this.generateUUID(),\n-      createdAt: now,\n-      updatedAt: now,\n-    };\n-\n-    try {\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.add(newBranch)\n-      );\n-      console.log('지점 추가 성공:', newBranch);\n-      return newBranch;\n-    } catch (error) {\n-      console.error('지점 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 지점 수정\n-   */\n-  async updateBranch(id: string, updates: Partial<Omit<Branch, 'id' | 'createdAt'>>): Promise<Branch | null> {\n-    try {\n-      const existing = await this.getBranchById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 지점입니다.');\n-      }\n-\n-      const updatedBranch: Branch = {\n-        ...existing,\n-        ...updates,\n-        updatedAt: new Date(),\n-      };\n-\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.put(updatedBranch)\n-      );\n-\n-      console.log('지점 수정 성공:', updatedBranch);\n-      return updatedBranch;\n-    } catch (error) {\n-      console.error('지점 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 지점 삭제\n-   */\n-  async deleteBranch(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-      console.log('지점 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('지점 삭제 실패:', error);\n-      return false;\n-    }\n-  }\n-\n-  /**\n-   * 활성 지점만 조회\n-   */\n-  async getActiveBranches(): Promise<Branch[]> {\n-    try {\n-      return await this.executeTransaction('branches', 'readonly', (store) => {\n-        const index = store.index('isActive');\n-        return index.getAll(IDBKeyRange.only(true));\n-      });\n-    } catch (error) {\n-      console.error('활성 지점 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 지점명으로 정확히 일치하는 지점 조회 또는 생성 (원자적 처리)\n-   * 동시 실행 시 race condition 방지\n-   */\n-  async getOrCreateBranchByName(name: string, branchData?: Omit<Branch, 'id' | 'createdAt' | 'updatedAt' | 'name'>): Promise<Branch> {\n-    if (!this.db) {\n-      await this.initDB();\n-    }\n-\n-    return new Promise((resolve, reject) => {\n-      const transaction = this.db!.transaction(['branches'], 'readwrite');\n-      const store = transaction.objectStore('branches');\n-      const index = store.index('name');\n-      \n-      // 먼저 기존 지점 확인\n-      const getRequest = index.get(name);\n-      \n-      getRequest.onsuccess = () => {\n-        if (getRequest.result) {\n-          // 이미 존재함\n-          resolve(getRequest.result);\n-        } else {\n-          // 존재하지 않음, 새로 생성\n-          const now = new Date();\n-          const newBranch: Branch = {\n-            name,\n-            address: branchData?.address || '',\n-            phone: branchData?.phone || '',\n-            isActive: branchData?.isActive ?? true,\n-            id: this.generateUUID(),\n-            createdAt: now,\n-            updatedAt: now,\n-          };\n-\n-          const addRequest = store.add(newBranch);\n-          addRequest.onsuccess = () => {\n-            console.log('새 지점 생성 완료:', newBranch);\n-            resolve(newBranch);\n-          };\n-          addRequest.onerror = () => {\n-            console.error('지점 추가 실패:', addRequest.error);\n-            reject(addRequest.error);\n-          };\n-        }\n-      };\n-      \n-      getRequest.onerror = () => {\n-        console.error('지점 조회 실패:', getRequest.error);\n-        reject(getRequest.error);\n-      };\n-    });\n-  }\n-\n-  /**\n-   * 지점명으로 정확히 일치하는 지점 조회\n-   */\n-  async getBranchByName(name: string): Promise<Branch | null> {\n-    try {\n-      const allBranches = await this.getAllBranches();\n-      const branch = allBranches.find(branch => branch.name === name);\n-      return branch || null;\n-    } catch (error) {\n-      console.error('지점명으로 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 지점명으로 검색\n-   */\n-  async searchBranchesByName(name: string): Promise<Branch[]> {\n-    try {\n-      const allBranches = await this.getAllBranches();\n-      return allBranches.filter(branch => \n-        branch.name.toLowerCase().includes(name.toLowerCase())\n-      );\n-    } catch (error) {\n-      console.error('지점 검색 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  // === 직원 관리 메서드들 ===\n-\n-  /**\n-   * 모든 직원 조회\n-   */\n-  async getAllStaff(): Promise<Staff[]> {\n-    try {\n-      const staffList = await this.executeTransaction('staff', 'readonly', (store) => \n-        store.getAll()\n-      );\n-\n-      // 저장된 파일 데이터를 File 객체로 복원\n-      return staffList.map(staff => {\n-        if (staff.contractFileData && staff.contractFileName) {\n-          // 파일 확장자로부터 MIME 타입 추정\n-          const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n-          let mimeType = 'application/octet-stream';\n-          \n-          if (extension === 'pdf') {\n-            mimeType = 'application/pdf';\n-          } else if (['jpg', 'jpeg'].includes(extension || '')) {\n-            mimeType = 'image/jpeg';\n-          } else if (extension === 'png') {\n-            mimeType = 'image/png';\n-          }\n-\n-          staff.contractFile = this.arrayBufferToFile(\n-            staff.contractFileData, \n-            staff.contractFileName, \n-            mimeType\n-          );\n-        }\n-        return staff;\n-      });\n-    } catch (error) {\n-      console.error('직원 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * ID로 직원 조회\n-   */\n-  async getStaffById(id: string): Promise<Staff | null> {\n-    try {\n-      const staff = await this.executeTransaction('staff', 'readonly', (store) => \n-        store.get(id)\n-      );\n-\n-      if (!staff) return null;\n-\n-      // 저장된 파일 데이터를 File 객체로 복원\n-      if (staff.contractFileData && staff.contractFileName) {\n-        const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n-        let mimeType = 'application/octet-stream';\n-        \n-        if (extension === 'pdf') {\n-          mimeType = 'application/pdf';\n-        } else if (['jpg', 'jpeg'].includes(extension || '')) {\n-          mimeType = 'image/jpeg';\n-        } else if (extension === 'png') {\n-          mimeType = 'image/png';\n-        }\n-\n-        staff.contractFile = this.arrayBufferToFile(\n-          staff.contractFileData, \n-          staff.contractFileName, \n-          mimeType\n-        );\n-      }\n-\n-      return staff;\n-    } catch (error) {\n-      console.error('직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 직원 추가\n-   */\n-  async addStaff(staffData: Omit<Staff, 'id' | 'createdAt' | 'updatedAt'>): Promise<Staff> {\n-    const now = new Date();\n-    \n-    // 파일 데이터 처리\n-    let contractFileData: ArrayBuffer | undefined;\n-    let contractFileName: string | undefined;\n-    \n-    if (staffData.contractFile) {\n-      contractFileData = await this.fileToArrayBuffer(staffData.contractFile);\n-      contractFileName = staffData.contractFile.name;\n-    }\n-\n-    const newStaff: Staff = {\n-      ...staffData,\n-      id: this.generateUUID(),\n-      createdAt: now,\n-      updatedAt: now,\n-      isActive: staffData.isActive !== undefined ? staffData.isActive : true, // 기본값 true\n-      contractFile: undefined, // File 객체는 저장하지 않음\n-      contractFileName,\n-      contractFileData,\n-    };\n-\n-    try {\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.add(newStaff)\n-      );\n-      console.log('직원 추가 성공:', newStaff);\n-      return newStaff;\n-    } catch (error) {\n-      console.error('직원 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 시스템 관리자 계정인지 확인\n-   */\n-  private isSystemAdmin(staff: Staff): boolean {\n-    return staff.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID;\n-  }\n-\n-  /**\n-   * 시스템 관리자 보호 검증\n-   */\n-  private validateSystemAdminProtection(staff: Staff, operation: 'delete' | 'permission_change'): void {\n-    if (this.isSystemAdmin(staff)) {\n-      const message = operation === 'delete' \n-        ? '시스템 관리자 계정은 삭제할 수 없습니다.'\n-        : '시스템 관리자 계정의 권한은 변경할 수 없습니다.';\n-      throw new Error(message);\n-    }\n-  }\n-\n-  /**\n-   * 직원 수정\n-   */\n-  async updateStaff(id: string, updates: Partial<Omit<Staff, 'id' | 'createdAt'>>): Promise<Staff | null> {\n-    try {\n-      const existing = await this.getStaffById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 직원입니다.');\n-      }\n-\n-      // 시스템 관리자 권한 변경 보호\n-      if (updates.permission && updates.permission !== existing.permission) {\n-        this.validateSystemAdminProtection(existing, 'permission_change');\n-      }\n-\n-      // 파일 데이터 처리\n-      let contractFileData = existing.contractFileData;\n-      let contractFileName = existing.contractFileName;\n-      \n-      if (updates.contractFile) {\n-        contractFileData = await this.fileToArrayBuffer(updates.contractFile);\n-        contractFileName = updates.contractFile.name;\n-      }\n-\n-      const updatedStaff: Staff = {\n-        ...existing,\n-        ...updates,\n-        updatedAt: new Date(),\n-        contractFile: undefined, // File 객체는 저장하지 않음\n-        contractFileName,\n-        contractFileData,\n-      };\n-\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.put(updatedStaff)\n-      );\n-\n-      console.log('직원 수정 성공:', updatedStaff);\n-      return updatedStaff;\n-    } catch (error) {\n-      console.error('직원 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 직원 삭제\n-   */\n-  async deleteStaff(id: string): Promise<boolean> {\n-    try {\n-      const existing = await this.getStaffById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 직원입니다.');\n-      }\n-\n-      // 시스템 관리자 삭제 보호\n-      this.validateSystemAdminProtection(existing, 'delete');\n-\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-      console.log('직원 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('직원 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 직원 활성/비활성 상태 토글\n-   */\n-  async toggleStaffStatus(id: string): Promise<Staff | null> {\n-    try {\n-      const existing = await this.getStaffById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 직원입니다.');\n-      }\n-\n-      // 시스템 관리자 상태 변경 보호\n-      if (existing.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID) {\n-        throw new Error('시스템 관리자 계정의 상태는 변경할 수 없습니다.');\n-      }\n-\n-      const updatedStaff = {\n-        ...existing,\n-        isActive: !existing.isActive,\n-        updatedAt: new Date()\n-      };\n-\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.put(updatedStaff)\n-      );\n-\n-      console.log('직원 상태 변경 성공:', id, `-> ${updatedStaff.isActive ? '활성' : '비활성'}`);\n-      return updatedStaff;\n-    } catch (error) {\n-      console.error('직원 상태 변경 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 지점별 직원 조회\n-   */\n-  async getStaffByBranch(branchId: string): Promise<Staff[]> {\n-    try {\n-      return await this.executeTransaction('staff', 'readonly', (store) => {\n-        const index = store.index('branchId');\n-        return index.getAll(IDBKeyRange.only(branchId));\n-      });\n-    } catch (error) {\n-      console.error('지점별 직원 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 이메일로 직원 조회\n-   */\n-  async getStaffByEmail(email: string): Promise<Staff | null> {\n-    try {\n-      const result = await this.executeTransaction('staff', 'readonly', (store) => {\n-        const index = store.index('email');\n-        return index.get(email);\n-      });\n-      return result || null;\n-    } catch (error) {\n-      console.error('이메일로 직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 로그인ID로 직원 조회\n-   */\n-  async getStaffByLoginId(loginId: string): Promise<Staff | null> {\n-    try {\n-      const staff = await this.executeTransaction('staff', 'readonly', (store) => {\n-        const index = store.index('loginId');\n-        return index.get(loginId);\n-      });\n-\n-      if (!staff) return null;\n-\n-      // 저장된 파일 데이터를 File 객체로 복원\n-      if (staff.contractFileData && staff.contractFileName) {\n-        const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n-        let mimeType = 'application/octet-stream';\n-        \n-        if (extension === 'pdf') {\n-          mimeType = 'application/pdf';\n-        } else if (['jpg', 'jpeg'].includes(extension || '')) {\n-          mimeType = 'image/jpeg';\n-        } else if (extension === 'png') {\n-          mimeType = 'image/png';\n-        }\n-\n-        staff.contractFile = this.arrayBufferToFile(\n-          staff.contractFileData, \n-          staff.contractFileName, \n-          mimeType\n-        );\n-      }\n-\n-      return staff;\n-    } catch (error) {\n-      console.error('로그인ID로 직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 전화번호로 직원 조회\n-   */\n-  async getStaffByPhone(phone: string): Promise<Staff | null> {\n-    try {\n-      const allStaff = await this.getAllStaff();\n-      const found = allStaff.find(staff => staff.phone === phone);\n-      return found || null;\n-    } catch (error) {\n-      console.error('전화번호로 직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 중복 체크 함수 (등록 시 사용)\n-   */\n-  async checkDuplicateStaff(loginId: string, email: string, phone: string): Promise<{\n-    isDuplicate: boolean;\n-    duplicateField?: 'loginId' | 'email' | 'phone';\n-    message?: string;\n-  }> {\n-    try {\n-      // 로그인 ID 중복 체크\n-      const existingByLoginId = await this.getStaffByLoginId(loginId);\n-      if (existingByLoginId) {\n-        return {\n-          isDuplicate: true,\n-          duplicateField: 'loginId',\n-          message: '이미 사용 중인 로그인 ID입니다.'\n-        };\n-      }\n-\n-      // 이메일 중복 체크\n-      const existingByEmail = await this.getStaffByEmail(email);\n-      if (existingByEmail) {\n-        return {\n-          isDuplicate: true,\n-          duplicateField: 'email',\n-          message: '이미 사용 중인 이메일입니다.'\n-        };\n-      }\n-\n-      // 전화번호 중복 체크\n-      const existingByPhone = await this.getStaffByPhone(phone);\n-      if (existingByPhone) {\n-        return {\n-          isDuplicate: true,\n-          duplicateField: 'phone',\n-          message: '이미 사용 중인 전화번호입니다.'\n-        };\n-      }\n-\n-      return { isDuplicate: false };\n-    } catch (error) {\n-      console.error('중복 체크 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 파일을 ArrayBuffer로 변환\n-   */\n-  private fileToArrayBuffer(file: File): Promise<ArrayBuffer> {\n-    return new Promise((resolve, reject) => {\n-      const reader = new FileReader();\n-      reader.onload = () => resolve(reader.result as ArrayBuffer);\n-      reader.onerror = () => reject(reader.error);\n-      reader.readAsArrayBuffer(file);\n-    });\n-  }\n-\n-  /**\n-   * ArrayBuffer를 Blob으로 변환 (파일 다운로드용)\n-   */\n-  arrayBufferToBlob(buffer: ArrayBuffer, mimeType: string): Blob {\n-    return new Blob([buffer], { type: mimeType });\n-  }\n-\n-  /**\n-   * ArrayBuffer를 File 객체로 변환\n-   */\n-  private arrayBufferToFile(buffer: ArrayBuffer, fileName: string, mimeType: string = 'application/octet-stream'): File {\n-    const blob = new Blob([buffer], { type: mimeType });\n-    return new File([blob], fileName, { type: mimeType });\n-  }\n-\n-  /**\n-   * 데이터베이스 초기화 (개발/테스트용)\n-   */\n-  async clearAllData(): Promise<void> {\n-    try {\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('programs', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('products', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      console.log('모든 데이터 삭제 완료');\n-    } catch (error) {\n-      console.error('데이터 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 기존 직원 데이터의 isActive 필드 초기화 (마이그레이션용)\n-   */\n-  async migrateStaffActiveStatus(): Promise<void> {\n-    try {\n-      const allStaff = await this.executeTransaction('staff', 'readonly', (store) => \n-        store.getAll()\n-      );\n-\n-      // isActive 필드가 없는 직원들을 찾아서 업데이트\n-      const staffToUpdate = allStaff.filter(staff => staff.isActive === undefined);\n-      \n-      if (staffToUpdate.length > 0) {\n-        console.log(`${staffToUpdate.length}명의 직원 isActive 필드를 초기화합니다.`);\n-        \n-        for (const staff of staffToUpdate) {\n-          const updatedStaff = {\n-            ...staff,\n-            isActive: true, // 기본값을 true로 설정\n-            updatedAt: new Date()\n-          };\n-          \n-          await this.executeTransaction('staff', 'readwrite', (store) => \n-            store.put(updatedStaff)\n-          );\n-        }\n-        \n-        console.log('직원 isActive 필드 초기화 완료');\n-      }\n-    } catch (error) {\n-      console.error('직원 isActive 필드 초기화 실패:', error);\n-    }\n-  }\n-\n-  // =================== 프로그램 관리 메서드 ===================\n-\n-  /**\n-   * 프로그램 추가\n-   */\n-  async addProgram(programData: Omit<Program, 'id' | 'createdAt' | 'updatedAt'>): Promise<Program> {\n-    try {\n-      // 프로그램명 중복 체크\n-      const existingProgram = await this.getProgramByName(programData.name);\n-      if (existingProgram) {\n-        throw new Error('이미 존재하는 프로그램명입니다.');\n-      }\n-\n-      const newProgram: Program = {\n-        id: this.generateUUID(),\n-        ...programData,\n-        createdAt: new Date(),\n-        updatedAt: new Date()\n-      };\n-\n-      await this.executeTransaction('programs', 'readwrite', (store) => \n-        store.add(newProgram)\n-      );\n-\n-      console.log('프로그램 추가 성공:', newProgram);\n-      return newProgram;\n-    } catch (error) {\n-      console.error('프로그램 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 모든 프로그램 조회\n-   */\n-  async getAllPrograms(): Promise<Program[]> {\n-    try {\n-      const programs = await this.executeTransaction('programs', 'readonly', (store) => \n-        store.getAll()\n-      );\n-      \n-      return programs.map(program => ({\n-        ...program,\n-        createdAt: new Date(program.createdAt),\n-        updatedAt: new Date(program.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('프로그램 목록 조회 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 프로그램명으로 조회\n-   */\n-  async getProgramByName(name: string): Promise<Program | null> {\n-    try {\n-      const program = await this.executeTransaction('programs', 'readonly', (store) => \n-        store.index('name').get(name)\n-      );\n-      \n-      if (program) {\n-        return {\n-          ...program,\n-          createdAt: new Date(program.createdAt),\n-          updatedAt: new Date(program.updatedAt)\n-        };\n-      }\n-      \n-      return null;\n-    } catch (error) {\n-      console.error('프로그램 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 프로그램 수정\n-   */\n-  async updateProgram(id: string, updates: Partial<Omit<Program, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Program | null> {\n-    try {\n-      const existingProgram = await this.executeTransaction('programs', 'readonly', (store) => \n-        store.get(id)\n-      );\n-\n-      if (!existingProgram) {\n-        console.error('수정할 프로그램을 찾을 수 없습니다:', id);\n-        return null;\n-      }\n-\n-      // 프로그램명 변경 시 중복 체크\n-      if (updates.name && updates.name !== existingProgram.name) {\n-        const duplicateProgram = await this.getProgramByName(updates.name);\n-        if (duplicateProgram) {\n-          throw new Error('이미 존재하는 프로그램명입니다.');\n-        }\n-      }\n-\n-      const updatedProgram: Program = {\n-        ...existingProgram,\n-        ...updates,\n-        id,\n-        createdAt: new Date(existingProgram.createdAt),\n-        updatedAt: new Date()\n-      };\n-\n-      await this.executeTransaction('programs', 'readwrite', (store) => \n-        store.put(updatedProgram)\n-      );\n-\n-      console.log('프로그램 수정 성공:', updatedProgram);\n-      return updatedProgram;\n-    } catch (error) {\n-      console.error('프로그램 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 프로그램 삭제\n-   */\n-  async deleteProgram(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('programs', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-\n-      console.log('프로그램 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('프로그램 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  // =================== 상품 관리 메서드 ===================\n-\n-  /**\n-   * 상품 추가\n-   */\n-  async addProduct(productData: Omit<Product, 'id' | 'createdAt' | 'updatedAt'>): Promise<Product> {\n-    try {\n-      const newProduct: Product = {\n-        id: this.generateUUID(),\n-        ...productData,\n-        createdAt: new Date(),\n-        updatedAt: new Date()\n-      };\n-\n-      await this.executeTransaction('products', 'readwrite', (store) => \n-        store.add(newProduct)\n-      );\n-\n-      console.log('상품 추가 성공:', newProduct);\n-      return newProduct;\n-    } catch (error) {\n-      console.error('상품 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 모든 상품 조회\n-   */\n-  async getAllProducts(): Promise<Product[]> {\n-    try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => \n-        store.getAll()\n-      );\n-      \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('상품 목록 조회 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * ID로 상품 조회\n-   */\n-  async getProductById(id: string): Promise<Product | null> {\n-    try {\n-      const product = await this.executeTransaction('products', 'readonly', (store) => \n-        store.get(id)\n-      );\n-      \n-      if (product) {\n-        return {\n-          ...product,\n-          createdAt: new Date(product.createdAt),\n-          updatedAt: new Date(product.updatedAt)\n-        };\n-      }\n-      \n-      return null;\n-    } catch (error) {\n-      console.error('상품 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 지점별 상품 조회\n-   */\n-  async getProductsByBranch(branchId: string): Promise<Product[]> {\n-    try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => {\n-        const index = store.index('branchId');\n-        return index.getAll(IDBKeyRange.only(branchId));\n-      });\n-      \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('지점별 상품 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 프로그램별 상품 조회\n-   */\n-  async getProductsByProgram(programId: string): Promise<Product[]> {\n-    try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => {\n-        const index = store.index('programId');\n-        return index.getAll(IDBKeyRange.only(programId));\n-      });\n-      \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('프로그램별 상품 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 지점과 프로그램으로 상품 조회\n-   */\n-  async getProductsByBranchAndProgram(branchId: string, programId: string): Promise<Product[]> {\n-    try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => {\n-        const index = store.index('branchProgram');\n-        return index.getAll(IDBKeyRange.only([branchId, programId]));\n-      });\n-      \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('지점-프로그램별 상품 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 상품 수정\n-   */\n-  async updateProduct(id: string, updates: Partial<Omit<Product, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Product | null> {\n-    try {\n-      const existingProduct = await this.executeTransaction('products', 'readonly', (store) => \n-        store.get(id)\n-      );\n-\n-      if (!existingProduct) {\n-        console.error('수정할 상품을 찾을 수 없습니다:', id);\n-        return null;\n-      }\n-\n-      const updatedProduct: Product = {\n-        ...existingProduct,\n-        ...updates,\n-        id,\n-        createdAt: new Date(existingProduct.createdAt),\n-        updatedAt: new Date()\n-      };\n-\n-      await this.executeTransaction('products', 'readwrite', (store) => \n-        store.put(updatedProduct)\n-      );\n-\n-      console.log('상품 수정 성공:', updatedProduct);\n-      return updatedProduct;\n-    } catch (error) {\n-      console.error('상품 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 상품 삭제\n-   */\n-  async deleteProduct(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('products', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-\n-      console.log('상품 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('상품 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 활성 상품만 조회\n-   */\n-  async getActiveProducts(): Promise<Product[]> {\n-    try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => {\n-        const index = store.index('isActive');\n-        return index.getAll(IDBKeyRange.only(true));\n-      });\n-      \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('활성 상품 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 상품명으로 검색\n-   */\n-  async searchProductsByName(name: string): Promise<Product[]> {\n-    try {\n-      const allProducts = await this.getAllProducts();\n-      return allProducts.filter(product => \n-        product.name.toLowerCase().includes(name.toLowerCase())\n-      );\n-    } catch (error) {\n-      console.error('상품 검색 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  // ==================== 휴일설정 관련 메서드 ====================\n-\n-  /**\n-   * 휴일설정 추가/업데이트\n-   */\n-  async saveHolidaySettings(settingsArray: Omit<HolidaySettings, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<HolidaySettings[]> {\n-    try {\n-      const savedSettings: HolidaySettings[] = [];\n-      \n-      for (const setting of settingsArray) {\n-        // 기존 설정이 있는지 확인\n-        const existingSettings = await this.getHolidaySettingsByStaffAndDate(setting.staffId, setting.date);\n-        \n-        let savedSetting: HolidaySettings;\n-        \n-        if (existingSettings.length > 0) {\n-          // 업데이트\n-          const existing = existingSettings[0];\n-          savedSetting = {\n-            ...existing,\n-            ...setting,\n-            updatedAt: new Date()\n-          };\n-          \n-          await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n-            store.put(savedSetting)\n-          );\n-        } else {\n-          // 새로 추가\n-          savedSetting = {\n-            ...setting,\n-            id: this.generateUUID(),\n-            createdAt: new Date(),\n-            updatedAt: new Date()\n-          };\n-          \n-          await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n-            store.add(savedSetting)\n-          );\n-        }\n-        \n-        savedSettings.push(savedSetting);\n-      }\n-\n-      console.log('휴일설정 저장 성공:', savedSettings.length);\n-      return savedSettings;\n-    } catch (error) {\n-      console.error('휴일설정 저장 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 특정 직원의 모든 휴일설정 조회\n-   */\n-  async getHolidaySettingsByStaff(staffId: string): Promise<HolidaySettings[]> {\n-    try {\n-      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n-        const index = store.index('staffId');\n-        return index.getAll(IDBKeyRange.only(staffId));\n-      });\n-      \n-      return settings.map(setting => ({\n-        ...setting,\n-        createdAt: new Date(setting.createdAt),\n-        updatedAt: new Date(setting.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('직원별 휴일설정 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 특정 직원의 특정 날짜 휴일설정 조회\n-   */\n-  async getHolidaySettingsByStaffAndDate(staffId: string, date: string): Promise<HolidaySettings[]> {\n-    try {\n-      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n-        const index = store.index('staffDate');\n-        return index.getAll(IDBKeyRange.only([staffId, date]));\n-      });\n-      \n-      return settings.map(setting => ({\n-        ...setting,\n-        createdAt: new Date(setting.createdAt),\n-        updatedAt: new Date(setting.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('직원별 날짜별 휴일설정 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 특정 날짜의 모든 휴일설정 조회\n-   */\n-  async getHolidaySettingsByDate(date: string): Promise<HolidaySettings[]> {\n-    try {\n-      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n-        const index = store.index('date');\n-        return index.getAll(IDBKeyRange.only(date));\n-      });\n-      \n-      return settings.map(setting => ({\n-        ...setting,\n-        createdAt: new Date(setting.createdAt),\n-        updatedAt: new Date(setting.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('날짜별 휴일설정 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 날짜 범위의 휴일설정 조회\n-   */\n-  async getHolidaySettingsByDateRange(startDate: string, endDate: string): Promise<HolidaySettings[]> {\n-    try {\n-      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n-        const index = store.index('date');\n-        return index.getAll(IDBKeyRange.bound(startDate, endDate));\n-      });\n-      \n-      return settings.map(setting => ({\n-        ...setting,\n-        createdAt: new Date(setting.createdAt),\n-        updatedAt: new Date(setting.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('날짜 범위별 휴일설정 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 휴일설정 삭제\n-   */\n-  async deleteHolidaySettings(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-\n-      console.log('휴일설정 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('휴일설정 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 특정 직원의 모든 휴일설정 삭제\n-   */\n-  async deleteHolidaySettingsByStaff(staffId: string): Promise<boolean> {\n-    try {\n-      const settings = await this.getHolidaySettingsByStaff(staffId);\n-      \n-      for (const setting of settings) {\n-        await this.deleteHolidaySettings(setting.id);\n-      }\n-\n-      console.log('직원 휴일설정 전체 삭제 성공:', staffId);\n-      return true;\n-    } catch (error) {\n-      console.error('직원 휴일설정 전체 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  // ==================== 약관/문서 관련 메서드 ====================\n-\n-  /**\n-   * 약관/문서 추가\n-   */\n-  async addTermsDocument(documentData: Omit<TermsDocument, 'id' | 'createdAt' | 'updatedAt' | 'version'>): Promise<TermsDocument> {\n-    try {\n-      // 같은 타입의 기존 문서들의 최대 버전 찾기\n-      const existingDocs = await this.getTermsDocumentsByType(documentData.type);\n-      const maxVersion = existingDocs.length > 0 ? Math.max(...existingDocs.map(doc => doc.version)) : 0;\n-\n-      // 기존 활성 문서들 비활성화\n-      for (const doc of existingDocs.filter(d => d.isActive)) {\n-        await this.updateTermsDocument(doc.id, { isActive: false });\n-      }\n-\n-      const newDocument: TermsDocument = {\n-        ...documentData,\n-        id: this.generateUUID(),\n-        version: maxVersion + 1,\n-        createdAt: new Date(),\n-        updatedAt: new Date(),\n-        publishedAt: documentData.isActive ? new Date() : null\n-      };\n-\n-      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n-        store.add(newDocument)\n-      );\n-\n-      console.log('약관/문서 추가 성공:', newDocument);\n-      return newDocument;\n-    } catch (error) {\n-      console.error('약관/문서 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 모든 약관/문서 조회\n-   */\n-  async getAllTermsDocuments(): Promise<TermsDocument[]> {\n-    try {\n-      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n-        store.getAll()\n-      );\n-      \n-      return documents.map(doc => ({\n-        ...doc,\n-        createdAt: new Date(doc.createdAt),\n-        updatedAt: new Date(doc.updatedAt),\n-        publishedAt: doc.publishedAt ? new Date(doc.publishedAt) : null\n-      }));\n-    } catch (error) {\n-      console.error('약관/문서 목록 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * ID로 약관/문서 조회\n-   */\n-  async getTermsDocumentById(id: string): Promise<TermsDocument | null> {\n-    try {\n-      const document = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n-        store.get(id)\n-      );\n-      \n-      if (document) {\n-        return {\n-          ...document,\n-          createdAt: new Date(document.createdAt),\n-          updatedAt: new Date(document.updatedAt),\n-          publishedAt: document.publishedAt ? new Date(document.publishedAt) : null\n-        };\n-      }\n-      \n-      return null;\n-    } catch (error) {\n-      console.error('약관/문서 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 타입별 약관/문서 조회\n-   */\n-  async getTermsDocumentsByType(type: TermsDocument['type']): Promise<TermsDocument[]> {\n-    try {\n-      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => {\n-        return store.getAll();\n-      });\n-      \n-      const filteredDocs = documents.filter(doc => doc.type === type);\n-      \n-      return filteredDocs.map(doc => ({\n-        ...doc,\n-        createdAt: new Date(doc.createdAt),\n-        updatedAt: new Date(doc.updatedAt),\n-        publishedAt: doc.publishedAt ? new Date(doc.publishedAt) : null\n-      })).sort((a, b) => b.version - a.version); // 최신 버전부터\n-    } catch (error) {\n-      console.error('타입별 약관/문서 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 활성화된 약관/문서만 조회 (타입별)\n-   */\n-  async getActiveTermsDocument(type: TermsDocument['type']): Promise<TermsDocument | null> {\n-    try {\n-      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => {\n-        return store.getAll();\n-      });\n-      \n-      const activeDoc = documents.find(doc => doc.type === type && doc.isActive);\n-      \n-      if (!activeDoc) return null;\n-\n-      return {\n-        ...activeDoc,\n-        createdAt: new Date(activeDoc.createdAt),\n-        updatedAt: new Date(activeDoc.updatedAt),\n-        publishedAt: activeDoc.publishedAt ? new Date(activeDoc.publishedAt) : null\n-      };\n-    } catch (error) {\n-      console.error('활성 약관/문서 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 약관/문서 수정\n-   */\n-  async updateTermsDocument(id: string, updates: Partial<Omit<TermsDocument, 'id' | 'createdAt' | 'updatedAt' | 'version'>>): Promise<TermsDocument | null> {\n-    try {\n-      const existingDocument = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n-        store.get(id)\n-      );\n-\n-      if (!existingDocument) {\n-        console.error('수정할 약관/문서를 찾을 수 없습니다:', id);\n-        return null;\n-      }\n-\n-      // 활성화 시 같은 타입의 다른 문서들 비활성화\n-      if (updates.isActive === true && !existingDocument.isActive) {\n-        const otherDocs = await this.getTermsDocumentsByType(existingDocument.type);\n-        for (const doc of otherDocs.filter((d: TermsDocument) => d.id !== id && d.isActive)) {\n-          await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n-            store.put({\n-              ...doc,\n-              isActive: false,\n-              updatedAt: new Date()\n-            })\n-          );\n-        }\n-      }\n-\n-      const updatedDocument: TermsDocument = {\n-        ...existingDocument,\n-        ...updates,\n-        id,\n-        createdAt: new Date(existingDocument.createdAt),\n-        updatedAt: new Date(),\n-        publishedAt: updates.isActive === true && !existingDocument.isActive ? new Date() : \n-                    updates.isActive === false ? null : \n-                    existingDocument.publishedAt\n-      };\n-\n-      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n-        store.put(updatedDocument)\n-      );\n-\n-      console.log('약관/문서 수정 성공:', updatedDocument);\n-      return updatedDocument;\n-    } catch (error) {\n-      console.error('약관/문서 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 약관/문서 삭제\n-   */\n-  async deleteTermsDocument(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-\n-      console.log('약관/문서 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('약관/문서 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 약관/문서 검색 (제목, 내용)\n-   */\n-  async searchTermsDocuments(searchTerm: string): Promise<TermsDocument[]> {\n-    try {\n-      const allDocuments = await this.getAllTermsDocuments();\n-      const lowerSearchTerm = searchTerm.toLowerCase();\n-      \n-      return allDocuments.filter(doc => \n-        doc.title.toLowerCase().includes(lowerSearchTerm) ||\n-        doc.content.toLowerCase().includes(lowerSearchTerm)\n-      );\n-    } catch (error) {\n-      console.error('약관/문서 검색 실패:', error);\n-      return [];\n-    }\n-  }\n-}\n-\n-// 싱글톤 인스턴스 생성\n-export const dbManager = new IndexedDBManager();\n-\n-// 개발자 도구에서 사용할 수 있도록 전역 객체에 추가\n-if (typeof window !== 'undefined') {\n-  (window as any).dbManager = dbManager;\n-}\n"
                },
                {
                    "date": 1760255178512,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -344,28 +344,35 @@\n       const store = transaction.objectStore(storeName);\n       \n       // 트랜잭션 이벤트 리스너 추가\n       transaction.oncomplete = () => {\n-        console.log(`트랜잭션 완료: ${storeName}`);\n+        console.log(`✅ 트랜잭션 완료: ${storeName}`);\n       };\n       \n       transaction.onerror = (event) => {\n-        console.error(`트랜잭션 오류: ${storeName}`, event);\n+        console.error(`❌ 트랜잭션 오류: ${storeName}`, event);\n+        console.error('트랜잭션 에러 상세:', transaction.error);\n       };\n       \n       transaction.onabort = (event) => {\n-        console.error(`트랜잭션 중단: ${storeName}`, event);\n+        console.error(`❌ 트랜잭션 중단: ${storeName}`, event);\n+        console.error('트랜잭션 중단 사유:', transaction.error);\n       };\n       \n       const request = operation(store);\n \n       request.onsuccess = () => {\n-        console.log(`operation 성공: ${storeName}`);\n+        console.log(`✅ operation 성공: ${storeName}, 결과:`, request.result);\n         resolve(request.result);\n       };\n       \n       request.onerror = () => {\n-        console.error(`operation 실패: ${storeName}`, request.error);\n+        console.error(`❌ operation 실패: ${storeName}`, request.error);\n+        console.error('요청 에러 상세:', {\n+          error: request.error,\n+          errorCode: request.error?.name,\n+          errorMessage: request.error?.message\n+        });\n         reject(request.error);\n       };\n     });\n   }\n@@ -1797,9 +1804,17 @@\n       \n       console.log('트랜잭션 시작...');\n       await this.executeTransaction('members', 'readwrite', (store) => {\n         console.log('store.add 실행 중...');\n-        return store.add(member);\n+        console.log('추가할 멤버 객체:', member);\n+        try {\n+          const request = store.add(member);\n+          console.log('store.add 요청 생성됨');\n+          return request;\n+        } catch (storeError) {\n+          console.error('❌ store.add에서 즉시 에러:', storeError);\n+          throw storeError;\n+        }\n       });\n \n       console.log('✅ 회원 추가 성공:', member.id);\n       \n"
                },
                {
                    "date": 1760255779613,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1870,12 +1870,15 @@\n    * 전화번호로 회원 조회\n    */\n   async getMemberByPhone(phone: string): Promise<Member | null> {\n     try {\n-      return await this.executeTransaction('members', 'readonly', (store) => {\n+      const result = await this.executeTransaction('members', 'readonly', (store) => {\n         const index = store.index('phone');\n         return index.get(phone);\n-      }) || null;\n+      });\n+      \n+      // 활성 회원만 반환\n+      return (result && result.isActive) ? result : null;\n     } catch (error) {\n       console.error('전화번호로 회원 조회 실패:', error);\n       return null;\n     }\n@@ -1956,8 +1959,71 @@\n       return [];\n     }\n   }\n \n+  /**\n+   * 이메일로 회원 조회\n+   */\n+  async getMemberByEmail(email: string): Promise<Member | null> {\n+    try {\n+      // 이메일이 비어있으면 null 반환\n+      if (!email || email.trim() === '') {\n+        return null;\n+      }\n+\n+      // 모든 회원을 조회해서 이메일이 일치하는 회원 찾기 (대소문자 구분 없이)\n+      const allMembers = await this.getAllMembers();\n+      const member = allMembers.find(m => \n+        m.email.toLowerCase() === email.toLowerCase() && m.isActive\n+      );\n+      \n+      return member || null;\n+    } catch (error) {\n+      console.error('이메일로 회원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 회원 중복 체크 (연락처와 이메일)\n+   */\n+  async checkMemberDuplicate(phone: string, email?: string): Promise<{\n+    isDuplicate: boolean;\n+    duplicateField?: 'phone' | 'email';\n+    message?: string;\n+  }> {\n+    try {\n+      // 전화번호 중복 체크\n+      if (phone && phone.trim() !== '') {\n+        const existingByPhone = await this.getMemberByPhone(phone);\n+        if (existingByPhone) {\n+          return {\n+            isDuplicate: true,\n+            duplicateField: 'phone',\n+            message: `연락처 ${phone}는(은) 이미 등록된 회원입니다.`\n+          };\n+        }\n+      }\n+\n+      // 이메일 중복 체크 (이메일이 있는 경우만)\n+      if (email && email.trim() !== '') {\n+        const existingByEmail = await this.getMemberByEmail(email);\n+        if (existingByEmail) {\n+          return {\n+            isDuplicate: true,\n+            duplicateField: 'email',\n+            message: `이메일 ${email}는(은) 이미 등록된 회원입니다.`\n+          };\n+        }\n+      }\n+\n+      return { isDuplicate: false };\n+    } catch (error) {\n+      console.error('회원 중복 체크 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n   // ==================== 결제 관리 ====================\n \n   /**\n    * 결제 정보 추가\n"
                },
                {
                    "date": 1760256268353,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2022,8 +2022,69 @@\n       throw error;\n     }\n   }\n \n+  /**\n+   * 로그인 ID로 회원 조회\n+   */\n+  async getMemberByLoginId(loginId: string): Promise<Member | null> {\n+    try {\n+      // 로그인 ID가 비어있으면 null 반환\n+      if (!loginId || loginId.trim() === '') {\n+        return null;\n+      }\n+\n+      return await this.executeTransaction('members', 'readonly', (store) => {\n+        const index = store.index('loginId');\n+        return index.get(loginId);\n+      }) || null;\n+    } catch (error) {\n+      console.error('로그인 ID로 회원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 로그인 ID 중복 체크 (직원과 회원 모두 확인)\n+   */\n+  async checkLoginIdDuplicate(loginId: string): Promise<{\n+    isDuplicate: boolean;\n+    duplicateType?: 'staff' | 'member';\n+    message?: string;\n+  }> {\n+    try {\n+      // 로그인 ID가 비어있으면 중복 없음\n+      if (!loginId || loginId.trim() === '') {\n+        return { isDuplicate: false };\n+      }\n+\n+      // 직원 테이블에서 중복 검사\n+      const existingStaff = await this.getStaffByLoginId(loginId);\n+      if (existingStaff) {\n+        return {\n+          isDuplicate: true,\n+          duplicateType: 'staff',\n+          message: `로그인 ID ${loginId}는(은) 이미 직원으로 등록되어 있습니다.`\n+        };\n+      }\n+\n+      // 회원 테이블에서 중복 검사\n+      const existingMember = await this.getMemberByLoginId(loginId);\n+      if (existingMember) {\n+        return {\n+          isDuplicate: true,\n+          duplicateType: 'member',\n+          message: `로그인 ID ${loginId}는(은) 이미 회원으로 등록되어 있습니다.`\n+        };\n+      }\n+\n+      return { isDuplicate: false };\n+    } catch (error) {\n+      console.error('로그인 ID 중복 체크 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n   // ==================== 결제 관리 ====================\n \n   /**\n    * 결제 정보 추가\n"
                },
                {
                    "date": 1760257923520,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -100,10 +100,10 @@\n   branchName: string; // 조회 성능을 위해 저장\n   coach: string; // 담당 코치 ID\n   coachName: string; // 조회 성능을 위해 저장\n   joinPath: string;\n-  loginId: string;\n-  loginPassword: string;\n+  loginId: string; // 로그인 ID (공란일 때는 임시값 생성)\n+  loginPassword: string | null; // 로그인 비밀번호 (공란 가능)\n   enableLogin: boolean;\n   agreementInfo: {\n     agreements: Array<{\n       id: string;\n@@ -2051,10 +2051,10 @@\n     duplicateType?: 'staff' | 'member';\n     message?: string;\n   }> {\n     try {\n-      // 로그인 ID가 비어있으면 중복 없음\n-      if (!loginId || loginId.trim() === '') {\n+      // 로그인 ID가 비어있거나 임시 ID이면 중복 없음\n+      if (!loginId || loginId.trim() === '' || loginId.startsWith('temp_')) {\n         return { isDuplicate: false };\n       }\n \n       // 직원 테이블에서 중복 검사\n@@ -2068,9 +2068,9 @@\n       }\n \n       // 회원 테이블에서 중복 검사\n       const existingMember = await this.getMemberByLoginId(loginId);\n-      if (existingMember) {\n+      if (existingMember && !existingMember.loginId.startsWith('temp_')) {\n         return {\n           isDuplicate: true,\n           duplicateType: 'member',\n           message: `로그인 ID ${loginId}는(은) 이미 회원으로 등록되어 있습니다.`\n"
                },
                {
                    "date": 1760755500691,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -153,8 +153,9 @@\n class IndexedDBManager {\n   private dbName: string = 'LavidaDB';\n   private version: number = 9; // 버전 업데이트 (Member, Payment 테이블 추가)\n   private db: IDBDatabase | null = null;\n+  private isInitializing: boolean = false; // 단순한 플래그로 변경\n \n   constructor() {\n     this.initDB();\n   }\n@@ -162,25 +163,57 @@\n   /**\n    * IndexedDB 초기화\n    */\n   private async initDB(): Promise<void> {\n-    return new Promise((resolve, reject) => {\n-      const request = indexedDB.open(this.dbName, this.version);\n+    // 이미 초기화되었으면 바로 반환\n+    if (this.db) {\n+      console.log('IndexedDB가 이미 연결되어 있습니다.');\n+      return Promise.resolve();\n+    }\n \n-      request.onerror = () => {\n-        console.error('IndexedDB 열기 실패:', request.error);\n-        reject(request.error);\n-      };\n+    // 이미 초기화 중이면 대기\n+    if (this.isInitializing) {\n+      console.log('IndexedDB 초기화가 이미 진행 중입니다. 대기 중...');\n+      // 최대 5초까지 대기\n+      for (let i = 0; i < 50; i++) {\n+        await new Promise(resolve => setTimeout(resolve, 100));\n+        if (this.db) {\n+          return;\n+        }\n+      }\n+      throw new Error('IndexedDB 초기화 대기 시간 초과');\n+    }\n \n-      request.onsuccess = () => {\n-        this.db = request.result;\n-        console.log('IndexedDB 연결 성공');\n-        resolve();\n-      };\n+    console.log('IndexedDB 초기화를 시작합니다...');\n+    this.isInitializing = true;\n+    \n+    try {\n+      await new Promise<void>((resolve, reject) => {\n+        const request = indexedDB.open(this.dbName, this.version);\n \n-      request.onupgradeneeded = (event) => {\n-        const db = (event.target as IDBOpenDBRequest).result;\n+        request.onerror = () => {\n+          console.error('❌ IndexedDB 열기 실패:', request.error);\n+          this.isInitializing = false;\n+          reject(request.error);\n+        };\n \n+        request.onsuccess = () => {\n+          this.db = request.result;\n+          console.log('✅ IndexedDB 연결 성공');\n+          \n+          // DB 연결 오류 핸들러 설정\n+          this.db.onerror = (event) => {\n+            console.error('IndexedDB 오류:', event);\n+          };\n+          \n+          this.isInitializing = false;\n+          resolve();\n+        };\n+\n+        request.onupgradeneeded = (event) => {\n+          console.log('🔄 IndexedDB 스키마 업데이트 중...');\n+          const db = (event.target as IDBOpenDBRequest).result;\n+\n         // 지점 테이블 생성\n         if (!db.objectStoreNames.contains('branches')) {\n           const branchStore = db.createObjectStore('branches', { keyPath: 'id' });\n           branchStore.createIndex('name', 'name', { unique: true }); // 지점명 고유 제약\n@@ -308,10 +341,15 @@\n         }\n \n         // 향후 다른 테이블들도 여기에 추가 가능\n         // 예: 회원, 방문기록 등\n-      };\n-    });\n+        };\n+      });\n+    } catch (error) {\n+      console.error('❌ IndexedDB 초기화 중 오류:', error);\n+      this.isInitializing = false;\n+      throw error;\n+    }\n   }\n \n   /**\n    * 고유 ID 생성 (UUID v4 형식)\n@@ -331,50 +369,52 @@\n     storeName: string,\n     mode: IDBTransactionMode,\n     operation: (store: IDBObjectStore) => IDBRequest<T>\n   ): Promise<T> {\n+    // DB가 없으면 최대 3번 초기화 시도\n     if (!this.db) {\n-      console.log('executeTransaction: DB가 없어서 초기화 시도');\n-      await this.initDB();\n+      for (let attempt = 1; attempt <= 3; attempt++) {\n+        try {\n+          await this.initDB();\n+          if (this.db) break;\n+        } catch (error) {\n+          if (attempt === 3) {\n+            throw new Error(`IndexedDB 초기화 실패 (${attempt}번 시도): ${error}`);\n+          }\n+          await new Promise(resolve => setTimeout(resolve, 100 * attempt));\n+        }\n+      }\n     }\n+    \n+    if (!this.db) {\n+      throw new Error('IndexedDB 연결에 실패했습니다');\n+    }\n \n     return new Promise((resolve, reject) => {\n-      console.log(`executeTransaction 시작: store=${storeName}, mode=${mode}`);\n-      \n-      const transaction = this.db!.transaction([storeName], mode);\n-      const store = transaction.objectStore(storeName);\n-      \n-      // 트랜잭션 이벤트 리스너 추가\n-      transaction.oncomplete = () => {\n-        console.log(`✅ 트랜잭션 완료: ${storeName}`);\n-      };\n-      \n-      transaction.onerror = (event) => {\n-        console.error(`❌ 트랜잭션 오류: ${storeName}`, event);\n-        console.error('트랜잭션 에러 상세:', transaction.error);\n-      };\n-      \n-      transaction.onabort = (event) => {\n-        console.error(`❌ 트랜잭션 중단: ${storeName}`, event);\n-        console.error('트랜잭션 중단 사유:', transaction.error);\n-      };\n-      \n-      const request = operation(store);\n+      try {\n+        const transaction = this.db!.transaction([storeName], mode);\n+        const store = transaction.objectStore(storeName);\n+        \n+        transaction.onerror = () => {\n+          reject(transaction.error || new Error('트랜잭션 오류'));\n+        };\n+        \n+        transaction.onabort = () => {\n+          reject(new Error('트랜잭션이 중단되었습니다'));\n+        };\n \n-      request.onsuccess = () => {\n-        console.log(`✅ operation 성공: ${storeName}, 결과:`, request.result);\n-        resolve(request.result);\n-      };\n-      \n-      request.onerror = () => {\n-        console.error(`❌ operation 실패: ${storeName}`, request.error);\n-        console.error('요청 에러 상세:', {\n-          error: request.error,\n-          errorCode: request.error?.name,\n-          errorMessage: request.error?.message\n-        });\n-        reject(request.error);\n-      };\n+        const request = operation(store);\n+        \n+        request.onsuccess = () => {\n+          resolve(request.result);\n+        };\n+        \n+        request.onerror = () => {\n+          reject(request.error || new Error('요청 오류'));\n+        };\n+      } catch (error) {\n+        reject(error);\n+      }\n     });\n   }\n \n   // === 지점 관리 메서드들 ===\n"
                },
                {
                    "date": 1760757228111,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,2511 @@\n+/**\n+ * IndexedDB를 활용한 로컬 데이터베이스 관리 유틸리티\n+ * 백엔드 연결 전까지 브라우저에서 데이터를 영구 저장\n+ */\n+\n+import { SYSTEM_ADMIN_CONFIG } from '../constants/staffConstants';\n+\n+export interface DBRecord {\n+  id: string;\n+  createdAt: Date;\n+  updatedAt: Date;\n+}\n+\n+export interface Branch extends DBRecord {\n+  name: string;\n+  address?: string;\n+  phone?: string;\n+  isActive: boolean;\n+}\n+\n+export interface AppSettings extends DBRecord {\n+  key: string;\n+  value: string;\n+}\n+\n+export interface Staff extends DBRecord {\n+  name: string;\n+  loginId: string; // 로그인 ID\n+  password: string; // 비밀번호\n+  phone: string;\n+  email: string;\n+  branchId: string;\n+  position: string; // 직급\n+  role: string; // 직책\n+  employmentType: string; // 고용형태\n+  permission: string; // 권한\n+  program?: string; // 담당프로그램 (코치일 경우만)\n+  contractStartDate: Date;\n+  contractEndDate?: Date | null; // 계약종료일 (정규직은 없을 수 있음)\n+  contractFile?: File | null; // 계약서 파일\n+  contractFileName?: string; // 계약서 파일명 저장용\n+  contractFileData?: ArrayBuffer; // 계약서 파일 데이터 저장용\n+  workingHours?: {\n+    start: number; // 기본 근무 시작 시간 (시)\n+    end: number; // 기본 근무 종료 시간 (시)\n+  };\n+  isActive: boolean; // 활성/비활성 상태\n+}\n+\n+export interface Program extends DBRecord {\n+  name: string;\n+  type: string; // '횟수제' | '기간제'\n+  isActive: boolean;\n+}\n+\n+export interface Product extends DBRecord {\n+  name: string;\n+  branchId: string;\n+  programId: string;\n+  programName: string; // 프로그램명 저장 (조회 성능 향상)\n+  programType: string; // 프로그램 종류 저장 (조회 성능 향상)\n+  sessions?: number; // 횟수 (횟수제인 경우에만 필요)\n+  duration?: number; // 소요시간 (분 단위, 횟수제인 경우에만 필요)\n+  price?: number; // 가격\n+  description?: string; // 상품소개\n+  isActive: boolean;\n+}\n+\n+export interface HolidaySettings extends DBRecord {\n+  staffId: string;\n+  date: string; // YYYY-MM-DD 형식\n+  isHoliday: boolean; // true: 휴일, false: 근무일\n+  workingHours?: {\n+    start: number;\n+    end: number;\n+  }; // 해당 날짜의 근무시간 (휴일이 아닌 경우)\n+}\n+\n+export interface TermsDocument extends DBRecord {\n+  type: 'privacy_policy' | 'terms_of_service' | 'business_info' | 'marketing_consent' | 'member_terms' | 'contract';\n+  title: string;\n+  content: string;\n+  version: number; // 버전 관리\n+  isActive: boolean;\n+  publishedAt?: Date | null; // 발행일\n+}\n+\n+export interface Member extends DBRecord {\n+  name: string;\n+  phone: string;\n+  email: string;\n+  birth: string;\n+  gender: 'male' | 'female' | '';\n+  address: string;\n+  sigunguCode: string;\n+  dong: string;\n+  roadAddress: string;\n+  jibunAddress: string;\n+  branchId: string;\n+  branchName: string; // 조회 성능을 위해 저장\n+  coach: string; // 담당 코치 ID\n+  coachName: string; // 조회 성능을 위해 저장\n+  joinPath: string;\n+  loginId: string; // 로그인 ID (공란일 때는 임시값 생성)\n+  loginPassword: string | null; // 로그인 비밀번호 (공란 가능)\n+  enableLogin: boolean;\n+  agreementInfo: {\n+    agreements: Array<{\n+      id: string;\n+      title: string;\n+      content: string;\n+      required: boolean;\n+      agreed: boolean;\n+    }>;\n+    customerSignature: string;\n+    staffSignature: string;\n+  };\n+  isActive: boolean;\n+  // 추가 회원 정보 필드들\n+  registrationDate: string;\n+  agreementDate: string;\n+  signatureData: string;\n+  membershipType: string;\n+  duration: number;\n+  durationUnit: string;\n+  startDate: string;\n+  endDate: string;\n+  monthlyFee: number;\n+  totalAmount: number;\n+  discountAmount: number;\n+  finalAmount: number;\n+  paymentMethod: string;\n+  paymentDate: string;\n+  remarks: string;\n+}\n+\n+export interface Payment extends DBRecord {\n+  memberId: string;\n+  memberName: string; // 조회 성능을 위해 저장\n+  products: Array<{\n+    id: string;\n+    name: string;\n+    price: number;\n+    description?: string;\n+  }>;\n+  totalAmount: number;\n+  receivedAmount?: number; // 받은 금액\n+  paymentStatus: 'pending' | 'completed' | 'cancelled' | 'refunded' | 'unpaid'; // '미수' 상태 추가\n+  paymentMethod?: string;\n+  paymentDate?: Date | null;\n+  notes?: string;\n+}\n+\n+export interface Point extends DBRecord {\n+  memberId: string;\n+  memberName: string; // 조회 성능을 위해 저장\n+  amount: number; // 포인트 금액 (양수: 적립, 음수: 사용)\n+  type: 'earned' | 'used' | 'expired' | 'adjusted'; // 적립, 사용, 만료, 조정\n+  source: string; // 포인트 발생 출처 (예: '회원등록 초과금', '상품구매', '포인트사용' 등)\n+  description?: string; // 상세 설명\n+  expiryDate?: Date | null; // 만료일 (적립된 포인트의 경우)\n+  relatedPaymentId?: string; // 연관된 결제 ID (있는 경우)\n+}\n+\n+class IndexedDBManager {\n+  private dbName: string = 'LavidaDB';\n+  private version: number = 10; // 버전 업데이트 (Point 테이블 추가, Payment 테이블 필드 추가)\n+  private db: IDBDatabase | null = null;\n+  private isInitializing: boolean = false; // 단순한 플래그로 변경\n+\n+  constructor() {\n+    this.initDB();\n+  }\n+\n+  /**\n+   * IndexedDB 초기화\n+   */\n+  private async initDB(): Promise<void> {\n+    // 이미 초기화되었으면 바로 반환\n+    if (this.db) {\n+      console.log('IndexedDB가 이미 연결되어 있습니다.');\n+      return Promise.resolve();\n+    }\n+\n+    // 이미 초기화 중이면 대기\n+    if (this.isInitializing) {\n+      console.log('IndexedDB 초기화가 이미 진행 중입니다. 대기 중...');\n+      // 최대 5초까지 대기\n+      for (let i = 0; i < 50; i++) {\n+        await new Promise(resolve => setTimeout(resolve, 100));\n+        if (this.db) {\n+          return;\n+        }\n+      }\n+      throw new Error('IndexedDB 초기화 대기 시간 초과');\n+    }\n+\n+    console.log('IndexedDB 초기화를 시작합니다...');\n+    this.isInitializing = true;\n+    \n+    try {\n+      await new Promise<void>((resolve, reject) => {\n+        const request = indexedDB.open(this.dbName, this.version);\n+\n+        request.onerror = () => {\n+          console.error('❌ IndexedDB 열기 실패:', request.error);\n+          this.isInitializing = false;\n+          reject(request.error);\n+        };\n+\n+        request.onsuccess = () => {\n+          this.db = request.result;\n+          console.log('✅ IndexedDB 연결 성공');\n+          \n+          // DB 연결 오류 핸들러 설정\n+          this.db.onerror = (event) => {\n+            console.error('IndexedDB 오류:', event);\n+          };\n+          \n+          this.isInitializing = false;\n+          resolve();\n+        };\n+\n+        request.onupgradeneeded = (event) => {\n+          console.log('🔄 IndexedDB 스키마 업데이트 중...');\n+          const db = (event.target as IDBOpenDBRequest).result;\n+\n+        // 지점 테이블 생성\n+        if (!db.objectStoreNames.contains('branches')) {\n+          const branchStore = db.createObjectStore('branches', { keyPath: 'id' });\n+          branchStore.createIndex('name', 'name', { unique: true }); // 지점명 고유 제약\n+          branchStore.createIndex('isActive', 'isActive', { unique: false });\n+          branchStore.createIndex('createdAt', 'createdAt', { unique: false });\n+        } else {\n+          // 기존 테이블이 있으면 인덱스 업데이트\n+          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n+          const branchStore = transaction.objectStore('branches');\n+          \n+          // 기존 name 인덱스 삭제 후 unique로 재생성\n+          if (branchStore.indexNames.contains('name')) {\n+            branchStore.deleteIndex('name');\n+          }\n+          branchStore.createIndex('name', 'name', { unique: true });\n+        }\n+\n+        // 직원 테이블 생성\n+        if (!db.objectStoreNames.contains('staff')) {\n+          const staffStore = db.createObjectStore('staff', { keyPath: 'id' });\n+          staffStore.createIndex('name', 'name', { unique: false });\n+          staffStore.createIndex('loginId', 'loginId', { unique: true });\n+          staffStore.createIndex('email', 'email', { unique: true });\n+          staffStore.createIndex('branchId', 'branchId', { unique: false });\n+          staffStore.createIndex('position', 'position', { unique: false });\n+          staffStore.createIndex('role', 'role', { unique: false });\n+          staffStore.createIndex('employmentType', 'employmentType', { unique: false });\n+          staffStore.createIndex('permission', 'permission', { unique: false });\n+          staffStore.createIndex('isActive', 'isActive', { unique: false });\n+          staffStore.createIndex('createdAt', 'createdAt', { unique: false });\n+        } else {\n+          // 기존 테이블이 있으면 인덱스 업데이트 (isActive 인덱스 추가)\n+          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n+          const staffStore = transaction.objectStore('staff');\n+          \n+          if (!staffStore.indexNames.contains('isActive')) {\n+            staffStore.createIndex('isActive', 'isActive', { unique: false });\n+          }\n+        }\n+\n+        // 프로그램 테이블 생성\n+        if (!db.objectStoreNames.contains('programs')) {\n+          const programStore = db.createObjectStore('programs', { keyPath: 'id' });\n+          programStore.createIndex('name', 'name', { unique: true }); // 프로그램명 고유 제약\n+          programStore.createIndex('type', 'type', { unique: false });\n+          programStore.createIndex('isActive', 'isActive', { unique: false });\n+          programStore.createIndex('createdAt', 'createdAt', { unique: false });\n+        } else {\n+          // 기존 테이블이 있으면 인덱스 업데이트\n+          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n+          const programStore = transaction.objectStore('programs');\n+          \n+          // 기존 name 인덱스 삭제 후 unique로 재생성\n+          if (programStore.indexNames.contains('name')) {\n+            programStore.deleteIndex('name');\n+          }\n+          programStore.createIndex('name', 'name', { unique: true });\n+        }\n+\n+        // 상품 테이블 생성\n+        if (!db.objectStoreNames.contains('products')) {\n+          const productStore = db.createObjectStore('products', { keyPath: 'id' });\n+          productStore.createIndex('name', 'name', { unique: false });\n+          productStore.createIndex('branchId', 'branchId', { unique: false });\n+          productStore.createIndex('programId', 'programId', { unique: false });\n+          productStore.createIndex('programType', 'programType', { unique: false });\n+          productStore.createIndex('isActive', 'isActive', { unique: false });\n+          productStore.createIndex('createdAt', 'createdAt', { unique: false });\n+          // 복합 인덱스: 지점별, 프로그램별 조회 최적화\n+          productStore.createIndex('branchProgram', ['branchId', 'programId'], { unique: false });\n+        }\n+\n+        // 휴일설정 테이블 생성\n+        if (!db.objectStoreNames.contains('holidaySettings')) {\n+          const holidayStore = db.createObjectStore('holidaySettings', { keyPath: 'id' });\n+          holidayStore.createIndex('staffId', 'staffId', { unique: false });\n+          holidayStore.createIndex('date', 'date', { unique: false });\n+          holidayStore.createIndex('isHoliday', 'isHoliday', { unique: false });\n+          // 복합 인덱스: 직원별, 날짜별 조회 최적화\n+          holidayStore.createIndex('staffDate', ['staffId', 'date'], { unique: true });\n+        }\n+\n+        // 약관/문서 테이블 생성\n+        if (!db.objectStoreNames.contains('termsDocuments')) {\n+          const termsStore = db.createObjectStore('termsDocuments', { keyPath: 'id' });\n+          termsStore.createIndex('type', 'type', { unique: false });\n+          termsStore.createIndex('language', 'language', { unique: false });\n+          termsStore.createIndex('title', 'title', { unique: false });\n+          termsStore.createIndex('version', 'version', { unique: false });\n+          termsStore.createIndex('isActive', 'isActive', { unique: false });\n+          termsStore.createIndex('publishedAt', 'publishedAt', { unique: false });\n+          termsStore.createIndex('createdAt', 'createdAt', { unique: false });\n+          // 복합 인덱스: 타입별, 언어별 조회 최적화\n+          termsStore.createIndex('typeLanguage', ['type', 'language'], { unique: false });\n+          // 활성 상태 및 최신 버전 조회 최적화\n+          termsStore.createIndex('typeLanguageActive', ['type', 'language', 'isActive'], { unique: false });\n+        }\n+\n+        // 회원 테이블 생성\n+        if (!db.objectStoreNames.contains('members')) {\n+          const memberStore = db.createObjectStore('members', { keyPath: 'id' });\n+          memberStore.createIndex('name', 'name', { unique: false });\n+          memberStore.createIndex('phone', 'phone', { unique: true }); // 전화번호는 고유\n+          memberStore.createIndex('email', 'email', { unique: false });\n+          memberStore.createIndex('branchId', 'branchId', { unique: false });\n+          memberStore.createIndex('coach', 'coach', { unique: false });\n+          memberStore.createIndex('loginId', 'loginId', { unique: true }); // 로그인 ID는 고유\n+          memberStore.createIndex('isActive', 'isActive', { unique: false });\n+          memberStore.createIndex('createdAt', 'createdAt', { unique: false });\n+          // 복합 인덱스: 지점별 회원 조회 최적화\n+          memberStore.createIndex('branchActive', ['branchId', 'isActive'], { unique: false });\n+        }\n+\n+        // 결제 테이블 생성\n+        if (!db.objectStoreNames.contains('payments')) {\n+          const paymentStore = db.createObjectStore('payments', { keyPath: 'id' });\n+          paymentStore.createIndex('memberId', 'memberId', { unique: false });\n+          paymentStore.createIndex('memberName', 'memberName', { unique: false });\n+          paymentStore.createIndex('paymentStatus', 'paymentStatus', { unique: false });\n+          paymentStore.createIndex('paymentDate', 'paymentDate', { unique: false });\n+          paymentStore.createIndex('totalAmount', 'totalAmount', { unique: false });\n+          paymentStore.createIndex('receivedAmount', 'receivedAmount', { unique: false });\n+          paymentStore.createIndex('createdAt', 'createdAt', { unique: false });\n+          // 복합 인덱스: 회원별 결제 조회 최적화\n+          paymentStore.createIndex('memberStatus', ['memberId', 'paymentStatus'], { unique: false });\n+        } else {\n+          // 기존 결제 테이블에 새 인덱스 추가 (receivedAmount)\n+          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n+          const paymentStore = transaction.objectStore('payments');\n+          \n+          if (!paymentStore.indexNames.contains('receivedAmount')) {\n+            paymentStore.createIndex('receivedAmount', 'receivedAmount', { unique: false });\n+          }\n+        }\n+\n+        // 포인트 테이블 생성\n+        if (!db.objectStoreNames.contains('points')) {\n+          const pointStore = db.createObjectStore('points', { keyPath: 'id' });\n+          pointStore.createIndex('memberId', 'memberId', { unique: false });\n+          pointStore.createIndex('memberName', 'memberName', { unique: false });\n+          pointStore.createIndex('type', 'type', { unique: false });\n+          pointStore.createIndex('source', 'source', { unique: false });\n+          pointStore.createIndex('amount', 'amount', { unique: false });\n+          pointStore.createIndex('expiryDate', 'expiryDate', { unique: false });\n+          pointStore.createIndex('relatedPaymentId', 'relatedPaymentId', { unique: false });\n+          pointStore.createIndex('createdAt', 'createdAt', { unique: false });\n+          // 복합 인덱스: 회원별 포인트 조회 최적화\n+          pointStore.createIndex('memberType', ['memberId', 'type'], { unique: false });\n+          // 만료되지 않은 포인트 조회 최적화\n+          pointStore.createIndex('memberActive', ['memberId', 'expiryDate'], { unique: false });\n+        }\n+\n+        // 향후 다른 테이블들도 여기에 추가 가능\n+        // 예: 회원, 방문기록 등\n+        };\n+      });\n+    } catch (error) {\n+      console.error('❌ IndexedDB 초기화 중 오류:', error);\n+      this.isInitializing = false;\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 고유 ID 생성 (UUID v4 형식)\n+   */\n+  private generateUUID(): string {\n+    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n+      const r = Math.random() * 16 | 0;\n+      const v = c === 'x' ? r : ((r & 0x3) | 0x8);\n+      return v.toString(16);\n+    });\n+  }\n+\n+  /**\n+   * 트랜잭션 실행 헬퍼\n+   */\n+  private async executeTransaction<T>(\n+    storeName: string,\n+    mode: IDBTransactionMode,\n+    operation: (store: IDBObjectStore) => IDBRequest<T>\n+  ): Promise<T> {\n+    // DB가 없으면 최대 3번 초기화 시도\n+    if (!this.db) {\n+      for (let attempt = 1; attempt <= 3; attempt++) {\n+        try {\n+          await this.initDB();\n+          if (this.db) break;\n+        } catch (error) {\n+          if (attempt === 3) {\n+            throw new Error(`IndexedDB 초기화 실패 (${attempt}번 시도): ${error}`);\n+          }\n+          await new Promise(resolve => setTimeout(resolve, 100 * attempt));\n+        }\n+      }\n+    }\n+    \n+    if (!this.db) {\n+      throw new Error('IndexedDB 연결에 실패했습니다');\n+    }\n+\n+    return new Promise((resolve, reject) => {\n+      try {\n+        const transaction = this.db!.transaction([storeName], mode);\n+        const store = transaction.objectStore(storeName);\n+        \n+        transaction.onerror = () => {\n+          reject(transaction.error || new Error('트랜잭션 오류'));\n+        };\n+        \n+        transaction.onabort = () => {\n+          reject(new Error('트랜잭션이 중단되었습니다'));\n+        };\n+\n+        const request = operation(store);\n+        \n+        request.onsuccess = () => {\n+          resolve(request.result);\n+        };\n+        \n+        request.onerror = () => {\n+          reject(request.error || new Error('요청 오류'));\n+        };\n+      } catch (error) {\n+        reject(error);\n+      }\n+    });\n+  }\n+\n+  // === 지점 관리 메서드들 ===\n+\n+  /**\n+   * 모든 지점 조회\n+   */\n+  async getAllBranches(): Promise<Branch[]> {\n+    try {\n+      return await this.executeTransaction('branches', 'readonly', (store) => \n+        store.getAll()\n+      );\n+    } catch (error) {\n+      console.error('지점 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * ID로 지점 조회\n+   */\n+  async getBranchById(id: string): Promise<Branch | null> {\n+    try {\n+      const result = await this.executeTransaction('branches', 'readonly', (store) => \n+        store.get(id)\n+      );\n+      return result || null;\n+    } catch (error) {\n+      console.error('지점 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 지점 추가\n+   */\n+  async addBranch(branchData: Omit<Branch, 'id' | 'createdAt' | 'updatedAt'>): Promise<Branch> {\n+    const now = new Date();\n+    const newBranch: Branch = {\n+      ...branchData,\n+      id: this.generateUUID(),\n+      createdAt: now,\n+      updatedAt: now,\n+    };\n+\n+    try {\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.add(newBranch)\n+      );\n+      console.log('지점 추가 성공:', newBranch);\n+      return newBranch;\n+    } catch (error) {\n+      console.error('지점 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 지점 수정\n+   */\n+  async updateBranch(id: string, updates: Partial<Omit<Branch, 'id' | 'createdAt'>>): Promise<Branch | null> {\n+    try {\n+      const existing = await this.getBranchById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 지점입니다.');\n+      }\n+\n+      const updatedBranch: Branch = {\n+        ...existing,\n+        ...updates,\n+        updatedAt: new Date(),\n+      };\n+\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.put(updatedBranch)\n+      );\n+\n+      console.log('지점 수정 성공:', updatedBranch);\n+      return updatedBranch;\n+    } catch (error) {\n+      console.error('지점 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 지점 삭제\n+   */\n+  async deleteBranch(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+      console.log('지점 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('지점 삭제 실패:', error);\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * 활성 지점만 조회\n+   */\n+  async getActiveBranches(): Promise<Branch[]> {\n+    try {\n+      return await this.executeTransaction('branches', 'readonly', (store) => {\n+        const index = store.index('isActive');\n+        return index.getAll(IDBKeyRange.only(true));\n+      });\n+    } catch (error) {\n+      console.error('활성 지점 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 지점명으로 정확히 일치하는 지점 조회 또는 생성 (원자적 처리)\n+   * 동시 실행 시 race condition 방지\n+   */\n+  async getOrCreateBranchByName(name: string, branchData?: Omit<Branch, 'id' | 'createdAt' | 'updatedAt' | 'name'>): Promise<Branch> {\n+    if (!this.db) {\n+      await this.initDB();\n+    }\n+\n+    return new Promise((resolve, reject) => {\n+      const transaction = this.db!.transaction(['branches'], 'readwrite');\n+      const store = transaction.objectStore('branches');\n+      const index = store.index('name');\n+      \n+      // 먼저 기존 지점 확인\n+      const getRequest = index.get(name);\n+      \n+      getRequest.onsuccess = () => {\n+        if (getRequest.result) {\n+          // 이미 존재함\n+          resolve(getRequest.result);\n+        } else {\n+          // 존재하지 않음, 새로 생성\n+          const now = new Date();\n+          const newBranch: Branch = {\n+            name,\n+            address: branchData?.address || '',\n+            phone: branchData?.phone || '',\n+            isActive: branchData?.isActive ?? true,\n+            id: this.generateUUID(),\n+            createdAt: now,\n+            updatedAt: now,\n+          };\n+\n+          const addRequest = store.add(newBranch);\n+          addRequest.onsuccess = () => {\n+            console.log('새 지점 생성 완료:', newBranch);\n+            resolve(newBranch);\n+          };\n+          addRequest.onerror = () => {\n+            console.error('지점 추가 실패:', addRequest.error);\n+            reject(addRequest.error);\n+          };\n+        }\n+      };\n+      \n+      getRequest.onerror = () => {\n+        console.error('지점 조회 실패:', getRequest.error);\n+        reject(getRequest.error);\n+      };\n+    });\n+  }\n+\n+  /**\n+   * 지점명으로 정확히 일치하는 지점 조회\n+   */\n+  async getBranchByName(name: string): Promise<Branch | null> {\n+    try {\n+      const allBranches = await this.getAllBranches();\n+      const branch = allBranches.find(branch => branch.name === name);\n+      return branch || null;\n+    } catch (error) {\n+      console.error('지점명으로 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 지점명으로 검색\n+   */\n+  async searchBranchesByName(name: string): Promise<Branch[]> {\n+    try {\n+      const allBranches = await this.getAllBranches();\n+      return allBranches.filter(branch => \n+        branch.name.toLowerCase().includes(name.toLowerCase())\n+      );\n+    } catch (error) {\n+      console.error('지점 검색 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  // === 직원 관리 메서드들 ===\n+\n+  /**\n+   * 모든 직원 조회\n+   */\n+  async getAllStaff(): Promise<Staff[]> {\n+    try {\n+      const staffList = await this.executeTransaction('staff', 'readonly', (store) => \n+        store.getAll()\n+      );\n+\n+      // 저장된 파일 데이터를 File 객체로 복원\n+      return staffList.map(staff => {\n+        if (staff.contractFileData && staff.contractFileName) {\n+          // 파일 확장자로부터 MIME 타입 추정\n+          const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n+          let mimeType = 'application/octet-stream';\n+          \n+          if (extension === 'pdf') {\n+            mimeType = 'application/pdf';\n+          } else if (['jpg', 'jpeg'].includes(extension || '')) {\n+            mimeType = 'image/jpeg';\n+          } else if (extension === 'png') {\n+            mimeType = 'image/png';\n+          }\n+\n+          staff.contractFile = this.arrayBufferToFile(\n+            staff.contractFileData, \n+            staff.contractFileName, \n+            mimeType\n+          );\n+        }\n+        return staff;\n+      });\n+    } catch (error) {\n+      console.error('직원 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * ID로 직원 조회\n+   */\n+  async getStaffById(id: string): Promise<Staff | null> {\n+    try {\n+      const staff = await this.executeTransaction('staff', 'readonly', (store) => \n+        store.get(id)\n+      );\n+\n+      if (!staff) return null;\n+\n+      // 저장된 파일 데이터를 File 객체로 복원\n+      if (staff.contractFileData && staff.contractFileName) {\n+        const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n+        let mimeType = 'application/octet-stream';\n+        \n+        if (extension === 'pdf') {\n+          mimeType = 'application/pdf';\n+        } else if (['jpg', 'jpeg'].includes(extension || '')) {\n+          mimeType = 'image/jpeg';\n+        } else if (extension === 'png') {\n+          mimeType = 'image/png';\n+        }\n+\n+        staff.contractFile = this.arrayBufferToFile(\n+          staff.contractFileData, \n+          staff.contractFileName, \n+          mimeType\n+        );\n+      }\n+\n+      return staff;\n+    } catch (error) {\n+      console.error('직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 직원 추가\n+   */\n+  async addStaff(staffData: Omit<Staff, 'id' | 'createdAt' | 'updatedAt'>): Promise<Staff> {\n+    const now = new Date();\n+    \n+    // 파일 데이터 처리\n+    let contractFileData: ArrayBuffer | undefined;\n+    let contractFileName: string | undefined;\n+    \n+    if (staffData.contractFile) {\n+      contractFileData = await this.fileToArrayBuffer(staffData.contractFile);\n+      contractFileName = staffData.contractFile.name;\n+    }\n+\n+    const newStaff: Staff = {\n+      ...staffData,\n+      id: this.generateUUID(),\n+      createdAt: now,\n+      updatedAt: now,\n+      isActive: staffData.isActive !== undefined ? staffData.isActive : true, // 기본값 true\n+      contractFile: undefined, // File 객체는 저장하지 않음\n+      contractFileName,\n+      contractFileData,\n+    };\n+\n+    try {\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.add(newStaff)\n+      );\n+      console.log('직원 추가 성공:', newStaff);\n+      return newStaff;\n+    } catch (error) {\n+      console.error('직원 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 시스템 관리자 계정인지 확인\n+   */\n+  private isSystemAdmin(staff: Staff): boolean {\n+    return staff.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID;\n+  }\n+\n+  /**\n+   * 시스템 관리자 보호 검증\n+   */\n+  private validateSystemAdminProtection(staff: Staff, operation: 'delete' | 'permission_change'): void {\n+    if (this.isSystemAdmin(staff)) {\n+      const message = operation === 'delete' \n+        ? '시스템 관리자 계정은 삭제할 수 없습니다.'\n+        : '시스템 관리자 계정의 권한은 변경할 수 없습니다.';\n+      throw new Error(message);\n+    }\n+  }\n+\n+  /**\n+   * 직원 수정\n+   */\n+  async updateStaff(id: string, updates: Partial<Omit<Staff, 'id' | 'createdAt'>>): Promise<Staff | null> {\n+    try {\n+      const existing = await this.getStaffById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 직원입니다.');\n+      }\n+\n+      // 시스템 관리자 권한 변경 보호\n+      if (updates.permission && updates.permission !== existing.permission) {\n+        this.validateSystemAdminProtection(existing, 'permission_change');\n+      }\n+\n+      // 파일 데이터 처리\n+      let contractFileData = existing.contractFileData;\n+      let contractFileName = existing.contractFileName;\n+      \n+      if (updates.contractFile) {\n+        contractFileData = await this.fileToArrayBuffer(updates.contractFile);\n+        contractFileName = updates.contractFile.name;\n+      }\n+\n+      const updatedStaff: Staff = {\n+        ...existing,\n+        ...updates,\n+        updatedAt: new Date(),\n+        contractFile: undefined, // File 객체는 저장하지 않음\n+        contractFileName,\n+        contractFileData,\n+      };\n+\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.put(updatedStaff)\n+      );\n+\n+      console.log('직원 수정 성공:', updatedStaff);\n+      return updatedStaff;\n+    } catch (error) {\n+      console.error('직원 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 직원 삭제\n+   */\n+  async deleteStaff(id: string): Promise<boolean> {\n+    try {\n+      const existing = await this.getStaffById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 직원입니다.');\n+      }\n+\n+      // 시스템 관리자 삭제 보호\n+      this.validateSystemAdminProtection(existing, 'delete');\n+\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+      console.log('직원 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('직원 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 직원 활성/비활성 상태 토글\n+   */\n+  async toggleStaffStatus(id: string): Promise<Staff | null> {\n+    try {\n+      const existing = await this.getStaffById(id);\n+      if (!existing) {\n+        throw new Error('존재하지 않는 직원입니다.');\n+      }\n+\n+      // 시스템 관리자 상태 변경 보호\n+      if (existing.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID) {\n+        throw new Error('시스템 관리자 계정의 상태는 변경할 수 없습니다.');\n+      }\n+\n+      const updatedStaff = {\n+        ...existing,\n+        isActive: !existing.isActive,\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.put(updatedStaff)\n+      );\n+\n+      console.log('직원 상태 변경 성공:', id, `-> ${updatedStaff.isActive ? '활성' : '비활성'}`);\n+      return updatedStaff;\n+    } catch (error) {\n+      console.error('직원 상태 변경 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 지점별 직원 조회\n+   */\n+  async getStaffByBranch(branchId: string): Promise<Staff[]> {\n+    try {\n+      return await this.executeTransaction('staff', 'readonly', (store) => {\n+        const index = store.index('branchId');\n+        return index.getAll(IDBKeyRange.only(branchId));\n+      });\n+    } catch (error) {\n+      console.error('지점별 직원 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 이메일로 직원 조회\n+   */\n+  async getStaffByEmail(email: string): Promise<Staff | null> {\n+    try {\n+      const result = await this.executeTransaction('staff', 'readonly', (store) => {\n+        const index = store.index('email');\n+        return index.get(email);\n+      });\n+      return result || null;\n+    } catch (error) {\n+      console.error('이메일로 직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 로그인ID로 직원 조회\n+   */\n+  async getStaffByLoginId(loginId: string): Promise<Staff | null> {\n+    try {\n+      const staff = await this.executeTransaction('staff', 'readonly', (store) => {\n+        const index = store.index('loginId');\n+        return index.get(loginId);\n+      });\n+\n+      if (!staff) return null;\n+\n+      // 저장된 파일 데이터를 File 객체로 복원\n+      if (staff.contractFileData && staff.contractFileName) {\n+        const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n+        let mimeType = 'application/octet-stream';\n+        \n+        if (extension === 'pdf') {\n+          mimeType = 'application/pdf';\n+        } else if (['jpg', 'jpeg'].includes(extension || '')) {\n+          mimeType = 'image/jpeg';\n+        } else if (extension === 'png') {\n+          mimeType = 'image/png';\n+        }\n+\n+        staff.contractFile = this.arrayBufferToFile(\n+          staff.contractFileData, \n+          staff.contractFileName, \n+          mimeType\n+        );\n+      }\n+\n+      return staff;\n+    } catch (error) {\n+      console.error('로그인ID로 직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 전화번호로 직원 조회\n+   */\n+  async getStaffByPhone(phone: string): Promise<Staff | null> {\n+    try {\n+      const allStaff = await this.getAllStaff();\n+      const found = allStaff.find(staff => staff.phone === phone);\n+      return found || null;\n+    } catch (error) {\n+      console.error('전화번호로 직원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 중복 체크 함수 (등록 시 사용)\n+   */\n+  async checkDuplicateStaff(loginId: string, email: string, phone: string): Promise<{\n+    isDuplicate: boolean;\n+    duplicateField?: 'loginId' | 'email' | 'phone';\n+    message?: string;\n+  }> {\n+    try {\n+      // 로그인 ID 중복 체크\n+      const existingByLoginId = await this.getStaffByLoginId(loginId);\n+      if (existingByLoginId) {\n+        return {\n+          isDuplicate: true,\n+          duplicateField: 'loginId',\n+          message: '이미 사용 중인 로그인 ID입니다.'\n+        };\n+      }\n+\n+      // 이메일 중복 체크\n+      const existingByEmail = await this.getStaffByEmail(email);\n+      if (existingByEmail) {\n+        return {\n+          isDuplicate: true,\n+          duplicateField: 'email',\n+          message: '이미 사용 중인 이메일입니다.'\n+        };\n+      }\n+\n+      // 전화번호 중복 체크\n+      const existingByPhone = await this.getStaffByPhone(phone);\n+      if (existingByPhone) {\n+        return {\n+          isDuplicate: true,\n+          duplicateField: 'phone',\n+          message: '이미 사용 중인 전화번호입니다.'\n+        };\n+      }\n+\n+      return { isDuplicate: false };\n+    } catch (error) {\n+      console.error('중복 체크 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 파일을 ArrayBuffer로 변환\n+   */\n+  private fileToArrayBuffer(file: File): Promise<ArrayBuffer> {\n+    return new Promise((resolve, reject) => {\n+      const reader = new FileReader();\n+      reader.onload = () => resolve(reader.result as ArrayBuffer);\n+      reader.onerror = () => reject(reader.error);\n+      reader.readAsArrayBuffer(file);\n+    });\n+  }\n+\n+  /**\n+   * ArrayBuffer를 Blob으로 변환 (파일 다운로드용)\n+   */\n+  arrayBufferToBlob(buffer: ArrayBuffer, mimeType: string): Blob {\n+    return new Blob([buffer], { type: mimeType });\n+  }\n+\n+  /**\n+   * ArrayBuffer를 File 객체로 변환\n+   */\n+  private arrayBufferToFile(buffer: ArrayBuffer, fileName: string, mimeType: string = 'application/octet-stream'): File {\n+    const blob = new Blob([buffer], { type: mimeType });\n+    return new File([blob], fileName, { type: mimeType });\n+  }\n+\n+  /**\n+   * 데이터베이스 초기화 (개발/테스트용)\n+   */\n+  async clearAllData(): Promise<void> {\n+    try {\n+      await this.executeTransaction('branches', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      await this.executeTransaction('staff', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      await this.executeTransaction('points', 'readwrite', (store) => \n+        store.clear()\n+      );\n+      console.log('모든 데이터 삭제 완료');\n+    } catch (error) {\n+      console.error('데이터 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 기존 직원 데이터의 isActive 필드 초기화 (마이그레이션용)\n+   */\n+  async migrateStaffActiveStatus(): Promise<void> {\n+    try {\n+      const allStaff = await this.executeTransaction('staff', 'readonly', (store) => \n+        store.getAll()\n+      );\n+\n+      // isActive 필드가 없는 직원들을 찾아서 업데이트\n+      const staffToUpdate = allStaff.filter(staff => staff.isActive === undefined);\n+      \n+      if (staffToUpdate.length > 0) {\n+        console.log(`${staffToUpdate.length}명의 직원 isActive 필드를 초기화합니다.`);\n+        \n+        for (const staff of staffToUpdate) {\n+          const updatedStaff = {\n+            ...staff,\n+            isActive: true, // 기본값을 true로 설정\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('staff', 'readwrite', (store) => \n+            store.put(updatedStaff)\n+          );\n+        }\n+        \n+        console.log('직원 isActive 필드 초기화 완료');\n+      }\n+    } catch (error) {\n+      console.error('직원 isActive 필드 초기화 실패:', error);\n+    }\n+  }\n+\n+  // =================== 프로그램 관리 메서드 ===================\n+\n+  /**\n+   * 프로그램 추가\n+   */\n+  async addProgram(programData: Omit<Program, 'id' | 'createdAt' | 'updatedAt'>): Promise<Program> {\n+    try {\n+      // 프로그램명 중복 체크\n+      const existingProgram = await this.getProgramByName(programData.name);\n+      if (existingProgram) {\n+        throw new Error('이미 존재하는 프로그램명입니다.');\n+      }\n+\n+      const newProgram: Program = {\n+        id: this.generateUUID(),\n+        ...programData,\n+        createdAt: new Date(),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.add(newProgram)\n+      );\n+\n+      console.log('프로그램 추가 성공:', newProgram);\n+      return newProgram;\n+    } catch (error) {\n+      console.error('프로그램 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 프로그램 조회\n+   */\n+  async getAllPrograms(): Promise<Program[]> {\n+    try {\n+      const programs = await this.executeTransaction('programs', 'readonly', (store) => \n+        store.getAll()\n+      );\n+      \n+      return programs.map(program => ({\n+        ...program,\n+        createdAt: new Date(program.createdAt),\n+        updatedAt: new Date(program.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('프로그램 목록 조회 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 프로그램명으로 조회\n+   */\n+  async getProgramByName(name: string): Promise<Program | null> {\n+    try {\n+      const program = await this.executeTransaction('programs', 'readonly', (store) => \n+        store.index('name').get(name)\n+      );\n+      \n+      if (program) {\n+        return {\n+          ...program,\n+          createdAt: new Date(program.createdAt),\n+          updatedAt: new Date(program.updatedAt)\n+        };\n+      }\n+      \n+      return null;\n+    } catch (error) {\n+      console.error('프로그램 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 프로그램 수정\n+   */\n+  async updateProgram(id: string, updates: Partial<Omit<Program, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Program | null> {\n+    try {\n+      const existingProgram = await this.executeTransaction('programs', 'readonly', (store) => \n+        store.get(id)\n+      );\n+\n+      if (!existingProgram) {\n+        console.error('수정할 프로그램을 찾을 수 없습니다:', id);\n+        return null;\n+      }\n+\n+      // 프로그램명 변경 시 중복 체크\n+      if (updates.name && updates.name !== existingProgram.name) {\n+        const duplicateProgram = await this.getProgramByName(updates.name);\n+        if (duplicateProgram) {\n+          throw new Error('이미 존재하는 프로그램명입니다.');\n+        }\n+      }\n+\n+      const updatedProgram: Program = {\n+        ...existingProgram,\n+        ...updates,\n+        id,\n+        createdAt: new Date(existingProgram.createdAt),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.put(updatedProgram)\n+      );\n+\n+      console.log('프로그램 수정 성공:', updatedProgram);\n+      return updatedProgram;\n+    } catch (error) {\n+      console.error('프로그램 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 프로그램 삭제\n+   */\n+  async deleteProgram(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('programs', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('프로그램 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('프로그램 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  // =================== 상품 관리 메서드 ===================\n+\n+  /**\n+   * 상품 추가\n+   */\n+  async addProduct(productData: Omit<Product, 'id' | 'createdAt' | 'updatedAt'>): Promise<Product> {\n+    try {\n+      const newProduct: Product = {\n+        id: this.generateUUID(),\n+        ...productData,\n+        createdAt: new Date(),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.add(newProduct)\n+      );\n+\n+      console.log('상품 추가 성공:', newProduct);\n+      return newProduct;\n+    } catch (error) {\n+      console.error('상품 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 상품 조회\n+   */\n+  async getAllProducts(): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => \n+        store.getAll()\n+      );\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('상품 목록 조회 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * ID로 상품 조회\n+   */\n+  async getProductById(id: string): Promise<Product | null> {\n+    try {\n+      const product = await this.executeTransaction('products', 'readonly', (store) => \n+        store.get(id)\n+      );\n+      \n+      if (product) {\n+        return {\n+          ...product,\n+          createdAt: new Date(product.createdAt),\n+          updatedAt: new Date(product.updatedAt)\n+        };\n+      }\n+      \n+      return null;\n+    } catch (error) {\n+      console.error('상품 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 지점별 상품 조회\n+   */\n+  async getProductsByBranch(branchId: string): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('branchId');\n+        return index.getAll(IDBKeyRange.only(branchId));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('지점별 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 프로그램별 상품 조회\n+   */\n+  async getProductsByProgram(programId: string): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('programId');\n+        return index.getAll(IDBKeyRange.only(programId));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('프로그램별 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 지점과 프로그램으로 상품 조회\n+   */\n+  async getProductsByBranchAndProgram(branchId: string, programId: string): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('branchProgram');\n+        return index.getAll(IDBKeyRange.only([branchId, programId]));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('지점-프로그램별 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 상품 수정\n+   */\n+  async updateProduct(id: string, updates: Partial<Omit<Product, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Product | null> {\n+    try {\n+      const existingProduct = await this.executeTransaction('products', 'readonly', (store) => \n+        store.get(id)\n+      );\n+\n+      if (!existingProduct) {\n+        console.error('수정할 상품을 찾을 수 없습니다:', id);\n+        return null;\n+      }\n+\n+      const updatedProduct: Product = {\n+        ...existingProduct,\n+        ...updates,\n+        id,\n+        createdAt: new Date(existingProduct.createdAt),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.put(updatedProduct)\n+      );\n+\n+      console.log('상품 수정 성공:', updatedProduct);\n+      return updatedProduct;\n+    } catch (error) {\n+      console.error('상품 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 상품 삭제\n+   */\n+  async deleteProduct(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('products', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('상품 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('상품 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 활성 상품만 조회\n+   */\n+  async getActiveProducts(): Promise<Product[]> {\n+    try {\n+      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+        const index = store.index('isActive');\n+        return index.getAll(IDBKeyRange.only(true));\n+      });\n+      \n+      return products.map(product => ({\n+        ...product,\n+        createdAt: new Date(product.createdAt),\n+        updatedAt: new Date(product.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('활성 상품 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 상품명으로 검색\n+   */\n+  async searchProductsByName(name: string): Promise<Product[]> {\n+    try {\n+      const allProducts = await this.getAllProducts();\n+      return allProducts.filter(product => \n+        product.name.toLowerCase().includes(name.toLowerCase())\n+      );\n+    } catch (error) {\n+      console.error('상품 검색 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  // ==================== 휴일설정 관련 메서드 ====================\n+\n+  /**\n+   * 휴일설정 추가/업데이트\n+   */\n+  async saveHolidaySettings(settingsArray: Omit<HolidaySettings, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<HolidaySettings[]> {\n+    try {\n+      const savedSettings: HolidaySettings[] = [];\n+      \n+      for (const setting of settingsArray) {\n+        // 기존 설정이 있는지 확인\n+        const existingSettings = await this.getHolidaySettingsByStaffAndDate(setting.staffId, setting.date);\n+        \n+        let savedSetting: HolidaySettings;\n+        \n+        if (existingSettings.length > 0) {\n+          // 업데이트\n+          const existing = existingSettings[0];\n+          savedSetting = {\n+            ...existing,\n+            ...setting,\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n+            store.put(savedSetting)\n+          );\n+        } else {\n+          // 새로 추가\n+          savedSetting = {\n+            ...setting,\n+            id: this.generateUUID(),\n+            createdAt: new Date(),\n+            updatedAt: new Date()\n+          };\n+          \n+          await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n+            store.add(savedSetting)\n+          );\n+        }\n+        \n+        savedSettings.push(savedSetting);\n+      }\n+\n+      console.log('휴일설정 저장 성공:', savedSettings.length);\n+      return savedSettings;\n+    } catch (error) {\n+      console.error('휴일설정 저장 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 모든 휴일설정 조회\n+   */\n+  async getHolidaySettingsByStaff(staffId: string): Promise<HolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n+        const index = store.index('staffId');\n+        return index.getAll(IDBKeyRange.only(staffId));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('직원별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 특정 날짜 휴일설정 조회\n+   */\n+  async getHolidaySettingsByStaffAndDate(staffId: string, date: string): Promise<HolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n+        const index = store.index('staffDate');\n+        return index.getAll(IDBKeyRange.only([staffId, date]));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('직원별 날짜별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 특정 날짜의 모든 휴일설정 조회\n+   */\n+  async getHolidaySettingsByDate(date: string): Promise<HolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n+        const index = store.index('date');\n+        return index.getAll(IDBKeyRange.only(date));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('날짜별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 날짜 범위의 휴일설정 조회\n+   */\n+  async getHolidaySettingsByDateRange(startDate: string, endDate: string): Promise<HolidaySettings[]> {\n+    try {\n+      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n+        const index = store.index('date');\n+        return index.getAll(IDBKeyRange.bound(startDate, endDate));\n+      });\n+      \n+      return settings.map(setting => ({\n+        ...setting,\n+        createdAt: new Date(setting.createdAt),\n+        updatedAt: new Date(setting.updatedAt)\n+      }));\n+    } catch (error) {\n+      console.error('날짜 범위별 휴일설정 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 휴일설정 삭제\n+   */\n+  async deleteHolidaySettings(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('휴일설정 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('휴일설정 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 특정 직원의 모든 휴일설정 삭제\n+   */\n+  async deleteHolidaySettingsByStaff(staffId: string): Promise<boolean> {\n+    try {\n+      const settings = await this.getHolidaySettingsByStaff(staffId);\n+      \n+      for (const setting of settings) {\n+        await this.deleteHolidaySettings(setting.id);\n+      }\n+\n+      console.log('직원 휴일설정 전체 삭제 성공:', staffId);\n+      return true;\n+    } catch (error) {\n+      console.error('직원 휴일설정 전체 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  // ==================== 약관/문서 관련 메서드 ====================\n+\n+  /**\n+   * 약관/문서 추가\n+   */\n+  async addTermsDocument(documentData: Omit<TermsDocument, 'id' | 'createdAt' | 'updatedAt' | 'version'>): Promise<TermsDocument> {\n+    try {\n+      // 같은 타입의 기존 문서들의 최대 버전 찾기\n+      const existingDocs = await this.getTermsDocumentsByType(documentData.type);\n+      const maxVersion = existingDocs.length > 0 ? Math.max(...existingDocs.map(doc => doc.version)) : 0;\n+\n+      // 기존 활성 문서들 비활성화\n+      for (const doc of existingDocs.filter(d => d.isActive)) {\n+        await this.updateTermsDocument(doc.id, { isActive: false });\n+      }\n+\n+      const newDocument: TermsDocument = {\n+        ...documentData,\n+        id: this.generateUUID(),\n+        version: maxVersion + 1,\n+        createdAt: new Date(),\n+        updatedAt: new Date(),\n+        publishedAt: documentData.isActive ? new Date() : null\n+      };\n+\n+      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n+        store.add(newDocument)\n+      );\n+\n+      console.log('약관/문서 추가 성공:', newDocument);\n+      return newDocument;\n+    } catch (error) {\n+      console.error('약관/문서 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 약관/문서 조회\n+   */\n+  async getAllTermsDocuments(): Promise<TermsDocument[]> {\n+    try {\n+      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n+        store.getAll()\n+      );\n+      \n+      return documents.map(doc => ({\n+        ...doc,\n+        createdAt: new Date(doc.createdAt),\n+        updatedAt: new Date(doc.updatedAt),\n+        publishedAt: doc.publishedAt ? new Date(doc.publishedAt) : null\n+      }));\n+    } catch (error) {\n+      console.error('약관/문서 목록 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * ID로 약관/문서 조회\n+   */\n+  async getTermsDocumentById(id: string): Promise<TermsDocument | null> {\n+    try {\n+      const document = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n+        store.get(id)\n+      );\n+      \n+      if (document) {\n+        return {\n+          ...document,\n+          createdAt: new Date(document.createdAt),\n+          updatedAt: new Date(document.updatedAt),\n+          publishedAt: document.publishedAt ? new Date(document.publishedAt) : null\n+        };\n+      }\n+      \n+      return null;\n+    } catch (error) {\n+      console.error('약관/문서 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 타입별 약관/문서 조회\n+   */\n+  async getTermsDocumentsByType(type: TermsDocument['type']): Promise<TermsDocument[]> {\n+    try {\n+      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => {\n+        return store.getAll();\n+      });\n+      \n+      const filteredDocs = documents.filter(doc => doc.type === type);\n+      \n+      return filteredDocs.map(doc => ({\n+        ...doc,\n+        createdAt: new Date(doc.createdAt),\n+        updatedAt: new Date(doc.updatedAt),\n+        publishedAt: doc.publishedAt ? new Date(doc.publishedAt) : null\n+      })).sort((a, b) => b.version - a.version); // 최신 버전부터\n+    } catch (error) {\n+      console.error('타입별 약관/문서 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 활성화된 약관/문서만 조회 (타입별)\n+   */\n+  async getActiveTermsDocument(type: TermsDocument['type']): Promise<TermsDocument | null> {\n+    try {\n+      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => {\n+        return store.getAll();\n+      });\n+      \n+      const activeDoc = documents.find(doc => doc.type === type && doc.isActive);\n+      \n+      if (!activeDoc) return null;\n+\n+      return {\n+        ...activeDoc,\n+        createdAt: new Date(activeDoc.createdAt),\n+        updatedAt: new Date(activeDoc.updatedAt),\n+        publishedAt: activeDoc.publishedAt ? new Date(activeDoc.publishedAt) : null\n+      };\n+    } catch (error) {\n+      console.error('활성 약관/문서 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 약관/문서 수정\n+   */\n+  async updateTermsDocument(id: string, updates: Partial<Omit<TermsDocument, 'id' | 'createdAt' | 'updatedAt' | 'version'>>): Promise<TermsDocument | null> {\n+    try {\n+      const existingDocument = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n+        store.get(id)\n+      );\n+\n+      if (!existingDocument) {\n+        console.error('수정할 약관/문서를 찾을 수 없습니다:', id);\n+        return null;\n+      }\n+\n+      // 활성화 시 같은 타입의 다른 문서들 비활성화\n+      if (updates.isActive === true && !existingDocument.isActive) {\n+        const otherDocs = await this.getTermsDocumentsByType(existingDocument.type);\n+        for (const doc of otherDocs.filter((d: TermsDocument) => d.id !== id && d.isActive)) {\n+          await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n+            store.put({\n+              ...doc,\n+              isActive: false,\n+              updatedAt: new Date()\n+            })\n+          );\n+        }\n+      }\n+\n+      const updatedDocument: TermsDocument = {\n+        ...existingDocument,\n+        ...updates,\n+        id,\n+        createdAt: new Date(existingDocument.createdAt),\n+        updatedAt: new Date(),\n+        publishedAt: updates.isActive === true && !existingDocument.isActive ? new Date() : \n+                    updates.isActive === false ? null : \n+                    existingDocument.publishedAt\n+      };\n+\n+      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n+        store.put(updatedDocument)\n+      );\n+\n+      console.log('약관/문서 수정 성공:', updatedDocument);\n+      return updatedDocument;\n+    } catch (error) {\n+      console.error('약관/문서 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 약관/문서 삭제\n+   */\n+  async deleteTermsDocument(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('약관/문서 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('약관/문서 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 약관/문서 검색 (제목, 내용)\n+   */\n+  async searchTermsDocuments(searchTerm: string): Promise<TermsDocument[]> {\n+    try {\n+      const allDocuments = await this.getAllTermsDocuments();\n+      const lowerSearchTerm = searchTerm.toLowerCase();\n+      \n+      return allDocuments.filter(doc => \n+        doc.title.toLowerCase().includes(lowerSearchTerm) ||\n+        doc.content.toLowerCase().includes(lowerSearchTerm)\n+      );\n+    } catch (error) {\n+      console.error('약관/문서 검색 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  // ==================== 회원 관리 ====================\n+\n+  /**\n+   * 회원 추가\n+   */\n+  async addMember(memberData: Omit<Member, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n+    try {\n+      console.log('=== addMember 함수 시작 ===');\n+      console.log('받은 memberData:', memberData);\n+      \n+      // 데이터베이스 연결 확인\n+      if (!this.db) {\n+        console.log('데이터베이스가 연결되지 않음, 초기화 시도...');\n+        await this.initDB();\n+      }\n+      console.log('데이터베이스 연결 상태:', this.db ? '연결됨' : '연결 안됨');\n+      \n+      const member: Member = {\n+        id: this.generateUUID(),\n+        ...memberData,\n+        createdAt: new Date(),\n+        updatedAt: new Date(),\n+      };\n+\n+      console.log('생성할 회원 객체:', member);\n+      console.log('회원 ID:', member.id);\n+      \n+      console.log('트랜잭션 시작...');\n+      await this.executeTransaction('members', 'readwrite', (store) => {\n+        console.log('store.add 실행 중...');\n+        console.log('추가할 멤버 객체:', member);\n+        try {\n+          const request = store.add(member);\n+          console.log('store.add 요청 생성됨');\n+          return request;\n+        } catch (storeError) {\n+          console.error('❌ store.add에서 즉시 에러:', storeError);\n+          throw storeError;\n+        }\n+      });\n+\n+      console.log('✅ 회원 추가 성공:', member.id);\n+      \n+      // 즉시 확인\n+      console.log('=== 저장 확인 ===');\n+      const savedMember = await this.executeTransaction('members', 'readonly', (store) => \n+        store.get(member.id)\n+      );\n+      \n+      if (savedMember) {\n+        console.log('✅ 저장된 회원 확인됨:', savedMember);\n+      } else {\n+        console.error('❌ 방금 저장한 회원을 찾을 수 없음');\n+      }\n+      \n+      return member.id;\n+    } catch (error) {\n+      console.error('❌ 회원 추가 실패:', error);\n+      console.error('에러 상세:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 회원 조회\n+   */\n+  async getAllMembers(): Promise<Member[]> {\n+    try {\n+      return await this.executeTransaction('members', 'readonly', (store) => \n+        store.getAll()\n+      );\n+    } catch (error) {\n+      console.error('회원 목록 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * ID로 회원 조회\n+   */\n+  async getMemberById(id: string): Promise<Member | null> {\n+    try {\n+      return await this.executeTransaction('members', 'readonly', (store) => \n+        store.get(id)\n+      ) || null;\n+    } catch (error) {\n+      console.error('회원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 전화번호로 회원 조회\n+   */\n+  async getMemberByPhone(phone: string): Promise<Member | null> {\n+    try {\n+      const result = await this.executeTransaction('members', 'readonly', (store) => {\n+        const index = store.index('phone');\n+        return index.get(phone);\n+      });\n+      \n+      // 활성 회원만 반환\n+      return (result && result.isActive) ? result : null;\n+    } catch (error) {\n+      console.error('전화번호로 회원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 지점별 회원 조회\n+   */\n+  async getMembersByBranch(branchId: string): Promise<Member[]> {\n+    try {\n+      return await this.executeTransaction('members', 'readonly', (store) => {\n+        const index = store.index('branchId');\n+        return index.getAll(branchId);\n+      });\n+    } catch (error) {\n+      console.error('지점별 회원 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 회원 정보 수정\n+   */\n+  async updateMember(id: string, updates: Partial<Omit<Member, 'id' | 'createdAt'>>): Promise<boolean> {\n+    try {\n+      const existingMember = await this.getMemberById(id);\n+      if (!existingMember) {\n+        throw new Error('수정할 회원을 찾을 수 없습니다.');\n+      }\n+\n+      const updatedMember: Member = {\n+        ...existingMember,\n+        ...updates,\n+        updatedAt: new Date(),\n+      };\n+\n+      await this.executeTransaction('members', 'readwrite', (store) => \n+        store.put(updatedMember)\n+      );\n+\n+      console.log('회원 정보 수정 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('회원 정보 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 회원 삭제 (비활성화)\n+   */\n+  async deleteMember(id: string): Promise<boolean> {\n+    try {\n+      await this.updateMember(id, { isActive: false });\n+      console.log('회원 삭제(비활성화) 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('회원 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 회원 검색 (이름, 전화번호, 이메일)\n+   */\n+  async searchMembers(searchTerm: string): Promise<Member[]> {\n+    try {\n+      const allMembers = await this.getAllMembers();\n+      const lowerSearchTerm = searchTerm.toLowerCase();\n+      \n+      return allMembers.filter(member => \n+        member.name.toLowerCase().includes(lowerSearchTerm) ||\n+        member.phone.includes(searchTerm) ||\n+        member.email.toLowerCase().includes(lowerSearchTerm)\n+      );\n+    } catch (error) {\n+      console.error('회원 검색 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 이메일로 회원 조회\n+   */\n+  async getMemberByEmail(email: string): Promise<Member | null> {\n+    try {\n+      // 이메일이 비어있으면 null 반환\n+      if (!email || email.trim() === '') {\n+        return null;\n+      }\n+\n+      // 모든 회원을 조회해서 이메일이 일치하는 회원 찾기 (대소문자 구분 없이)\n+      const allMembers = await this.getAllMembers();\n+      const member = allMembers.find(m => \n+        m.email.toLowerCase() === email.toLowerCase() && m.isActive\n+      );\n+      \n+      return member || null;\n+    } catch (error) {\n+      console.error('이메일로 회원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 회원 중복 체크 (연락처와 이메일)\n+   */\n+  async checkMemberDuplicate(phone: string, email?: string): Promise<{\n+    isDuplicate: boolean;\n+    duplicateField?: 'phone' | 'email';\n+    message?: string;\n+  }> {\n+    try {\n+      // 전화번호 중복 체크\n+      if (phone && phone.trim() !== '') {\n+        const existingByPhone = await this.getMemberByPhone(phone);\n+        if (existingByPhone) {\n+          return {\n+            isDuplicate: true,\n+            duplicateField: 'phone',\n+            message: `연락처 ${phone}는(은) 이미 등록된 회원입니다.`\n+          };\n+        }\n+      }\n+\n+      // 이메일 중복 체크 (이메일이 있는 경우만)\n+      if (email && email.trim() !== '') {\n+        const existingByEmail = await this.getMemberByEmail(email);\n+        if (existingByEmail) {\n+          return {\n+            isDuplicate: true,\n+            duplicateField: 'email',\n+            message: `이메일 ${email}는(은) 이미 등록된 회원입니다.`\n+          };\n+        }\n+      }\n+\n+      return { isDuplicate: false };\n+    } catch (error) {\n+      console.error('회원 중복 체크 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 로그인 ID로 회원 조회\n+   */\n+  async getMemberByLoginId(loginId: string): Promise<Member | null> {\n+    try {\n+      // 로그인 ID가 비어있으면 null 반환\n+      if (!loginId || loginId.trim() === '') {\n+        return null;\n+      }\n+\n+      return await this.executeTransaction('members', 'readonly', (store) => {\n+        const index = store.index('loginId');\n+        return index.get(loginId);\n+      }) || null;\n+    } catch (error) {\n+      console.error('로그인 ID로 회원 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 로그인 ID 중복 체크 (직원과 회원 모두 확인)\n+   */\n+  async checkLoginIdDuplicate(loginId: string): Promise<{\n+    isDuplicate: boolean;\n+    duplicateType?: 'staff' | 'member';\n+    message?: string;\n+  }> {\n+    try {\n+      // 로그인 ID가 비어있거나 임시 ID이면 중복 없음\n+      if (!loginId || loginId.trim() === '' || loginId.startsWith('temp_')) {\n+        return { isDuplicate: false };\n+      }\n+\n+      // 직원 테이블에서 중복 검사\n+      const existingStaff = await this.getStaffByLoginId(loginId);\n+      if (existingStaff) {\n+        return {\n+          isDuplicate: true,\n+          duplicateType: 'staff',\n+          message: `로그인 ID ${loginId}는(은) 이미 직원으로 등록되어 있습니다.`\n+        };\n+      }\n+\n+      // 회원 테이블에서 중복 검사\n+      const existingMember = await this.getMemberByLoginId(loginId);\n+      if (existingMember && !existingMember.loginId.startsWith('temp_')) {\n+        return {\n+          isDuplicate: true,\n+          duplicateType: 'member',\n+          message: `로그인 ID ${loginId}는(은) 이미 회원으로 등록되어 있습니다.`\n+        };\n+      }\n+\n+      return { isDuplicate: false };\n+    } catch (error) {\n+      console.error('로그인 ID 중복 체크 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  // ==================== 결제 관리 ====================\n+\n+  /**\n+   * 결제 정보 추가\n+   */\n+  async addPayment(paymentData: Omit<Payment, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n+    try {\n+      const payment: Payment = {\n+        id: this.generateUUID(),\n+        ...paymentData,\n+        createdAt: new Date(),\n+        updatedAt: new Date(),\n+      };\n+\n+      await this.executeTransaction('payments', 'readwrite', (store) => \n+        store.add(payment)\n+      );\n+\n+      console.log('결제 정보 추가 성공:', payment.id);\n+      return payment.id;\n+    } catch (error) {\n+      console.error('결제 정보 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 모든 결제 정보 조회\n+   */\n+  async getAllPayments(): Promise<Payment[]> {\n+    try {\n+      return await this.executeTransaction('payments', 'readonly', (store) => \n+        store.getAll()\n+      );\n+    } catch (error) {\n+      console.error('결제 목록 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * ID로 결제 정보 조회\n+   */\n+  async getPaymentById(id: string): Promise<Payment | null> {\n+    try {\n+      return await this.executeTransaction('payments', 'readonly', (store) => \n+        store.get(id)\n+      ) || null;\n+    } catch (error) {\n+      console.error('결제 정보 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 회원별 결제 정보 조회\n+   */\n+  async getPaymentsByMember(memberId: string): Promise<Payment[]> {\n+    try {\n+      return await this.executeTransaction('payments', 'readonly', (store) => {\n+        const index = store.index('memberId');\n+        return index.getAll(memberId);\n+      });\n+    } catch (error) {\n+      console.error('회원별 결제 정보 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 결제 정보 수정\n+   */\n+  async updatePayment(id: string, updates: Partial<Omit<Payment, 'id' | 'createdAt'>>): Promise<boolean> {\n+    try {\n+      const existingPayment = await this.getPaymentById(id);\n+      if (!existingPayment) {\n+        throw new Error('수정할 결제 정보를 찾을 수 없습니다.');\n+      }\n+\n+      const updatedPayment: Payment = {\n+        ...existingPayment,\n+        ...updates,\n+        updatedAt: new Date(),\n+      };\n+\n+      await this.executeTransaction('payments', 'readwrite', (store) => \n+        store.put(updatedPayment)\n+      );\n+\n+      console.log('결제 정보 수정 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('결제 정보 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 결제 정보 삭제\n+   */\n+  async deletePayment(id: string): Promise<boolean> {\n+    try {\n+      await this.executeTransaction('payments', 'readwrite', (store) => \n+        store.delete(id)\n+      );\n+\n+      console.log('결제 정보 삭제 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('결제 정보 삭제 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  // ==================== 포인트 관리 ====================\n+\n+  /**\n+   * 포인트 적립\n+   */\n+  async addPoint(pointData: Omit<Point, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n+    try {\n+      const point: Point = {\n+        id: this.generateUUID(),\n+        ...pointData,\n+        createdAt: new Date(),\n+        updatedAt: new Date(),\n+      };\n+\n+      await this.executeTransaction('points', 'readwrite', (store) => \n+        store.add(point)\n+      );\n+\n+      console.log('포인트 적립 성공:', point.id, `${point.amount}원`);\n+      return point.id;\n+    } catch (error) {\n+      console.error('포인트 적립 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 회원별 포인트 내역 조회\n+   */\n+  async getPointsByMember(memberId: string): Promise<Point[]> {\n+    try {\n+      return await this.executeTransaction('points', 'readonly', (store) => {\n+        const index = store.index('memberId');\n+        return index.getAll(memberId);\n+      });\n+    } catch (error) {\n+      console.error('회원별 포인트 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 회원의 현재 사용 가능한 포인트 잔액 계산\n+   */\n+  async getMemberPointBalance(memberId: string): Promise<number> {\n+    try {\n+      const points = await this.getPointsByMember(memberId);\n+      const now = new Date();\n+      \n+      // 만료되지 않은 포인트들만 계산\n+      const validPoints = points.filter(point => {\n+        // 만료일이 없거나 만료일이 지나지 않은 경우\n+        return !point.expiryDate || point.expiryDate > now;\n+      });\n+      \n+      // 총 포인트 합계 (적립은 +, 사용은 -)\n+      return validPoints.reduce((total, point) => total + point.amount, 0);\n+    } catch (error) {\n+      console.error('포인트 잔액 계산 실패:', error);\n+      return 0;\n+    }\n+  }\n+\n+  /**\n+   * 포인트 사용\n+   */\n+  async usePoints(memberId: string, amount: number, source: string, description?: string, relatedPaymentId?: string): Promise<string> {\n+    try {\n+      // 사용 가능한 포인트 잔액 확인\n+      const currentBalance = await this.getMemberPointBalance(memberId);\n+      \n+      if (currentBalance < amount) {\n+        throw new Error(`포인트가 부족합니다. 현재 잔액: ${currentBalance.toLocaleString()}원, 사용 요청: ${amount.toLocaleString()}원`);\n+      }\n+\n+      // 회원 정보 조회\n+      const member = await this.getMemberById(memberId);\n+      if (!member) {\n+        throw new Error('회원 정보를 찾을 수 없습니다.');\n+      }\n+\n+      // 포인트 사용 내역 추가 (음수로 저장)\n+      return await this.addPoint({\n+        memberId,\n+        memberName: member.name,\n+        amount: -amount, // 사용은 음수\n+        type: 'used',\n+        source,\n+        description,\n+        relatedPaymentId\n+      });\n+    } catch (error) {\n+      console.error('포인트 사용 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 만료된 포인트 처리\n+   */\n+  async expirePoints(): Promise<number> {\n+    try {\n+      const now = new Date();\n+      const allPoints = await this.executeTransaction('points', 'readonly', (store) => \n+        store.getAll()\n+      );\n+      \n+      // 만료된 적립 포인트 찾기 (type이 'earned'이고 만료일이 지난 것들)\n+      const expiredPoints = allPoints.filter(point => \n+        point.type === 'earned' && \n+        point.expiryDate && \n+        point.expiryDate <= now &&\n+        point.amount > 0 // 적립된 포인트만\n+      );\n+      \n+      let expiredCount = 0;\n+      \n+      // 각 만료된 포인트에 대해 만료 처리 레코드 생성\n+      for (const expiredPoint of expiredPoints) {\n+        await this.addPoint({\n+          memberId: expiredPoint.memberId,\n+          memberName: expiredPoint.memberName,\n+          amount: -expiredPoint.amount, // 만료는 음수로 차감\n+          type: 'expired',\n+          source: '포인트 만료',\n+          description: `${expiredPoint.expiryDate.toLocaleDateString()} 만료된 포인트`,\n+          relatedPaymentId: expiredPoint.relatedPaymentId\n+        });\n+        \n+        expiredCount++;\n+      }\n+      \n+      console.log(`만료된 포인트 처리 완료: ${expiredCount}건`);\n+      return expiredCount;\n+    } catch (error) {\n+      console.error('포인트 만료 처리 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 포인트 내역 검색\n+   */\n+  async searchPoints(searchTerm: string): Promise<Point[]> {\n+    try {\n+      const allPoints = await this.executeTransaction('points', 'readonly', (store) => \n+        store.getAll()\n+      );\n+      \n+      const lowerSearchTerm = searchTerm.toLowerCase();\n+      \n+      return allPoints.filter(point => \n+        point.memberName.toLowerCase().includes(lowerSearchTerm) ||\n+        point.source.toLowerCase().includes(lowerSearchTerm) ||\n+        (point.description && point.description.toLowerCase().includes(lowerSearchTerm))\n+      );\n+    } catch (error) {\n+      console.error('포인트 검색 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 회원의 포인트 적립/사용 통계\n+   */\n+  async getMemberPointStats(memberId: string): Promise<{\n+    totalEarned: number;\n+    totalUsed: number;\n+    totalExpired: number;\n+    currentBalance: number;\n+    transactionCount: number;\n+  }> {\n+    try {\n+      const points = await this.getPointsByMember(memberId);\n+      \n+      const totalEarned = points\n+        .filter(p => p.type === 'earned')\n+        .reduce((sum, p) => sum + p.amount, 0);\n+        \n+      const totalUsed = Math.abs(points\n+        .filter(p => p.type === 'used')\n+        .reduce((sum, p) => sum + p.amount, 0));\n+        \n+      const totalExpired = Math.abs(points\n+        .filter(p => p.type === 'expired')\n+        .reduce((sum, p) => sum + p.amount, 0));\n+      \n+      const currentBalance = await this.getMemberPointBalance(memberId);\n+      \n+      return {\n+        totalEarned,\n+        totalUsed,\n+        totalExpired,\n+        currentBalance,\n+        transactionCount: points.length\n+      };\n+    } catch (error) {\n+      console.error('포인트 통계 조회 실패:', error);\n+      return {\n+        totalEarned: 0,\n+        totalUsed: 0,\n+        totalExpired: 0,\n+        currentBalance: 0,\n+        transactionCount: 0\n+      };\n+    }\n+  }\n+\n+  /**\n+   * 모든 포인트 내역 조회\n+   */\n+  async getAllPoints(): Promise<Point[]> {\n+    try {\n+      return await this.executeTransaction('points', 'readonly', (store) => \n+        store.getAll()\n+      );\n+    } catch (error) {\n+      console.error('포인트 내역 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+}\n+\n+// 싱글톤 인스턴스 생성\n+export const dbManager = new IndexedDBManager();\n+\n+// 개발자 도구에서 사용할 수 있도록 전역 객체에 추가\n+if (typeof window !== 'undefined') {\n+  (window as any).dbManager = dbManager;\n+}\n"
                },
                {
                    "date": 1760757771074,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -115,24 +115,10 @@\n     customerSignature: string;\n     staffSignature: string;\n   };\n   isActive: boolean;\n-  // 추가 회원 정보 필드들\n-  registrationDate: string;\n-  agreementDate: string;\n-  signatureData: string;\n-  membershipType: string;\n-  duration: number;\n-  durationUnit: string;\n-  startDate: string;\n-  endDate: string;\n-  monthlyFee: number;\n-  totalAmount: number;\n-  discountAmount: number;\n-  finalAmount: number;\n-  paymentMethod: string;\n-  paymentDate: string;\n-  remarks: string;\n+  registrationDate: string; // 회원가입일\n+  remarks?: string; // 비고\n }\n \n export interface Payment extends DBRecord {\n   memberId: string;\n@@ -161,11 +147,35 @@\n   expiryDate?: Date | null; // 만료일 (적립된 포인트의 경우)\n   relatedPaymentId?: string; // 연관된 결제 ID (있는 경우)\n }\n \n+export interface CourseEnrollment extends DBRecord {\n+  memberId: string;\n+  memberName: string; // 조회 성능을 위해 저장\n+  productId: string;\n+  productName: string; // 상품명\n+  productPrice: number; // 상품 가격\n+  programId: string;\n+  programName: string; // 프로그램명\n+  programType: string; // 프로그램 타입 ('횟수제' | '기간제')\n+  branchId: string;\n+  branchName: string; // 지점명\n+  coach: string; // 담당 코치 ID\n+  coachName: string; // 담당 코치명\n+  enrollmentStatus: 'completed' | 'unpaid'; // 수강 상태 ('완료' | '미수')\n+  paidAmount: number; // 실제 지불한 금액\n+  unpaidAmount: number; // 미납 금액 (productPrice - paidAmount)\n+  startDate?: Date | null; // 수강 시작일\n+  endDate?: Date | null; // 수강 종료일 (기간제인 경우)\n+  sessionCount?: number; // 총 수업 횟수 (횟수제인 경우)\n+  completedSessions?: number; // 완료된 수업 횟수 (횟수제인 경우, 기본값 0)\n+  notes?: string; // 비고\n+  relatedPaymentId?: string; // 연관된 결제 ID\n+}\n+\n class IndexedDBManager {\n   private dbName: string = 'LavidaDB';\n-  private version: number = 10; // 버전 업데이트 (Point 테이블 추가, Payment 테이블 필드 추가)\n+  private version: number = 11; // 버전 업데이트 (CourseEnrollment 테이블 추가)\n   private db: IDBDatabase | null = null;\n   private isInitializing: boolean = false; // 단순한 플래그로 변경\n \n   constructor() {\n@@ -377,8 +387,37 @@\n           // 만료되지 않은 포인트 조회 최적화\n           pointStore.createIndex('memberActive', ['memberId', 'expiryDate'], { unique: false });\n         }\n \n+        // 수강정보 테이블 생성\n+        if (!db.objectStoreNames.contains('courseEnrollments')) {\n+          const courseStore = db.createObjectStore('courseEnrollments', { keyPath: 'id' });\n+          courseStore.createIndex('memberId', 'memberId', { unique: false });\n+          courseStore.createIndex('memberName', 'memberName', { unique: false });\n+          courseStore.createIndex('productId', 'productId', { unique: false });\n+          courseStore.createIndex('productName', 'productName', { unique: false });\n+          courseStore.createIndex('programId', 'programId', { unique: false });\n+          courseStore.createIndex('programName', 'programName', { unique: false });\n+          courseStore.createIndex('programType', 'programType', { unique: false });\n+          courseStore.createIndex('branchId', 'branchId', { unique: false });\n+          courseStore.createIndex('branchName', 'branchName', { unique: false });\n+          courseStore.createIndex('coach', 'coach', { unique: false });\n+          courseStore.createIndex('coachName', 'coachName', { unique: false });\n+          courseStore.createIndex('enrollmentStatus', 'enrollmentStatus', { unique: false });\n+          courseStore.createIndex('paidAmount', 'paidAmount', { unique: false });\n+          courseStore.createIndex('unpaidAmount', 'unpaidAmount', { unique: false });\n+          courseStore.createIndex('startDate', 'startDate', { unique: false });\n+          courseStore.createIndex('endDate', 'endDate', { unique: false });\n+          courseStore.createIndex('relatedPaymentId', 'relatedPaymentId', { unique: false });\n+          courseStore.createIndex('createdAt', 'createdAt', { unique: false });\n+          // 복합 인덱스: 회원별 수강 조회 최적화\n+          courseStore.createIndex('memberStatus', ['memberId', 'enrollmentStatus'], { unique: false });\n+          // 지점별, 프로그램별 수강 조회 최적화\n+          courseStore.createIndex('branchProgram', ['branchId', 'programId'], { unique: false });\n+          // 코치별 수강 조회 최적화\n+          courseStore.createIndex('coachStatus', ['coach', 'enrollmentStatus'], { unique: false });\n+        }\n+\n         // 향후 다른 테이블들도 여기에 추가 가능\n         // 예: 회원, 방문기록 등\n         };\n       });\n@@ -1070,8 +1109,11 @@\n       );\n       await this.executeTransaction('points', 'readwrite', (store) => \n         store.clear()\n       );\n+      await this.executeTransaction('courseEnrollments', 'readwrite', (store) => \n+        store.clear()\n+      );\n       console.log('모든 데이터 삭제 완료');\n     } catch (error) {\n       console.error('데이터 삭제 실패:', error);\n       throw error;\n@@ -2499,2256 +2541,251 @@\n       console.error('포인트 내역 조회 실패:', error);\n       return [];\n     }\n   }\n-}\n \n-// 싱글톤 인스턴스 생성\n-export const dbManager = new IndexedDBManager();\n+  // ==================== 수강정보 관리 ====================\n \n-// 개발자 도구에서 사용할 수 있도록 전역 객체에 추가\n-if (typeof window !== 'undefined') {\n-  (window as any).dbManager = dbManager;\n-}\n-/**\n- * IndexedDB를 활용한 로컬 데이터베이스 관리 유틸리티\n- * 백엔드 연결 전까지 브라우저에서 데이터를 영구 저장\n- */\n-\n-import { SYSTEM_ADMIN_CONFIG } from '../constants/staffConstants';\n-\n-export interface DBRecord {\n-  id: string;\n-  createdAt: Date;\n-  updatedAt: Date;\n-}\n-\n-export interface Branch extends DBRecord {\n-  name: string;\n-  address?: string;\n-  phone?: string;\n-  isActive: boolean;\n-}\n-\n-export interface AppSettings extends DBRecord {\n-  key: string;\n-  value: string;\n-}\n-\n-export interface Staff extends DBRecord {\n-  name: string;\n-  loginId: string; // 로그인 ID\n-  password: string; // 비밀번호\n-  phone: string;\n-  email: string;\n-  branchId: string;\n-  position: string; // 직급\n-  role: string; // 직책\n-  employmentType: string; // 고용형태\n-  permission: string; // 권한\n-  program?: string; // 담당프로그램 (코치일 경우만)\n-  contractStartDate: Date;\n-  contractEndDate?: Date | null; // 계약종료일 (정규직은 없을 수 있음)\n-  contractFile?: File | null; // 계약서 파일\n-  contractFileName?: string; // 계약서 파일명 저장용\n-  contractFileData?: ArrayBuffer; // 계약서 파일 데이터 저장용\n-  workingHours?: {\n-    start: number; // 기본 근무 시작 시간 (시)\n-    end: number; // 기본 근무 종료 시간 (시)\n-  };\n-  isActive: boolean; // 활성/비활성 상태\n-}\n-\n-export interface Program extends DBRecord {\n-  name: string;\n-  type: string; // '횟수제' | '기간제'\n-  isActive: boolean;\n-}\n-\n-export interface Product extends DBRecord {\n-  name: string;\n-  branchId: string;\n-  programId: string;\n-  programName: string; // 프로그램명 저장 (조회 성능 향상)\n-  programType: string; // 프로그램 종류 저장 (조회 성능 향상)\n-  sessions?: number; // 횟수 (횟수제인 경우에만 필요)\n-  duration?: number; // 소요시간 (분 단위, 횟수제인 경우에만 필요)\n-  price?: number; // 가격\n-  description?: string; // 상품소개\n-  isActive: boolean;\n-}\n-\n-export interface HolidaySettings extends DBRecord {\n-  staffId: string;\n-  date: string; // YYYY-MM-DD 형식\n-  isHoliday: boolean; // true: 휴일, false: 근무일\n-  workingHours?: {\n-    start: number;\n-    end: number;\n-  }; // 해당 날짜의 근무시간 (휴일이 아닌 경우)\n-}\n-\n-export interface TermsDocument extends DBRecord {\n-  type: 'privacy_policy' | 'terms_of_service' | 'business_info' | 'marketing_consent' | 'member_terms' | 'contract';\n-  title: string;\n-  content: string;\n-  version: number; // 버전 관리\n-  isActive: boolean;\n-  publishedAt?: Date | null; // 발행일\n-}\n-\n-export interface Member extends DBRecord {\n-  name: string;\n-  phone: string;\n-  email: string;\n-  birth: string;\n-  gender: 'male' | 'female' | '';\n-  address: string;\n-  sigunguCode: string;\n-  dong: string;\n-  roadAddress: string;\n-  jibunAddress: string;\n-  branchId: string;\n-  branchName: string; // 조회 성능을 위해 저장\n-  coach: string; // 담당 코치 ID\n-  coachName: string; // 조회 성능을 위해 저장\n-  joinPath: string;\n-  loginId: string; // 로그인 ID (공란일 때는 임시값 생성)\n-  loginPassword: string | null; // 로그인 비밀번호 (공란 가능)\n-  enableLogin: boolean;\n-  agreementInfo: {\n-    agreements: Array<{\n-      id: string;\n-      title: string;\n-      content: string;\n-      required: boolean;\n-      agreed: boolean;\n-    }>;\n-    customerSignature: string;\n-    staffSignature: string;\n-  };\n-  isActive: boolean;\n-  // 추가 회원 정보 필드들\n-  registrationDate: string;\n-  agreementDate: string;\n-  signatureData: string;\n-  membershipType: string;\n-  duration: number;\n-  durationUnit: string;\n-  startDate: string;\n-  endDate: string;\n-  monthlyFee: number;\n-  totalAmount: number;\n-  discountAmount: number;\n-  finalAmount: number;\n-  paymentMethod: string;\n-  paymentDate: string;\n-  remarks: string;\n-}\n-\n-export interface Payment extends DBRecord {\n-  memberId: string;\n-  memberName: string; // 조회 성능을 위해 저장\n-  products: Array<{\n-    id: string;\n-    name: string;\n-    price: number;\n-    description?: string;\n-  }>;\n-  totalAmount: number;\n-  paymentStatus: 'pending' | 'completed' | 'cancelled' | 'refunded';\n-  paymentMethod?: string;\n-  paymentDate?: Date | null;\n-  notes?: string;\n-}\n-\n-class IndexedDBManager {\n-  private dbName: string = 'LavidaDB';\n-  private version: number = 9; // 버전 업데이트 (Member, Payment 테이블 추가)\n-  private db: IDBDatabase | null = null;\n-  private isInitializing: boolean = false; // 단순한 플래그로 변경\n-\n-  constructor() {\n-    this.initDB();\n-  }\n-\n   /**\n-   * IndexedDB 초기화\n+   * 수강정보 추가\n    */\n-  private async initDB(): Promise<void> {\n-    // 이미 초기화되었으면 바로 반환\n-    if (this.db) {\n-      console.log('IndexedDB가 이미 연결되어 있습니다.');\n-      return Promise.resolve();\n-    }\n-\n-    // 이미 초기화 중이면 대기\n-    if (this.isInitializing) {\n-      console.log('IndexedDB 초기화가 이미 진행 중입니다. 대기 중...');\n-      // 최대 5초까지 대기\n-      for (let i = 0; i < 50; i++) {\n-        await new Promise(resolve => setTimeout(resolve, 100));\n-        if (this.db) {\n-          return;\n-        }\n-      }\n-      throw new Error('IndexedDB 초기화 대기 시간 초과');\n-    }\n-\n-    console.log('IndexedDB 초기화를 시작합니다...');\n-    this.isInitializing = true;\n-    \n+  async addCourseEnrollment(enrollmentData: Omit<CourseEnrollment, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n     try {\n-      await new Promise<void>((resolve, reject) => {\n-        const request = indexedDB.open(this.dbName, this.version);\n-\n-        request.onerror = () => {\n-          console.error('❌ IndexedDB 열기 실패:', request.error);\n-          this.isInitializing = false;\n-          reject(request.error);\n-        };\n-\n-        request.onsuccess = () => {\n-          this.db = request.result;\n-          console.log('✅ IndexedDB 연결 성공');\n-          \n-          // DB 연결 오류 핸들러 설정\n-          this.db.onerror = (event) => {\n-            console.error('IndexedDB 오류:', event);\n-          };\n-          \n-          this.isInitializing = false;\n-          resolve();\n-        };\n-\n-        request.onupgradeneeded = (event) => {\n-          console.log('🔄 IndexedDB 스키마 업데이트 중...');\n-          const db = (event.target as IDBOpenDBRequest).result;\n-\n-        // 지점 테이블 생성\n-        if (!db.objectStoreNames.contains('branches')) {\n-          const branchStore = db.createObjectStore('branches', { keyPath: 'id' });\n-          branchStore.createIndex('name', 'name', { unique: true }); // 지점명 고유 제약\n-          branchStore.createIndex('isActive', 'isActive', { unique: false });\n-          branchStore.createIndex('createdAt', 'createdAt', { unique: false });\n-        } else {\n-          // 기존 테이블이 있으면 인덱스 업데이트\n-          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n-          const branchStore = transaction.objectStore('branches');\n-          \n-          // 기존 name 인덱스 삭제 후 unique로 재생성\n-          if (branchStore.indexNames.contains('name')) {\n-            branchStore.deleteIndex('name');\n-          }\n-          branchStore.createIndex('name', 'name', { unique: true });\n-        }\n-\n-        // 직원 테이블 생성\n-        if (!db.objectStoreNames.contains('staff')) {\n-          const staffStore = db.createObjectStore('staff', { keyPath: 'id' });\n-          staffStore.createIndex('name', 'name', { unique: false });\n-          staffStore.createIndex('loginId', 'loginId', { unique: true });\n-          staffStore.createIndex('email', 'email', { unique: true });\n-          staffStore.createIndex('branchId', 'branchId', { unique: false });\n-          staffStore.createIndex('position', 'position', { unique: false });\n-          staffStore.createIndex('role', 'role', { unique: false });\n-          staffStore.createIndex('employmentType', 'employmentType', { unique: false });\n-          staffStore.createIndex('permission', 'permission', { unique: false });\n-          staffStore.createIndex('isActive', 'isActive', { unique: false });\n-          staffStore.createIndex('createdAt', 'createdAt', { unique: false });\n-        } else {\n-          // 기존 테이블이 있으면 인덱스 업데이트 (isActive 인덱스 추가)\n-          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n-          const staffStore = transaction.objectStore('staff');\n-          \n-          if (!staffStore.indexNames.contains('isActive')) {\n-            staffStore.createIndex('isActive', 'isActive', { unique: false });\n-          }\n-        }\n-\n-        // 프로그램 테이블 생성\n-        if (!db.objectStoreNames.contains('programs')) {\n-          const programStore = db.createObjectStore('programs', { keyPath: 'id' });\n-          programStore.createIndex('name', 'name', { unique: true }); // 프로그램명 고유 제약\n-          programStore.createIndex('type', 'type', { unique: false });\n-          programStore.createIndex('isActive', 'isActive', { unique: false });\n-          programStore.createIndex('createdAt', 'createdAt', { unique: false });\n-        } else {\n-          // 기존 테이블이 있으면 인덱스 업데이트\n-          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n-          const programStore = transaction.objectStore('programs');\n-          \n-          // 기존 name 인덱스 삭제 후 unique로 재생성\n-          if (programStore.indexNames.contains('name')) {\n-            programStore.deleteIndex('name');\n-          }\n-          programStore.createIndex('name', 'name', { unique: true });\n-        }\n-\n-        // 상품 테이블 생성\n-        if (!db.objectStoreNames.contains('products')) {\n-          const productStore = db.createObjectStore('products', { keyPath: 'id' });\n-          productStore.createIndex('name', 'name', { unique: false });\n-          productStore.createIndex('branchId', 'branchId', { unique: false });\n-          productStore.createIndex('programId', 'programId', { unique: false });\n-          productStore.createIndex('programType', 'programType', { unique: false });\n-          productStore.createIndex('isActive', 'isActive', { unique: false });\n-          productStore.createIndex('createdAt', 'createdAt', { unique: false });\n-          // 복합 인덱스: 지점별, 프로그램별 조회 최적화\n-          productStore.createIndex('branchProgram', ['branchId', 'programId'], { unique: false });\n-        }\n-\n-        // 휴일설정 테이블 생성\n-        if (!db.objectStoreNames.contains('holidaySettings')) {\n-          const holidayStore = db.createObjectStore('holidaySettings', { keyPath: 'id' });\n-          holidayStore.createIndex('staffId', 'staffId', { unique: false });\n-          holidayStore.createIndex('date', 'date', { unique: false });\n-          holidayStore.createIndex('isHoliday', 'isHoliday', { unique: false });\n-          // 복합 인덱스: 직원별, 날짜별 조회 최적화\n-          holidayStore.createIndex('staffDate', ['staffId', 'date'], { unique: true });\n-        }\n-\n-        // 약관/문서 테이블 생성\n-        if (!db.objectStoreNames.contains('termsDocuments')) {\n-          const termsStore = db.createObjectStore('termsDocuments', { keyPath: 'id' });\n-          termsStore.createIndex('type', 'type', { unique: false });\n-          termsStore.createIndex('language', 'language', { unique: false });\n-          termsStore.createIndex('title', 'title', { unique: false });\n-          termsStore.createIndex('version', 'version', { unique: false });\n-          termsStore.createIndex('isActive', 'isActive', { unique: false });\n-          termsStore.createIndex('publishedAt', 'publishedAt', { unique: false });\n-          termsStore.createIndex('createdAt', 'createdAt', { unique: false });\n-          // 복합 인덱스: 타입별, 언어별 조회 최적화\n-          termsStore.createIndex('typeLanguage', ['type', 'language'], { unique: false });\n-          // 활성 상태 및 최신 버전 조회 최적화\n-          termsStore.createIndex('typeLanguageActive', ['type', 'language', 'isActive'], { unique: false });\n-        }\n-\n-        // 회원 테이블 생성\n-        if (!db.objectStoreNames.contains('members')) {\n-          const memberStore = db.createObjectStore('members', { keyPath: 'id' });\n-          memberStore.createIndex('name', 'name', { unique: false });\n-          memberStore.createIndex('phone', 'phone', { unique: true }); // 전화번호는 고유\n-          memberStore.createIndex('email', 'email', { unique: false });\n-          memberStore.createIndex('branchId', 'branchId', { unique: false });\n-          memberStore.createIndex('coach', 'coach', { unique: false });\n-          memberStore.createIndex('loginId', 'loginId', { unique: true }); // 로그인 ID는 고유\n-          memberStore.createIndex('isActive', 'isActive', { unique: false });\n-          memberStore.createIndex('createdAt', 'createdAt', { unique: false });\n-          // 복합 인덱스: 지점별 회원 조회 최적화\n-          memberStore.createIndex('branchActive', ['branchId', 'isActive'], { unique: false });\n-        }\n-\n-        // 결제 테이블 생성\n-        if (!db.objectStoreNames.contains('payments')) {\n-          const paymentStore = db.createObjectStore('payments', { keyPath: 'id' });\n-          paymentStore.createIndex('memberId', 'memberId', { unique: false });\n-          paymentStore.createIndex('memberName', 'memberName', { unique: false });\n-          paymentStore.createIndex('paymentStatus', 'paymentStatus', { unique: false });\n-          paymentStore.createIndex('paymentDate', 'paymentDate', { unique: false });\n-          paymentStore.createIndex('totalAmount', 'totalAmount', { unique: false });\n-          paymentStore.createIndex('createdAt', 'createdAt', { unique: false });\n-          // 복합 인덱스: 회원별 결제 조회 최적화\n-          paymentStore.createIndex('memberStatus', ['memberId', 'paymentStatus'], { unique: false });\n-        }\n-\n-        // 향후 다른 테이블들도 여기에 추가 가능\n-        // 예: 회원, 방문기록 등\n-        };\n-      });\n-    } catch (error) {\n-      console.error('❌ IndexedDB 초기화 중 오류:', error);\n-      this.isInitializing = false;\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 고유 ID 생성 (UUID v4 형식)\n-   */\n-  private generateUUID(): string {\n-    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n-      const r = Math.random() * 16 | 0;\n-      const v = c === 'x' ? r : ((r & 0x3) | 0x8);\n-      return v.toString(16);\n-    });\n-  }\n-\n-  /**\n-   * 트랜잭션 실행 헬퍼\n-   */\n-  private async executeTransaction<T>(\n-    storeName: string,\n-    mode: IDBTransactionMode,\n-    operation: (store: IDBObjectStore) => IDBRequest<T>\n-  ): Promise<T> {\n-    // DB가 없으면 최대 3번 초기화 시도\n-    if (!this.db) {\n-      for (let attempt = 1; attempt <= 3; attempt++) {\n-        try {\n-          await this.initDB();\n-          if (this.db) break;\n-        } catch (error) {\n-          if (attempt === 3) {\n-            throw new Error(`IndexedDB 초기화 실패 (${attempt}번 시도): ${error}`);\n-          }\n-          await new Promise(resolve => setTimeout(resolve, 100 * attempt));\n-        }\n-      }\n-    }\n-    \n-    if (!this.db) {\n-      throw new Error('IndexedDB 연결에 실패했습니다');\n-    }\n-\n-    return new Promise((resolve, reject) => {\n-      try {\n-        const transaction = this.db!.transaction([storeName], mode);\n-        const store = transaction.objectStore(storeName);\n-        \n-        transaction.onerror = () => {\n-          reject(transaction.error || new Error('트랜잭션 오류'));\n-        };\n-        \n-        transaction.onabort = () => {\n-          reject(new Error('트랜잭션이 중단되었습니다'));\n-        };\n-\n-        const request = operation(store);\n-        \n-        request.onsuccess = () => {\n-          resolve(request.result);\n-        };\n-        \n-        request.onerror = () => {\n-          reject(request.error || new Error('요청 오류'));\n-        };\n-      } catch (error) {\n-        reject(error);\n-      }\n-    });\n-  }\n-\n-  // === 지점 관리 메서드들 ===\n-\n-  /**\n-   * 모든 지점 조회\n-   */\n-  async getAllBranches(): Promise<Branch[]> {\n-    try {\n-      return await this.executeTransaction('branches', 'readonly', (store) => \n-        store.getAll()\n-      );\n-    } catch (error) {\n-      console.error('지점 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * ID로 지점 조회\n-   */\n-  async getBranchById(id: string): Promise<Branch | null> {\n-    try {\n-      const result = await this.executeTransaction('branches', 'readonly', (store) => \n-        store.get(id)\n-      );\n-      return result || null;\n-    } catch (error) {\n-      console.error('지점 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 지점 추가\n-   */\n-  async addBranch(branchData: Omit<Branch, 'id' | 'createdAt' | 'updatedAt'>): Promise<Branch> {\n-    const now = new Date();\n-    const newBranch: Branch = {\n-      ...branchData,\n-      id: this.generateUUID(),\n-      createdAt: now,\n-      updatedAt: now,\n-    };\n-\n-    try {\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.add(newBranch)\n-      );\n-      console.log('지점 추가 성공:', newBranch);\n-      return newBranch;\n-    } catch (error) {\n-      console.error('지점 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 지점 수정\n-   */\n-  async updateBranch(id: string, updates: Partial<Omit<Branch, 'id' | 'createdAt'>>): Promise<Branch | null> {\n-    try {\n-      const existing = await this.getBranchById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 지점입니다.');\n-      }\n-\n-      const updatedBranch: Branch = {\n-        ...existing,\n-        ...updates,\n+      const enrollment: CourseEnrollment = {\n+        id: this.generateUUID(),\n+        ...enrollmentData,\n+        createdAt: new Date(),\n         updatedAt: new Date(),\n       };\n \n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.put(updatedBranch)\n+      await this.executeTransaction('courseEnrollments', 'readwrite', (store) => \n+        store.add(enrollment)\n       );\n \n-      console.log('지점 수정 성공:', updatedBranch);\n-      return updatedBranch;\n+      console.log('수강정보 추가 성공:', enrollment.id);\n+      return enrollment.id;\n     } catch (error) {\n-      console.error('지점 수정 실패:', error);\n+      console.error('수강정보 추가 실패:', error);\n       throw error;\n     }\n   }\n \n   /**\n-   * 지점 삭제\n+   * 모든 수강정보 조회\n    */\n-  async deleteBranch(id: string): Promise<boolean> {\n+  async getAllCourseEnrollments(): Promise<CourseEnrollment[]> {\n     try {\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-      console.log('지점 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('지점 삭제 실패:', error);\n-      return false;\n-    }\n-  }\n-\n-  /**\n-   * 활성 지점만 조회\n-   */\n-  async getActiveBranches(): Promise<Branch[]> {\n-    try {\n-      return await this.executeTransaction('branches', 'readonly', (store) => {\n-        const index = store.index('isActive');\n-        return index.getAll(IDBKeyRange.only(true));\n-      });\n-    } catch (error) {\n-      console.error('활성 지점 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 지점명으로 정확히 일치하는 지점 조회 또는 생성 (원자적 처리)\n-   * 동시 실행 시 race condition 방지\n-   */\n-  async getOrCreateBranchByName(name: string, branchData?: Omit<Branch, 'id' | 'createdAt' | 'updatedAt' | 'name'>): Promise<Branch> {\n-    if (!this.db) {\n-      await this.initDB();\n-    }\n-\n-    return new Promise((resolve, reject) => {\n-      const transaction = this.db!.transaction(['branches'], 'readwrite');\n-      const store = transaction.objectStore('branches');\n-      const index = store.index('name');\n-      \n-      // 먼저 기존 지점 확인\n-      const getRequest = index.get(name);\n-      \n-      getRequest.onsuccess = () => {\n-        if (getRequest.result) {\n-          // 이미 존재함\n-          resolve(getRequest.result);\n-        } else {\n-          // 존재하지 않음, 새로 생성\n-          const now = new Date();\n-          const newBranch: Branch = {\n-            name,\n-            address: branchData?.address || '',\n-            phone: branchData?.phone || '',\n-            isActive: branchData?.isActive ?? true,\n-            id: this.generateUUID(),\n-            createdAt: now,\n-            updatedAt: now,\n-          };\n-\n-          const addRequest = store.add(newBranch);\n-          addRequest.onsuccess = () => {\n-            console.log('새 지점 생성 완료:', newBranch);\n-            resolve(newBranch);\n-          };\n-          addRequest.onerror = () => {\n-            console.error('지점 추가 실패:', addRequest.error);\n-            reject(addRequest.error);\n-          };\n-        }\n-      };\n-      \n-      getRequest.onerror = () => {\n-        console.error('지점 조회 실패:', getRequest.error);\n-        reject(getRequest.error);\n-      };\n-    });\n-  }\n-\n-  /**\n-   * 지점명으로 정확히 일치하는 지점 조회\n-   */\n-  async getBranchByName(name: string): Promise<Branch | null> {\n-    try {\n-      const allBranches = await this.getAllBranches();\n-      const branch = allBranches.find(branch => branch.name === name);\n-      return branch || null;\n-    } catch (error) {\n-      console.error('지점명으로 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 지점명으로 검색\n-   */\n-  async searchBranchesByName(name: string): Promise<Branch[]> {\n-    try {\n-      const allBranches = await this.getAllBranches();\n-      return allBranches.filter(branch => \n-        branch.name.toLowerCase().includes(name.toLowerCase())\n-      );\n-    } catch (error) {\n-      console.error('지점 검색 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  // === 직원 관리 메서드들 ===\n-\n-  /**\n-   * 모든 직원 조회\n-   */\n-  async getAllStaff(): Promise<Staff[]> {\n-    try {\n-      const staffList = await this.executeTransaction('staff', 'readonly', (store) => \n+      return await this.executeTransaction('courseEnrollments', 'readonly', (store) => \n         store.getAll()\n       );\n-\n-      // 저장된 파일 데이터를 File 객체로 복원\n-      return staffList.map(staff => {\n-        if (staff.contractFileData && staff.contractFileName) {\n-          // 파일 확장자로부터 MIME 타입 추정\n-          const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n-          let mimeType = 'application/octet-stream';\n-          \n-          if (extension === 'pdf') {\n-            mimeType = 'application/pdf';\n-          } else if (['jpg', 'jpeg'].includes(extension || '')) {\n-            mimeType = 'image/jpeg';\n-          } else if (extension === 'png') {\n-            mimeType = 'image/png';\n-          }\n-\n-          staff.contractFile = this.arrayBufferToFile(\n-            staff.contractFileData, \n-            staff.contractFileName, \n-            mimeType\n-          );\n-        }\n-        return staff;\n-      });\n     } catch (error) {\n-      console.error('직원 조회 실패:', error);\n+      console.error('수강정보 목록 조회 실패:', error);\n       return [];\n     }\n   }\n \n   /**\n-   * ID로 직원 조회\n+   * ID로 수강정보 조회\n    */\n-  async getStaffById(id: string): Promise<Staff | null> {\n+  async getCourseEnrollmentById(id: string): Promise<CourseEnrollment | null> {\n     try {\n-      const staff = await this.executeTransaction('staff', 'readonly', (store) => \n+      return await this.executeTransaction('courseEnrollments', 'readonly', (store) => \n         store.get(id)\n-      );\n-\n-      if (!staff) return null;\n-\n-      // 저장된 파일 데이터를 File 객체로 복원\n-      if (staff.contractFileData && staff.contractFileName) {\n-        const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n-        let mimeType = 'application/octet-stream';\n-        \n-        if (extension === 'pdf') {\n-          mimeType = 'application/pdf';\n-        } else if (['jpg', 'jpeg'].includes(extension || '')) {\n-          mimeType = 'image/jpeg';\n-        } else if (extension === 'png') {\n-          mimeType = 'image/png';\n-        }\n-\n-        staff.contractFile = this.arrayBufferToFile(\n-          staff.contractFileData, \n-          staff.contractFileName, \n-          mimeType\n-        );\n-      }\n-\n-      return staff;\n+      ) || null;\n     } catch (error) {\n-      console.error('직원 조회 실패:', error);\n+      console.error('수강정보 조회 실패:', error);\n       return null;\n     }\n   }\n \n   /**\n-   * 직원 추가\n+   * 회원별 수강정보 조회\n    */\n-  async addStaff(staffData: Omit<Staff, 'id' | 'createdAt' | 'updatedAt'>): Promise<Staff> {\n-    const now = new Date();\n-    \n-    // 파일 데이터 처리\n-    let contractFileData: ArrayBuffer | undefined;\n-    let contractFileName: string | undefined;\n-    \n-    if (staffData.contractFile) {\n-      contractFileData = await this.fileToArrayBuffer(staffData.contractFile);\n-      contractFileName = staffData.contractFile.name;\n-    }\n-\n-    const newStaff: Staff = {\n-      ...staffData,\n-      id: this.generateUUID(),\n-      createdAt: now,\n-      updatedAt: now,\n-      isActive: staffData.isActive !== undefined ? staffData.isActive : true, // 기본값 true\n-      contractFile: undefined, // File 객체는 저장하지 않음\n-      contractFileName,\n-      contractFileData,\n-    };\n-\n+  async getCourseEnrollmentsByMember(memberId: string): Promise<CourseEnrollment[]> {\n     try {\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.add(newStaff)\n-      );\n-      console.log('직원 추가 성공:', newStaff);\n-      return newStaff;\n-    } catch (error) {\n-      console.error('직원 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 시스템 관리자 계정인지 확인\n-   */\n-  private isSystemAdmin(staff: Staff): boolean {\n-    return staff.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID;\n-  }\n-\n-  /**\n-   * 시스템 관리자 보호 검증\n-   */\n-  private validateSystemAdminProtection(staff: Staff, operation: 'delete' | 'permission_change'): void {\n-    if (this.isSystemAdmin(staff)) {\n-      const message = operation === 'delete' \n-        ? '시스템 관리자 계정은 삭제할 수 없습니다.'\n-        : '시스템 관리자 계정의 권한은 변경할 수 없습니다.';\n-      throw new Error(message);\n-    }\n-  }\n-\n-  /**\n-   * 직원 수정\n-   */\n-  async updateStaff(id: string, updates: Partial<Omit<Staff, 'id' | 'createdAt'>>): Promise<Staff | null> {\n-    try {\n-      const existing = await this.getStaffById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 직원입니다.');\n-      }\n-\n-      // 시스템 관리자 권한 변경 보호\n-      if (updates.permission && updates.permission !== existing.permission) {\n-        this.validateSystemAdminProtection(existing, 'permission_change');\n-      }\n-\n-      // 파일 데이터 처리\n-      let contractFileData = existing.contractFileData;\n-      let contractFileName = existing.contractFileName;\n-      \n-      if (updates.contractFile) {\n-        contractFileData = await this.fileToArrayBuffer(updates.contractFile);\n-        contractFileName = updates.contractFile.name;\n-      }\n-\n-      const updatedStaff: Staff = {\n-        ...existing,\n-        ...updates,\n-        updatedAt: new Date(),\n-        contractFile: undefined, // File 객체는 저장하지 않음\n-        contractFileName,\n-        contractFileData,\n-      };\n-\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.put(updatedStaff)\n-      );\n-\n-      console.log('직원 수정 성공:', updatedStaff);\n-      return updatedStaff;\n-    } catch (error) {\n-      console.error('직원 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 직원 삭제\n-   */\n-  async deleteStaff(id: string): Promise<boolean> {\n-    try {\n-      const existing = await this.getStaffById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 직원입니다.');\n-      }\n-\n-      // 시스템 관리자 삭제 보호\n-      this.validateSystemAdminProtection(existing, 'delete');\n-\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-      console.log('직원 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('직원 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 직원 활성/비활성 상태 토글\n-   */\n-  async toggleStaffStatus(id: string): Promise<Staff | null> {\n-    try {\n-      const existing = await this.getStaffById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 직원입니다.');\n-      }\n-\n-      // 시스템 관리자 상태 변경 보호\n-      if (existing.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID) {\n-        throw new Error('시스템 관리자 계정의 상태는 변경할 수 없습니다.');\n-      }\n-\n-      const updatedStaff = {\n-        ...existing,\n-        isActive: !existing.isActive,\n-        updatedAt: new Date()\n-      };\n-\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.put(updatedStaff)\n-      );\n-\n-      console.log('직원 상태 변경 성공:', id, `-> ${updatedStaff.isActive ? '활성' : '비활성'}`);\n-      return updatedStaff;\n-    } catch (error) {\n-      console.error('직원 상태 변경 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 지점별 직원 조회\n-   */\n-  async getStaffByBranch(branchId: string): Promise<Staff[]> {\n-    try {\n-      return await this.executeTransaction('staff', 'readonly', (store) => {\n-        const index = store.index('branchId');\n-        return index.getAll(IDBKeyRange.only(branchId));\n+      return await this.executeTransaction('courseEnrollments', 'readonly', (store) => {\n+        const index = store.index('memberId');\n+        return index.getAll(memberId);\n       });\n     } catch (error) {\n-      console.error('지점별 직원 조회 실패:', error);\n+      console.error('회원별 수강정보 조회 실패:', error);\n       return [];\n     }\n   }\n \n   /**\n-   * 이메일로 직원 조회\n+   * 지점별 수강정보 조회\n    */\n-  async getStaffByEmail(email: string): Promise<Staff | null> {\n+  async getCourseEnrollmentsByBranch(branchId: string): Promise<CourseEnrollment[]> {\n     try {\n-      const result = await this.executeTransaction('staff', 'readonly', (store) => {\n-        const index = store.index('email');\n-        return index.get(email);\n-      });\n-      return result || null;\n-    } catch (error) {\n-      console.error('이메일로 직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 로그인ID로 직원 조회\n-   */\n-  async getStaffByLoginId(loginId: string): Promise<Staff | null> {\n-    try {\n-      const staff = await this.executeTransaction('staff', 'readonly', (store) => {\n-        const index = store.index('loginId');\n-        return index.get(loginId);\n-      });\n-\n-      if (!staff) return null;\n-\n-      // 저장된 파일 데이터를 File 객체로 복원\n-      if (staff.contractFileData && staff.contractFileName) {\n-        const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n-        let mimeType = 'application/octet-stream';\n-        \n-        if (extension === 'pdf') {\n-          mimeType = 'application/pdf';\n-        } else if (['jpg', 'jpeg'].includes(extension || '')) {\n-          mimeType = 'image/jpeg';\n-        } else if (extension === 'png') {\n-          mimeType = 'image/png';\n-        }\n-\n-        staff.contractFile = this.arrayBufferToFile(\n-          staff.contractFileData, \n-          staff.contractFileName, \n-          mimeType\n-        );\n-      }\n-\n-      return staff;\n-    } catch (error) {\n-      console.error('로그인ID로 직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 전화번호로 직원 조회\n-   */\n-  async getStaffByPhone(phone: string): Promise<Staff | null> {\n-    try {\n-      const allStaff = await this.getAllStaff();\n-      const found = allStaff.find(staff => staff.phone === phone);\n-      return found || null;\n-    } catch (error) {\n-      console.error('전화번호로 직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 중복 체크 함수 (등록 시 사용)\n-   */\n-  async checkDuplicateStaff(loginId: string, email: string, phone: string): Promise<{\n-    isDuplicate: boolean;\n-    duplicateField?: 'loginId' | 'email' | 'phone';\n-    message?: string;\n-  }> {\n-    try {\n-      // 로그인 ID 중복 체크\n-      const existingByLoginId = await this.getStaffByLoginId(loginId);\n-      if (existingByLoginId) {\n-        return {\n-          isDuplicate: true,\n-          duplicateField: 'loginId',\n-          message: '이미 사용 중인 로그인 ID입니다.'\n-        };\n-      }\n-\n-      // 이메일 중복 체크\n-      const existingByEmail = await this.getStaffByEmail(email);\n-      if (existingByEmail) {\n-        return {\n-          isDuplicate: true,\n-          duplicateField: 'email',\n-          message: '이미 사용 중인 이메일입니다.'\n-        };\n-      }\n-\n-      // 전화번호 중복 체크\n-      const existingByPhone = await this.getStaffByPhone(phone);\n-      if (existingByPhone) {\n-        return {\n-          isDuplicate: true,\n-          duplicateField: 'phone',\n-          message: '이미 사용 중인 전화번호입니다.'\n-        };\n-      }\n-\n-      return { isDuplicate: false };\n-    } catch (error) {\n-      console.error('중복 체크 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 파일을 ArrayBuffer로 변환\n-   */\n-  private fileToArrayBuffer(file: File): Promise<ArrayBuffer> {\n-    return new Promise((resolve, reject) => {\n-      const reader = new FileReader();\n-      reader.onload = () => resolve(reader.result as ArrayBuffer);\n-      reader.onerror = () => reject(reader.error);\n-      reader.readAsArrayBuffer(file);\n-    });\n-  }\n-\n-  /**\n-   * ArrayBuffer를 Blob으로 변환 (파일 다운로드용)\n-   */\n-  arrayBufferToBlob(buffer: ArrayBuffer, mimeType: string): Blob {\n-    return new Blob([buffer], { type: mimeType });\n-  }\n-\n-  /**\n-   * ArrayBuffer를 File 객체로 변환\n-   */\n-  private arrayBufferToFile(buffer: ArrayBuffer, fileName: string, mimeType: string = 'application/octet-stream'): File {\n-    const blob = new Blob([buffer], { type: mimeType });\n-    return new File([blob], fileName, { type: mimeType });\n-  }\n-\n-  /**\n-   * 데이터베이스 초기화 (개발/테스트용)\n-   */\n-  async clearAllData(): Promise<void> {\n-    try {\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('programs', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('products', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      console.log('모든 데이터 삭제 완료');\n-    } catch (error) {\n-      console.error('데이터 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 기존 직원 데이터의 isActive 필드 초기화 (마이그레이션용)\n-   */\n-  async migrateStaffActiveStatus(): Promise<void> {\n-    try {\n-      const allStaff = await this.executeTransaction('staff', 'readonly', (store) => \n-        store.getAll()\n-      );\n-\n-      // isActive 필드가 없는 직원들을 찾아서 업데이트\n-      const staffToUpdate = allStaff.filter(staff => staff.isActive === undefined);\n-      \n-      if (staffToUpdate.length > 0) {\n-        console.log(`${staffToUpdate.length}명의 직원 isActive 필드를 초기화합니다.`);\n-        \n-        for (const staff of staffToUpdate) {\n-          const updatedStaff = {\n-            ...staff,\n-            isActive: true, // 기본값을 true로 설정\n-            updatedAt: new Date()\n-          };\n-          \n-          await this.executeTransaction('staff', 'readwrite', (store) => \n-            store.put(updatedStaff)\n-          );\n-        }\n-        \n-        console.log('직원 isActive 필드 초기화 완료');\n-      }\n-    } catch (error) {\n-      console.error('직원 isActive 필드 초기화 실패:', error);\n-    }\n-  }\n-\n-  // =================== 프로그램 관리 메서드 ===================\n-\n-  /**\n-   * 프로그램 추가\n-   */\n-  async addProgram(programData: Omit<Program, 'id' | 'createdAt' | 'updatedAt'>): Promise<Program> {\n-    try {\n-      // 프로그램명 중복 체크\n-      const existingProgram = await this.getProgramByName(programData.name);\n-      if (existingProgram) {\n-        throw new Error('이미 존재하는 프로그램명입니다.');\n-      }\n-\n-      const newProgram: Program = {\n-        id: this.generateUUID(),\n-        ...programData,\n-        createdAt: new Date(),\n-        updatedAt: new Date()\n-      };\n-\n-      await this.executeTransaction('programs', 'readwrite', (store) => \n-        store.add(newProgram)\n-      );\n-\n-      console.log('프로그램 추가 성공:', newProgram);\n-      return newProgram;\n-    } catch (error) {\n-      console.error('프로그램 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 모든 프로그램 조회\n-   */\n-  async getAllPrograms(): Promise<Program[]> {\n-    try {\n-      const programs = await this.executeTransaction('programs', 'readonly', (store) => \n-        store.getAll()\n-      );\n-      \n-      return programs.map(program => ({\n-        ...program,\n-        createdAt: new Date(program.createdAt),\n-        updatedAt: new Date(program.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('프로그램 목록 조회 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 프로그램명으로 조회\n-   */\n-  async getProgramByName(name: string): Promise<Program | null> {\n-    try {\n-      const program = await this.executeTransaction('programs', 'readonly', (store) => \n-        store.index('name').get(name)\n-      );\n-      \n-      if (program) {\n-        return {\n-          ...program,\n-          createdAt: new Date(program.createdAt),\n-          updatedAt: new Date(program.updatedAt)\n-        };\n-      }\n-      \n-      return null;\n-    } catch (error) {\n-      console.error('프로그램 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 프로그램 수정\n-   */\n-  async updateProgram(id: string, updates: Partial<Omit<Program, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Program | null> {\n-    try {\n-      const existingProgram = await this.executeTransaction('programs', 'readonly', (store) => \n-        store.get(id)\n-      );\n-\n-      if (!existingProgram) {\n-        console.error('수정할 프로그램을 찾을 수 없습니다:', id);\n-        return null;\n-      }\n-\n-      // 프로그램명 변경 시 중복 체크\n-      if (updates.name && updates.name !== existingProgram.name) {\n-        const duplicateProgram = await this.getProgramByName(updates.name);\n-        if (duplicateProgram) {\n-          throw new Error('이미 존재하는 프로그램명입니다.');\n-        }\n-      }\n-\n-      const updatedProgram: Program = {\n-        ...existingProgram,\n-        ...updates,\n-        id,\n-        createdAt: new Date(existingProgram.createdAt),\n-        updatedAt: new Date()\n-      };\n-\n-      await this.executeTransaction('programs', 'readwrite', (store) => \n-        store.put(updatedProgram)\n-      );\n-\n-      console.log('프로그램 수정 성공:', updatedProgram);\n-      return updatedProgram;\n-    } catch (error) {\n-      console.error('프로그램 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 프로그램 삭제\n-   */\n-  async deleteProgram(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('programs', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-\n-      console.log('프로그램 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('프로그램 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  // =================== 상품 관리 메서드 ===================\n-\n-  /**\n-   * 상품 추가\n-   */\n-  async addProduct(productData: Omit<Product, 'id' | 'createdAt' | 'updatedAt'>): Promise<Product> {\n-    try {\n-      const newProduct: Product = {\n-        id: this.generateUUID(),\n-        ...productData,\n-        createdAt: new Date(),\n-        updatedAt: new Date()\n-      };\n-\n-      await this.executeTransaction('products', 'readwrite', (store) => \n-        store.add(newProduct)\n-      );\n-\n-      console.log('상품 추가 성공:', newProduct);\n-      return newProduct;\n-    } catch (error) {\n-      console.error('상품 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 모든 상품 조회\n-   */\n-  async getAllProducts(): Promise<Product[]> {\n-    try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => \n-        store.getAll()\n-      );\n-      \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('상품 목록 조회 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * ID로 상품 조회\n-   */\n-  async getProductById(id: string): Promise<Product | null> {\n-    try {\n-      const product = await this.executeTransaction('products', 'readonly', (store) => \n-        store.get(id)\n-      );\n-      \n-      if (product) {\n-        return {\n-          ...product,\n-          createdAt: new Date(product.createdAt),\n-          updatedAt: new Date(product.updatedAt)\n-        };\n-      }\n-      \n-      return null;\n-    } catch (error) {\n-      console.error('상품 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 지점별 상품 조회\n-   */\n-  async getProductsByBranch(branchId: string): Promise<Product[]> {\n-    try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => {\n+      return await this.executeTransaction('courseEnrollments', 'readonly', (store) => {\n         const index = store.index('branchId');\n-        return index.getAll(IDBKeyRange.only(branchId));\n+        return index.getAll(branchId);\n       });\n-      \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n     } catch (error) {\n-      console.error('지점별 상품 조회 실패:', error);\n+      console.error('지점별 수강정보 조회 실패:', error);\n       return [];\n     }\n   }\n \n   /**\n-   * 프로그램별 상품 조회\n+   * 코치별 수강정보 조회\n    */\n-  async getProductsByProgram(programId: string): Promise<Product[]> {\n+  async getCourseEnrollmentsByCoach(coachId: string): Promise<CourseEnrollment[]> {\n     try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => {\n-        const index = store.index('programId');\n-        return index.getAll(IDBKeyRange.only(programId));\n+      return await this.executeTransaction('courseEnrollments', 'readonly', (store) => {\n+        const index = store.index('coach');\n+        return index.getAll(coachId);\n       });\n-      \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n     } catch (error) {\n-      console.error('프로그램별 상품 조회 실패:', error);\n+      console.error('코치별 수강정보 조회 실패:', error);\n       return [];\n     }\n   }\n \n   /**\n-   * 지점과 프로그램으로 상품 조회\n+   * 수강상태별 수강정보 조회\n    */\n-  async getProductsByBranchAndProgram(branchId: string, programId: string): Promise<Product[]> {\n+  async getCourseEnrollmentsByStatus(status: 'completed' | 'unpaid'): Promise<CourseEnrollment[]> {\n     try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => {\n-        const index = store.index('branchProgram');\n-        return index.getAll(IDBKeyRange.only([branchId, programId]));\n+      return await this.executeTransaction('courseEnrollments', 'readonly', (store) => {\n+        const index = store.index('enrollmentStatus');\n+        return index.getAll(status);\n       });\n-      \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n     } catch (error) {\n-      console.error('지점-프로그램별 상품 조회 실패:', error);\n+      console.error('상태별 수강정보 조회 실패:', error);\n       return [];\n     }\n   }\n \n   /**\n-   * 상품 수정\n+   * 프로그램별 수강정보 조회\n    */\n-  async updateProduct(id: string, updates: Partial<Omit<Product, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Product | null> {\n+  async getCourseEnrollmentsByProgram(programId: string): Promise<CourseEnrollment[]> {\n     try {\n-      const existingProduct = await this.executeTransaction('products', 'readonly', (store) => \n-        store.get(id)\n-      );\n-\n-      if (!existingProduct) {\n-        console.error('수정할 상품을 찾을 수 없습니다:', id);\n-        return null;\n-      }\n-\n-      const updatedProduct: Product = {\n-        ...existingProduct,\n-        ...updates,\n-        id,\n-        createdAt: new Date(existingProduct.createdAt),\n-        updatedAt: new Date()\n-      };\n-\n-      await this.executeTransaction('products', 'readwrite', (store) => \n-        store.put(updatedProduct)\n-      );\n-\n-      console.log('상품 수정 성공:', updatedProduct);\n-      return updatedProduct;\n-    } catch (error) {\n-      console.error('상품 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 상품 삭제\n-   */\n-  async deleteProduct(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('products', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-\n-      console.log('상품 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('상품 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 활성 상품만 조회\n-   */\n-  async getActiveProducts(): Promise<Product[]> {\n-    try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => {\n-        const index = store.index('isActive');\n-        return index.getAll(IDBKeyRange.only(true));\n+      return await this.executeTransaction('courseEnrollments', 'readonly', (store) => {\n+        const index = store.index('programId');\n+        return index.getAll(programId);\n       });\n-      \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n     } catch (error) {\n-      console.error('활성 상품 조회 실패:', error);\n+      console.error('프로그램별 수강정보 조회 실패:', error);\n       return [];\n     }\n   }\n \n   /**\n-   * 상품명으로 검색\n+   * 미수 수강정보 조회 (회원별)\n    */\n-  async searchProductsByName(name: string): Promise<Product[]> {\n+  async getUnpaidCourseEnrollmentsByMember(memberId: string): Promise<CourseEnrollment[]> {\n     try {\n-      const allProducts = await this.getAllProducts();\n-      return allProducts.filter(product => \n-        product.name.toLowerCase().includes(name.toLowerCase())\n-      );\n-    } catch (error) {\n-      console.error('상품 검색 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  // ==================== 휴일설정 관련 메서드 ====================\n-\n-  /**\n-   * 휴일설정 추가/업데이트\n-   */\n-  async saveHolidaySettings(settingsArray: Omit<HolidaySettings, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<HolidaySettings[]> {\n-    try {\n-      const savedSettings: HolidaySettings[] = [];\n-      \n-      for (const setting of settingsArray) {\n-        // 기존 설정이 있는지 확인\n-        const existingSettings = await this.getHolidaySettingsByStaffAndDate(setting.staffId, setting.date);\n-        \n-        let savedSetting: HolidaySettings;\n-        \n-        if (existingSettings.length > 0) {\n-          // 업데이트\n-          const existing = existingSettings[0];\n-          savedSetting = {\n-            ...existing,\n-            ...setting,\n-            updatedAt: new Date()\n-          };\n-          \n-          await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n-            store.put(savedSetting)\n-          );\n-        } else {\n-          // 새로 추가\n-          savedSetting = {\n-            ...setting,\n-            id: this.generateUUID(),\n-            createdAt: new Date(),\n-            updatedAt: new Date()\n-          };\n-          \n-          await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n-            store.add(savedSetting)\n-          );\n-        }\n-        \n-        savedSettings.push(savedSetting);\n-      }\n-\n-      console.log('휴일설정 저장 성공:', savedSettings.length);\n-      return savedSettings;\n-    } catch (error) {\n-      console.error('휴일설정 저장 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 특정 직원의 모든 휴일설정 조회\n-   */\n-  async getHolidaySettingsByStaff(staffId: string): Promise<HolidaySettings[]> {\n-    try {\n-      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n-        const index = store.index('staffId');\n-        return index.getAll(IDBKeyRange.only(staffId));\n+      return await this.executeTransaction('courseEnrollments', 'readonly', (store) => {\n+        const index = store.index('memberStatus');\n+        return index.getAll([memberId, 'unpaid']);\n       });\n-      \n-      return settings.map(setting => ({\n-        ...setting,\n-        createdAt: new Date(setting.createdAt),\n-        updatedAt: new Date(setting.updatedAt)\n-      }));\n     } catch (error) {\n-      console.error('직원별 휴일설정 조회 실패:', error);\n+      console.error('회원별 미수 수강정보 조회 실패:', error);\n       return [];\n     }\n   }\n \n   /**\n-   * 특정 직원의 특정 날짜 휴일설정 조회\n+   * 수강정보 수정\n    */\n-  async getHolidaySettingsByStaffAndDate(staffId: string, date: string): Promise<HolidaySettings[]> {\n+  async updateCourseEnrollment(id: string, updates: Partial<Omit<CourseEnrollment, 'id' | 'createdAt'>>): Promise<boolean> {\n     try {\n-      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n-        const index = store.index('staffDate');\n-        return index.getAll(IDBKeyRange.only([staffId, date]));\n-      });\n-      \n-      return settings.map(setting => ({\n-        ...setting,\n-        createdAt: new Date(setting.createdAt),\n-        updatedAt: new Date(setting.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('직원별 날짜별 휴일설정 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 특정 날짜의 모든 휴일설정 조회\n-   */\n-  async getHolidaySettingsByDate(date: string): Promise<HolidaySettings[]> {\n-    try {\n-      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n-        const index = store.index('date');\n-        return index.getAll(IDBKeyRange.only(date));\n-      });\n-      \n-      return settings.map(setting => ({\n-        ...setting,\n-        createdAt: new Date(setting.createdAt),\n-        updatedAt: new Date(setting.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('날짜별 휴일설정 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 날짜 범위의 휴일설정 조회\n-   */\n-  async getHolidaySettingsByDateRange(startDate: string, endDate: string): Promise<HolidaySettings[]> {\n-    try {\n-      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n-        const index = store.index('date');\n-        return index.getAll(IDBKeyRange.bound(startDate, endDate));\n-      });\n-      \n-      return settings.map(setting => ({\n-        ...setting,\n-        createdAt: new Date(setting.createdAt),\n-        updatedAt: new Date(setting.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('날짜 범위별 휴일설정 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 휴일설정 삭제\n-   */\n-  async deleteHolidaySettings(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-\n-      console.log('휴일설정 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('휴일설정 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 특정 직원의 모든 휴일설정 삭제\n-   */\n-  async deleteHolidaySettingsByStaff(staffId: string): Promise<boolean> {\n-    try {\n-      const settings = await this.getHolidaySettingsByStaff(staffId);\n-      \n-      for (const setting of settings) {\n-        await this.deleteHolidaySettings(setting.id);\n+      const existingEnrollment = await this.getCourseEnrollmentById(id);\n+      if (!existingEnrollment) {\n+        throw new Error('수정할 수강정보를 찾을 수 없습니다.');\n       }\n \n-      console.log('직원 휴일설정 전체 삭제 성공:', staffId);\n-      return true;\n-    } catch (error) {\n-      console.error('직원 휴일설정 전체 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  // ==================== 약관/문서 관련 메서드 ====================\n-\n-  /**\n-   * 약관/문서 추가\n-   */\n-  async addTermsDocument(documentData: Omit<TermsDocument, 'id' | 'createdAt' | 'updatedAt' | 'version'>): Promise<TermsDocument> {\n-    try {\n-      // 같은 타입의 기존 문서들의 최대 버전 찾기\n-      const existingDocs = await this.getTermsDocumentsByType(documentData.type);\n-      const maxVersion = existingDocs.length > 0 ? Math.max(...existingDocs.map(doc => doc.version)) : 0;\n-\n-      // 기존 활성 문서들 비활성화\n-      for (const doc of existingDocs.filter(d => d.isActive)) {\n-        await this.updateTermsDocument(doc.id, { isActive: false });\n-      }\n-\n-      const newDocument: TermsDocument = {\n-        ...documentData,\n-        id: this.generateUUID(),\n-        version: maxVersion + 1,\n-        createdAt: new Date(),\n-        updatedAt: new Date(),\n-        publishedAt: documentData.isActive ? new Date() : null\n-      };\n-\n-      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n-        store.add(newDocument)\n-      );\n-\n-      console.log('약관/문서 추가 성공:', newDocument);\n-      return newDocument;\n-    } catch (error) {\n-      console.error('약관/문서 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 모든 약관/문서 조회\n-   */\n-  async getAllTermsDocuments(): Promise<TermsDocument[]> {\n-    try {\n-      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n-        store.getAll()\n-      );\n-      \n-      return documents.map(doc => ({\n-        ...doc,\n-        createdAt: new Date(doc.createdAt),\n-        updatedAt: new Date(doc.updatedAt),\n-        publishedAt: doc.publishedAt ? new Date(doc.publishedAt) : null\n-      }));\n-    } catch (error) {\n-      console.error('약관/문서 목록 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * ID로 약관/문서 조회\n-   */\n-  async getTermsDocumentById(id: string): Promise<TermsDocument | null> {\n-    try {\n-      const document = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n-        store.get(id)\n-      );\n-      \n-      if (document) {\n-        return {\n-          ...document,\n-          createdAt: new Date(document.createdAt),\n-          updatedAt: new Date(document.updatedAt),\n-          publishedAt: document.publishedAt ? new Date(document.publishedAt) : null\n-        };\n-      }\n-      \n-      return null;\n-    } catch (error) {\n-      console.error('약관/문서 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 타입별 약관/문서 조회\n-   */\n-  async getTermsDocumentsByType(type: TermsDocument['type']): Promise<TermsDocument[]> {\n-    try {\n-      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => {\n-        return store.getAll();\n-      });\n-      \n-      const filteredDocs = documents.filter(doc => doc.type === type);\n-      \n-      return filteredDocs.map(doc => ({\n-        ...doc,\n-        createdAt: new Date(doc.createdAt),\n-        updatedAt: new Date(doc.updatedAt),\n-        publishedAt: doc.publishedAt ? new Date(doc.publishedAt) : null\n-      })).sort((a, b) => b.version - a.version); // 최신 버전부터\n-    } catch (error) {\n-      console.error('타입별 약관/문서 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 활성화된 약관/문서만 조회 (타입별)\n-   */\n-  async getActiveTermsDocument(type: TermsDocument['type']): Promise<TermsDocument | null> {\n-    try {\n-      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => {\n-        return store.getAll();\n-      });\n-      \n-      const activeDoc = documents.find(doc => doc.type === type && doc.isActive);\n-      \n-      if (!activeDoc) return null;\n-\n-      return {\n-        ...activeDoc,\n-        createdAt: new Date(activeDoc.createdAt),\n-        updatedAt: new Date(activeDoc.updatedAt),\n-        publishedAt: activeDoc.publishedAt ? new Date(activeDoc.publishedAt) : null\n-      };\n-    } catch (error) {\n-      console.error('활성 약관/문서 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 약관/문서 수정\n-   */\n-  async updateTermsDocument(id: string, updates: Partial<Omit<TermsDocument, 'id' | 'createdAt' | 'updatedAt' | 'version'>>): Promise<TermsDocument | null> {\n-    try {\n-      const existingDocument = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n-        store.get(id)\n-      );\n-\n-      if (!existingDocument) {\n-        console.error('수정할 약관/문서를 찾을 수 없습니다:', id);\n-        return null;\n-      }\n-\n-      // 활성화 시 같은 타입의 다른 문서들 비활성화\n-      if (updates.isActive === true && !existingDocument.isActive) {\n-        const otherDocs = await this.getTermsDocumentsByType(existingDocument.type);\n-        for (const doc of otherDocs.filter((d: TermsDocument) => d.id !== id && d.isActive)) {\n-          await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n-            store.put({\n-              ...doc,\n-              isActive: false,\n-              updatedAt: new Date()\n-            })\n-          );\n-        }\n-      }\n-\n-      const updatedDocument: TermsDocument = {\n-        ...existingDocument,\n+      const updatedEnrollment: CourseEnrollment = {\n+        ...existingEnrollment,\n         ...updates,\n-        id,\n-        createdAt: new Date(existingDocument.createdAt),\n         updatedAt: new Date(),\n-        publishedAt: updates.isActive === true && !existingDocument.isActive ? new Date() : \n-                    updates.isActive === false ? null : \n-                    existingDocument.publishedAt\n       };\n \n-      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n-        store.put(updatedDocument)\n+      await this.executeTransaction('courseEnrollments', 'readwrite', (store) => \n+        store.put(updatedEnrollment)\n       );\n \n-      console.log('약관/문서 수정 성공:', updatedDocument);\n-      return updatedDocument;\n+      console.log('수강정보 수정 성공:', id);\n+      return true;\n     } catch (error) {\n-      console.error('약관/문서 수정 실패:', error);\n+      console.error('수강정보 수정 실패:', error);\n       throw error;\n     }\n   }\n \n   /**\n-   * 약관/문서 삭제\n+   * 수강정보 삭제\n    */\n-  async deleteTermsDocument(id: string): Promise<boolean> {\n+  async deleteCourseEnrollment(id: string): Promise<boolean> {\n     try {\n-      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n+      await this.executeTransaction('courseEnrollments', 'readwrite', (store) => \n         store.delete(id)\n       );\n \n-      console.log('약관/문서 삭제 성공:', id);\n+      console.log('수강정보 삭제 성공:', id);\n       return true;\n     } catch (error) {\n-      console.error('약관/문서 삭제 실패:', error);\n+      console.error('수강정보 삭제 실패:', error);\n       throw error;\n     }\n   }\n \n   /**\n-   * 약관/문서 검색 (제목, 내용)\n+   * 수강정보 검색 (회원명, 상품명, 프로그램명으로 검색)\n    */\n-  async searchTermsDocuments(searchTerm: string): Promise<TermsDocument[]> {\n+  async searchCourseEnrollments(searchTerm: string): Promise<CourseEnrollment[]> {\n     try {\n-      const allDocuments = await this.getAllTermsDocuments();\n+      const allEnrollments = await this.getAllCourseEnrollments();\n       const lowerSearchTerm = searchTerm.toLowerCase();\n       \n-      return allDocuments.filter(doc => \n-        doc.title.toLowerCase().includes(lowerSearchTerm) ||\n-        doc.content.toLowerCase().includes(lowerSearchTerm)\n+      return allEnrollments.filter(enrollment => \n+        enrollment.memberName.toLowerCase().includes(lowerSearchTerm) ||\n+        enrollment.productName.toLowerCase().includes(lowerSearchTerm) ||\n+        enrollment.programName.toLowerCase().includes(lowerSearchTerm) ||\n+        enrollment.branchName.toLowerCase().includes(lowerSearchTerm) ||\n+        enrollment.coachName.toLowerCase().includes(lowerSearchTerm)\n       );\n     } catch (error) {\n-      console.error('약관/문서 검색 실패:', error);\n+      console.error('수강정보 검색 실패:', error);\n       return [];\n     }\n   }\n \n-  // ==================== 회원 관리 ====================\n-\n   /**\n-   * 회원 추가\n+   * 회원의 미수 총액 계산\n    */\n-  async addMember(memberData: Omit<Member, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n+  async getMemberUnpaidTotal(memberId: string): Promise<number> {\n     try {\n-      console.log('=== addMember 함수 시작 ===');\n-      console.log('받은 memberData:', memberData);\n-      \n-      // 데이터베이스 연결 확인\n-      if (!this.db) {\n-        console.log('데이터베이스가 연결되지 않음, 초기화 시도...');\n-        await this.initDB();\n-      }\n-      console.log('데이터베이스 연결 상태:', this.db ? '연결됨' : '연결 안됨');\n-      \n-      const member: Member = {\n-        id: this.generateUUID(),\n-        ...memberData,\n-        createdAt: new Date(),\n-        updatedAt: new Date(),\n-      };\n-\n-      console.log('생성할 회원 객체:', member);\n-      console.log('회원 ID:', member.id);\n-      \n-      console.log('트랜잭션 시작...');\n-      await this.executeTransaction('members', 'readwrite', (store) => {\n-        console.log('store.add 실행 중...');\n-        console.log('추가할 멤버 객체:', member);\n-        try {\n-          const request = store.add(member);\n-          console.log('store.add 요청 생성됨');\n-          return request;\n-        } catch (storeError) {\n-          console.error('❌ store.add에서 즉시 에러:', storeError);\n-          throw storeError;\n-        }\n-      });\n-\n-      console.log('✅ 회원 추가 성공:', member.id);\n-      \n-      // 즉시 확인\n-      console.log('=== 저장 확인 ===');\n-      const savedMember = await this.executeTransaction('members', 'readonly', (store) => \n-        store.get(member.id)\n-      );\n-      \n-      if (savedMember) {\n-        console.log('✅ 저장된 회원 확인됨:', savedMember);\n-      } else {\n-        console.error('❌ 방금 저장한 회원을 찾을 수 없음');\n-      }\n-      \n-      return member.id;\n+      const unpaidEnrollments = await this.getUnpaidCourseEnrollmentsByMember(memberId);\n+      return unpaidEnrollments.reduce((total, enrollment) => total + enrollment.unpaidAmount, 0);\n     } catch (error) {\n-      console.error('❌ 회원 추가 실패:', error);\n-      console.error('에러 상세:', error);\n-      throw error;\n+      console.error('회원 미수 총액 계산 실패:', error);\n+      return 0;\n     }\n   }\n \n   /**\n-   * 모든 회원 조회\n+   * 수강정보 일괄 추가 (회원가입 시 사용)\n    */\n-  async getAllMembers(): Promise<Member[]> {\n+  async addMultipleCourseEnrollments(enrollmentsData: Omit<CourseEnrollment, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<string[]> {\n     try {\n-      return await this.executeTransaction('members', 'readonly', (store) => \n-        store.getAll()\n-      );\n-    } catch (error) {\n-      console.error('회원 목록 조회 실패:', error);\n-      return [];\n-    }\n-  }\n+      const enrollmentIds: string[] = [];\n \n-  /**\n-   * ID로 회원 조회\n-   */\n-  async getMemberById(id: string): Promise<Member | null> {\n-    try {\n-      return await this.executeTransaction('members', 'readonly', (store) => \n-        store.get(id)\n-      ) || null;\n-    } catch (error) {\n-      console.error('회원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 전화번호로 회원 조회\n-   */\n-  async getMemberByPhone(phone: string): Promise<Member | null> {\n-    try {\n-      const result = await this.executeTransaction('members', 'readonly', (store) => {\n-        const index = store.index('phone');\n-        return index.get(phone);\n-      });\n-      \n-      // 활성 회원만 반환\n-      return (result && result.isActive) ? result : null;\n-    } catch (error) {\n-      console.error('전화번호로 회원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 지점별 회원 조회\n-   */\n-  async getMembersByBranch(branchId: string): Promise<Member[]> {\n-    try {\n-      return await this.executeTransaction('members', 'readonly', (store) => {\n-        const index = store.index('branchId');\n-        return index.getAll(branchId);\n-      });\n-    } catch (error) {\n-      console.error('지점별 회원 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 회원 정보 수정\n-   */\n-  async updateMember(id: string, updates: Partial<Omit<Member, 'id' | 'createdAt'>>): Promise<boolean> {\n-    try {\n-      const existingMember = await this.getMemberById(id);\n-      if (!existingMember) {\n-        throw new Error('수정할 회원을 찾을 수 없습니다.');\n+      for (const enrollmentData of enrollmentsData) {\n+        const enrollmentId = await this.addCourseEnrollment(enrollmentData);\n+        enrollmentIds.push(enrollmentId);\n       }\n \n-      const updatedMember: Member = {\n-        ...existingMember,\n-        ...updates,\n-        updatedAt: new Date(),\n-      };\n-\n-      await this.executeTransaction('members', 'readwrite', (store) => \n-        store.put(updatedMember)\n-      );\n-\n-      console.log('회원 정보 수정 성공:', id);\n-      return true;\n+      console.log('수강정보 일괄 추가 성공:', enrollmentIds.length, '건');\n+      return enrollmentIds;\n     } catch (error) {\n-      console.error('회원 정보 수정 실패:', error);\n+      console.error('수강정보 일괄 추가 실패:', error);\n       throw error;\n     }\n   }\n-\n-  /**\n-   * 회원 삭제 (비활성화)\n-   */\n-  async deleteMember(id: string): Promise<boolean> {\n-    try {\n-      await this.updateMember(id, { isActive: false });\n-      console.log('회원 삭제(비활성화) 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('회원 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 회원 검색 (이름, 전화번호, 이메일)\n-   */\n-  async searchMembers(searchTerm: string): Promise<Member[]> {\n-    try {\n-      const allMembers = await this.getAllMembers();\n-      const lowerSearchTerm = searchTerm.toLowerCase();\n-      \n-      return allMembers.filter(member => \n-        member.name.toLowerCase().includes(lowerSearchTerm) ||\n-        member.phone.includes(searchTerm) ||\n-        member.email.toLowerCase().includes(lowerSearchTerm)\n-      );\n-    } catch (error) {\n-      console.error('회원 검색 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 이메일로 회원 조회\n-   */\n-  async getMemberByEmail(email: string): Promise<Member | null> {\n-    try {\n-      // 이메일이 비어있으면 null 반환\n-      if (!email || email.trim() === '') {\n-        return null;\n-      }\n-\n-      // 모든 회원을 조회해서 이메일이 일치하는 회원 찾기 (대소문자 구분 없이)\n-      const allMembers = await this.getAllMembers();\n-      const member = allMembers.find(m => \n-        m.email.toLowerCase() === email.toLowerCase() && m.isActive\n-      );\n-      \n-      return member || null;\n-    } catch (error) {\n-      console.error('이메일로 회원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 회원 중복 체크 (연락처와 이메일)\n-   */\n-  async checkMemberDuplicate(phone: string, email?: string): Promise<{\n-    isDuplicate: boolean;\n-    duplicateField?: 'phone' | 'email';\n-    message?: string;\n-  }> {\n-    try {\n-      // 전화번호 중복 체크\n-      if (phone && phone.trim() !== '') {\n-        const existingByPhone = await this.getMemberByPhone(phone);\n-        if (existingByPhone) {\n-          return {\n-            isDuplicate: true,\n-            duplicateField: 'phone',\n-            message: `연락처 ${phone}는(은) 이미 등록된 회원입니다.`\n-          };\n-        }\n-      }\n-\n-      // 이메일 중복 체크 (이메일이 있는 경우만)\n-      if (email && email.trim() !== '') {\n-        const existingByEmail = await this.getMemberByEmail(email);\n-        if (existingByEmail) {\n-          return {\n-            isDuplicate: true,\n-            duplicateField: 'email',\n-            message: `이메일 ${email}는(은) 이미 등록된 회원입니다.`\n-          };\n-        }\n-      }\n-\n-      return { isDuplicate: false };\n-    } catch (error) {\n-      console.error('회원 중복 체크 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 로그인 ID로 회원 조회\n-   */\n-  async getMemberByLoginId(loginId: string): Promise<Member | null> {\n-    try {\n-      // 로그인 ID가 비어있으면 null 반환\n-      if (!loginId || loginId.trim() === '') {\n-        return null;\n-      }\n-\n-      return await this.executeTransaction('members', 'readonly', (store) => {\n-        const index = store.index('loginId');\n-        return index.get(loginId);\n-      }) || null;\n-    } catch (error) {\n-      console.error('로그인 ID로 회원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 로그인 ID 중복 체크 (직원과 회원 모두 확인)\n-   */\n-  async checkLoginIdDuplicate(loginId: string): Promise<{\n-    isDuplicate: boolean;\n-    duplicateType?: 'staff' | 'member';\n-    message?: string;\n-  }> {\n-    try {\n-      // 로그인 ID가 비어있거나 임시 ID이면 중복 없음\n-      if (!loginId || loginId.trim() === '' || loginId.startsWith('temp_')) {\n-        return { isDuplicate: false };\n-      }\n-\n-      // 직원 테이블에서 중복 검사\n-      const existingStaff = await this.getStaffByLoginId(loginId);\n-      if (existingStaff) {\n-        return {\n-          isDuplicate: true,\n-          duplicateType: 'staff',\n-          message: `로그인 ID ${loginId}는(은) 이미 직원으로 등록되어 있습니다.`\n-        };\n-      }\n-\n-      // 회원 테이블에서 중복 검사\n-      const existingMember = await this.getMemberByLoginId(loginId);\n-      if (existingMember && !existingMember.loginId.startsWith('temp_')) {\n-        return {\n-          isDuplicate: true,\n-          duplicateType: 'member',\n-          message: `로그인 ID ${loginId}는(은) 이미 회원으로 등록되어 있습니다.`\n-        };\n-      }\n-\n-      return { isDuplicate: false };\n-    } catch (error) {\n-      console.error('로그인 ID 중복 체크 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  // ==================== 결제 관리 ====================\n-\n-  /**\n-   * 결제 정보 추가\n-   */\n-  async addPayment(paymentData: Omit<Payment, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n-    try {\n-      const payment: Payment = {\n-        id: this.generateUUID(),\n-        ...paymentData,\n-        createdAt: new Date(),\n-        updatedAt: new Date(),\n-      };\n-\n-      await this.executeTransaction('payments', 'readwrite', (store) => \n-        store.add(payment)\n-      );\n-\n-      console.log('결제 정보 추가 성공:', payment.id);\n-      return payment.id;\n-    } catch (error) {\n-      console.error('결제 정보 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 모든 결제 정보 조회\n-   */\n-  async getAllPayments(): Promise<Payment[]> {\n-    try {\n-      return await this.executeTransaction('payments', 'readonly', (store) => \n-        store.getAll()\n-      );\n-    } catch (error) {\n-      console.error('결제 목록 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * ID로 결제 정보 조회\n-   */\n-  async getPaymentById(id: string): Promise<Payment | null> {\n-    try {\n-      return await this.executeTransaction('payments', 'readonly', (store) => \n-        store.get(id)\n-      ) || null;\n-    } catch (error) {\n-      console.error('결제 정보 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 회원별 결제 정보 조회\n-   */\n-  async getPaymentsByMember(memberId: string): Promise<Payment[]> {\n-    try {\n-      return await this.executeTransaction('payments', 'readonly', (store) => {\n-        const index = store.index('memberId');\n-        return index.getAll(memberId);\n-      });\n-    } catch (error) {\n-      console.error('회원별 결제 정보 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 결제 정보 수정\n-   */\n-  async updatePayment(id: string, updates: Partial<Omit<Payment, 'id' | 'createdAt'>>): Promise<boolean> {\n-    try {\n-      const existingPayment = await this.getPaymentById(id);\n-      if (!existingPayment) {\n-        throw new Error('수정할 결제 정보를 찾을 수 없습니다.');\n-      }\n-\n-      const updatedPayment: Payment = {\n-        ...existingPayment,\n-        ...updates,\n-        updatedAt: new Date(),\n-      };\n-\n-      await this.executeTransaction('payments', 'readwrite', (store) => \n-        store.put(updatedPayment)\n-      );\n-\n-      console.log('결제 정보 수정 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('결제 정보 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 결제 정보 삭제\n-   */\n-  async deletePayment(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('payments', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-\n-      console.log('결제 정보 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('결제 정보 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n }\n \n // 싱글톤 인스턴스 생성\n export const dbManager = new IndexedDBManager();\n"
                },
                {
                    "date": 1760760624146,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2784,8 +2784,38 @@\n       console.error('수강정보 일괄 추가 실패:', error);\n       throw error;\n     }\n   }\n+\n+  /**\n+   * 전체 미수 메타정보 조회 (미수 회원 수와 총 미수 금액)\n+   */\n+  async getUnpaidMetaInfo(): Promise<{ unpaidMemberCount: number; totalUnpaidAmount: number }> {\n+    try {\n+      const unpaidEnrollments = await this.executeTransaction('courseEnrollments', 'readonly', (store) => {\n+        const index = store.index('enrollmentStatus');\n+        return index.getAll('unpaid');\n+      });\n+      \n+      // 미수 회원 ID 중복 제거\n+      const uniqueUnpaidMembers = new Set(unpaidEnrollments.map((e: CourseEnrollment) => e.memberId));\n+      const unpaidMemberCount = uniqueUnpaidMembers.size;\n+      \n+      // 총 미수 금액 계산\n+      const totalUnpaidAmount = unpaidEnrollments.reduce((total: number, enrollment: CourseEnrollment) => total + enrollment.unpaidAmount, 0);\n+      \n+      return {\n+        unpaidMemberCount,\n+        totalUnpaidAmount\n+      };\n+    } catch (error) {\n+      console.error('전체 미수 메타정보 조회 실패:', error);\n+      return {\n+        unpaidMemberCount: 0,\n+        totalUnpaidAmount: 0\n+      };\n+    }\n+  }\n }\n \n // 싱글톤 인스턴스 생성\n export const dbManager = new IndexedDBManager();\n"
                },
                {
                    "date": 1760762961892,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -122,20 +122,33 @@\n \n export interface Payment extends DBRecord {\n   memberId: string;\n   memberName: string; // 조회 성능을 위해 저장\n+  branchId: string;\n+  branchName: string; // 지점명\n+  coach: string; // 담당 코치 ID\n+  coachName: string; // 담당 코치명\n   products: Array<{\n     id: string;\n     name: string;\n     price: number;\n+    quantity: number;\n+    programId?: string;\n+    programName?: string;\n+    programType?: string;\n     description?: string;\n   }>;\n-  totalAmount: number;\n-  receivedAmount?: number; // 받은 금액\n-  paymentStatus: 'pending' | 'completed' | 'cancelled' | 'refunded' | 'unpaid'; // '미수' 상태 추가\n+  totalAmount: number; // 총 결제 예정 금액\n+  paidAmount: number; // 실제 결제된 금액\n+  unpaidAmount: number; // 미결제 금액 (totalAmount - paidAmount)\n+  paymentStatus: 'pending' | 'completed' | 'cancelled' | 'refunded' | 'unpaid';\n   paymentMethod?: string;\n   paymentDate?: Date | null;\n-  notes?: string;\n+  // 결제 타입 및 연결 정보 추가\n+  paymentType: 'course' | 'asset' | 'other'; // 수강 결제 | 자산 결제 | 기타\n+  relatedCourseId?: string | null; // 연결된 수강 이력 ID\n+  relatedAssetId?: string | null; // 연결된 자산 ID (향후 사용)\n+  memo?: string; // 메모\n }\n \n export interface Point extends DBRecord {\n   memberId: string;\n"
                },
                {
                    "date": 1761366312655,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,8 +120,9 @@\n   remarks?: string; // 비고\n }\n \n export interface Payment extends DBRecord {\n+  orderId?: string;           // 주문 ID 참조 (기존 데이터 호환성을 위해 optional)\n   memberId: string;\n   memberName: string; // 조회 성능을 위해 저장\n   branchId: string;\n   branchName: string; // 지점명\n@@ -147,8 +148,12 @@\n   paymentType: 'course' | 'asset' | 'other'; // 수강 결제 | 자산 결제 | 기타\n   relatedCourseId?: string | null; // 연결된 수강 이력 ID\n   relatedAssetId?: string | null; // 연결된 자산 ID (향후 사용)\n   memo?: string; // 메모\n+  \n+  // 새로운 필드 추가\n+  amount?: number;            // 해당 결제수단으로 결제한 금액 (개별 결제 기록용)\n+  paymentReference?: string;  // 결제 참조번호 (카드 승인번호 등)\n }\n \n export interface Point extends DBRecord {\n   memberId: string;\n@@ -161,8 +166,9 @@\n   relatedPaymentId?: string; // 연관된 결제 ID (있는 경우)\n }\n \n export interface CourseEnrollment extends DBRecord {\n+  orderId?: string; // 주문 ID 참조 (기존 데이터 호환성을 위해 optional)\n   memberId: string;\n   memberName: string; // 조회 성능을 위해 저장\n   productId: string;\n   productName: string; // 상품명\n@@ -173,22 +179,98 @@\n   branchId: string;\n   branchName: string; // 지점명\n   coach: string; // 담당 코치 ID\n   coachName: string; // 담당 코치명\n-  enrollmentStatus: 'completed' | 'unpaid'; // 수강 상태 ('완료' | '미수')\n+  enrollmentStatus: 'active' | 'completed' | 'suspended' | 'cancelled' | 'unpaid'; // 수강 상태 확장\n   paidAmount: number; // 실제 지불한 금액\n   unpaidAmount: number; // 미납 금액 (productPrice - paidAmount)\n   startDate?: Date | null; // 수강 시작일\n   endDate?: Date | null; // 수강 종료일 (기간제인 경우)\n   sessionCount?: number; // 총 수업 횟수 (횟수제인 경우)\n   completedSessions?: number; // 완료된 수업 횟수 (횟수제인 경우, 기본값 0)\n   notes?: string; // 비고\n-  relatedPaymentId?: string; // 연관된 결제 ID\n+  relatedPaymentId?: string; // 연관된 결제 ID (기존 호환성)\n }\n \n+// ==================== 새로운 개선된 스키마 ====================\n+\n+export interface Order extends DBRecord {\n+  memberId: string;\n+  memberName: string;\n+  branchId: string;\n+  branchName: string;\n+  coach: string;\n+  coachName: string;\n+  \n+  // 주문 상품 정보\n+  orderItems: Array<{\n+    productId: string;\n+    productName: string;\n+    programId: string;\n+    programName: string;\n+    programType: string;\n+    price: number;\n+    quantity: number;\n+  }>;\n+  \n+  // 금액 정보\n+  totalAmount: number;        // 총 주문 금액\n+  paidAmount: number;         // 총 지불 금액\n+  unpaidAmount: number;       // 총 미수 금액\n+  pointsUsed: number;         // 사용된 포인트\n+  pointsEarned: number;       // 적립된 포인트 (초과금)\n+  \n+  // 상태 정보\n+  orderStatus: 'pending' | 'completed' | 'partially_paid' | 'cancelled';\n+  orderType: 'registration' | 'course_enrollment' | 'product_purchase';\n+  \n+  memo?: string;\n+}\n+\n+export interface PointTransaction extends DBRecord {\n+  memberId: string;\n+  memberName: string;\n+  \n+  // 거래 정보\n+  amount: number;             // 포인트 금액 (+ 적립, - 사용)\n+  balance: number;            // 거래 후 잔액 (성능 최적화)\n+  transactionType: 'earn' | 'use' | 'expire' | 'adjust' | 'refund';\n+  \n+  // 관련 정보\n+  relatedOrderId?: string;    // 관련 주문 ID\n+  relatedPaymentId?: string;  // 관련 결제 ID (기존 호환성)\n+  \n+  // 포인트 정책\n+  earnedDate?: Date;          // 적립일 (사용/만료 추적용)\n+  expiryDate?: Date;          // 만료일\n+  isExpired: boolean;         // 만료 여부\n+  \n+  source: string;             // 포인트 발생 출처\n+  description?: string;\n+  \n+  // FIFO 처리를 위한 추가 필드\n+  originalTransactionId?: string; // 원본 적립 거래 ID (사용/만료 시)\n+}\n+\n+export interface PointBalance extends DBRecord {\n+  memberId: string;\n+  \n+  // 실시간 잔액 정보\n+  totalBalance: number;       // 총 사용가능 포인트\n+  earnedPoints: number;       // 총 적립 포인트\n+  usedPoints: number;         // 총 사용 포인트\n+  expiredPoints: number;      // 총 만료 포인트\n+  \n+  // 만료 예정 포인트 (성능 최적화)\n+  expiringIn30Days: number;   // 30일 내 만료 예정\n+  expiringIn7Days: number;    // 7일 내 만료 예정\n+  \n+  lastUpdated: Date;          // 마지막 업데이트 시간\n+}\n+\n class IndexedDBManager {\n   private dbName: string = 'LavidaDB';\n-  private version: number = 11; // 버전 업데이트 (CourseEnrollment 테이블 추가)\n+  private version: number = 12; // 버전 업데이트 (새로운 스키마 추가)\n   private db: IDBDatabase | null = null;\n   private isInitializing: boolean = false; // 단순한 플래그로 변경\n \n   constructor() {\n@@ -420,8 +502,9 @@\n           courseStore.createIndex('unpaidAmount', 'unpaidAmount', { unique: false });\n           courseStore.createIndex('startDate', 'startDate', { unique: false });\n           courseStore.createIndex('endDate', 'endDate', { unique: false });\n           courseStore.createIndex('relatedPaymentId', 'relatedPaymentId', { unique: false });\n+          courseStore.createIndex('orderId', 'orderId', { unique: false }); // 새로운 필드\n           courseStore.createIndex('createdAt', 'createdAt', { unique: false });\n           // 복합 인덱스: 회원별 수강 조회 최적화\n           courseStore.createIndex('memberStatus', ['memberId', 'enrollmentStatus'], { unique: false });\n           // 지점별, 프로그램별 수강 조회 최적화\n@@ -429,11 +512,73 @@\n           // 코치별 수강 조회 최적화\n           courseStore.createIndex('coachStatus', ['coach', 'enrollmentStatus'], { unique: false });\n         }\n \n+        // 주문 테이블 생성 (새로운 스키마)\n+        if (!db.objectStoreNames.contains('orders')) {\n+          const orderStore = db.createObjectStore('orders', { keyPath: 'id' });\n+          orderStore.createIndex('memberId', 'memberId', { unique: false });\n+          orderStore.createIndex('memberName', 'memberName', { unique: false });\n+          orderStore.createIndex('branchId', 'branchId', { unique: false });\n+          orderStore.createIndex('branchName', 'branchName', { unique: false });\n+          orderStore.createIndex('coach', 'coach', { unique: false });\n+          orderStore.createIndex('coachName', 'coachName', { unique: false });\n+          orderStore.createIndex('orderStatus', 'orderStatus', { unique: false });\n+          orderStore.createIndex('orderType', 'orderType', { unique: false });\n+          orderStore.createIndex('totalAmount', 'totalAmount', { unique: false });\n+          orderStore.createIndex('unpaidAmount', 'unpaidAmount', { unique: false });\n+          orderStore.createIndex('createdAt', 'createdAt', { unique: false });\n+          // 복합 인덱스\n+          orderStore.createIndex('memberStatus', ['memberId', 'orderStatus'], { unique: false });\n+          orderStore.createIndex('branchStatus', ['branchId', 'orderStatus'], { unique: false });\n+        }\n+\n+        // 포인트 거래내역 테이블 생성 (새로운 스키마)\n+        if (!db.objectStoreNames.contains('pointTransactions')) {\n+          const ptStore = db.createObjectStore('pointTransactions', { keyPath: 'id' });\n+          ptStore.createIndex('memberId', 'memberId', { unique: false });\n+          ptStore.createIndex('memberName', 'memberName', { unique: false });\n+          ptStore.createIndex('transactionType', 'transactionType', { unique: false });\n+          ptStore.createIndex('relatedOrderId', 'relatedOrderId', { unique: false });\n+          ptStore.createIndex('relatedPaymentId', 'relatedPaymentId', { unique: false });\n+          ptStore.createIndex('earnedDate', 'earnedDate', { unique: false });\n+          ptStore.createIndex('expiryDate', 'expiryDate', { unique: false });\n+          ptStore.createIndex('isExpired', 'isExpired', { unique: false });\n+          ptStore.createIndex('originalTransactionId', 'originalTransactionId', { unique: false });\n+          ptStore.createIndex('createdAt', 'createdAt', { unique: false });\n+          // 복합 인덱스\n+          ptStore.createIndex('memberType', ['memberId', 'transactionType'], { unique: false });\n+          ptStore.createIndex('memberExpiry', ['memberId', 'expiryDate', 'isExpired'], { unique: false });\n+        }\n+\n+        // 포인트 잔액 테이블 생성 (새로운 스키마)\n+        if (!db.objectStoreNames.contains('pointBalances')) {\n+          const pbStore = db.createObjectStore('pointBalances', { keyPath: 'id' });\n+          pbStore.createIndex('memberId', 'memberId', { unique: true }); // 회원당 하나의 잔액 레코드\n+          pbStore.createIndex('totalBalance', 'totalBalance', { unique: false });\n+          pbStore.createIndex('lastUpdated', 'lastUpdated', { unique: false });\n+        }\n+\n         // 향후 다른 테이블들도 여기에 추가 가능\n         // 예: 회원, 방문기록 등\n         };\n+        \n+        // DB 초기화 완료 후 마이그레이션 실행\n+        request.onsuccess = async () => {\n+          this.db = request.result;\n+          this.isInitializing = false;\n+          \n+          try {\n+            // 데이터 마이그레이션 실행 (백그라운드에서)\n+            setTimeout(() => {\n+              this.runMigrations().catch(error => {\n+                console.error('백그라운드 마이그레이션 실패:', error);\n+              });\n+            }, 1000); // 1초 후 실행하여 초기화 완료 후 진행\n+          } catch (error) {\n+            console.error('마이그레이션 스케줄링 실패:', error);\n+          }\n+        };\n       });\n     } catch (error) {\n       console.error('❌ IndexedDB 초기화 중 오류:', error);\n       this.isInitializing = false;\n@@ -2827,8 +2972,768 @@\n         totalUnpaidAmount: 0\n       };\n     }\n   }\n+\n+  // ==================== 새로운 개선된 주문 관리 ====================\n+\n+  /**\n+   * 주문 생성\n+   */\n+  async createOrder(orderData: Omit<Order, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n+    try {\n+      const order: Order = {\n+        id: this.generateUUID(),\n+        ...orderData,\n+        createdAt: new Date(),\n+        updatedAt: new Date(),\n+      };\n+\n+      await this.executeTransaction('orders', 'readwrite', (store) => \n+        store.add(order)\n+      );\n+\n+      console.log('주문 생성 성공:', order.id);\n+      return order.id;\n+    } catch (error) {\n+      console.error('주문 생성 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 주문 조회\n+   */\n+  async getOrderById(id: string): Promise<Order | null> {\n+    try {\n+      return await this.executeTransaction('orders', 'readonly', (store) => \n+        store.get(id)\n+      ) || null;\n+    } catch (error) {\n+      console.error('주문 조회 실패:', error);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * 회원별 주문 조회\n+   */\n+  async getOrdersByMember(memberId: string): Promise<Order[]> {\n+    try {\n+      return await this.executeTransaction('orders', 'readonly', (store) => {\n+        const index = store.index('memberId');\n+        return index.getAll(memberId);\n+      });\n+    } catch (error) {\n+      console.error('회원별 주문 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 주문 상태 업데이트\n+   */\n+  async updateOrderStatus(orderId: string): Promise<void> {\n+    try {\n+      const order = await this.getOrderById(orderId);\n+      if (!order) throw new Error('주문을 찾을 수 없습니다.');\n+\n+      let newStatus: Order['orderStatus'];\n+      if (order.unpaidAmount <= 0) {\n+        newStatus = 'completed';\n+      } else if (order.paidAmount > 0) {\n+        newStatus = 'partially_paid';\n+      } else {\n+        newStatus = 'pending';\n+      }\n+\n+      await this.updateOrder(orderId, { orderStatus: newStatus });\n+    } catch (error) {\n+      console.error('주문 상태 업데이트 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 주문 수정\n+   */\n+  async updateOrder(id: string, updates: Partial<Omit<Order, 'id' | 'createdAt'>>): Promise<boolean> {\n+    try {\n+      const existingOrder = await this.getOrderById(id);\n+      if (!existingOrder) {\n+        throw new Error('수정할 주문을 찾을 수 없습니다.');\n+      }\n+\n+      const updatedOrder: Order = {\n+        ...existingOrder,\n+        ...updates,\n+        updatedAt: new Date(),\n+      };\n+\n+      await this.executeTransaction('orders', 'readwrite', (store) => \n+        store.put(updatedOrder)\n+      );\n+\n+      console.log('주문 수정 성공:', id);\n+      return true;\n+    } catch (error) {\n+      console.error('주문 수정 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  // ==================== 개선된 포인트 시스템 ====================\n+\n+  /**\n+   * 포인트 거래 추가\n+   */\n+  async addPointTransaction(transactionData: Omit<PointTransaction, 'id' | 'createdAt' | 'updatedAt' | 'balance'>): Promise<string> {\n+    try {\n+      // 현재 잔액 계산\n+      const currentBalance = await this.getMemberPointBalance(transactionData.memberId);\n+      const newBalance = currentBalance + transactionData.amount;\n+\n+      const transaction: PointTransaction = {\n+        id: this.generateUUID(),\n+        ...transactionData,\n+        balance: newBalance,\n+        isExpired: transactionData.isExpired || false,\n+        createdAt: new Date(),\n+        updatedAt: new Date(),\n+      };\n+\n+      await this.executeTransaction('pointTransactions', 'readwrite', (store) => \n+        store.add(transaction)\n+      );\n+\n+      // 포인트 잔액 테이블 업데이트\n+      await this.updatePointBalance(transactionData.memberId);\n+\n+      console.log('포인트 거래 추가 성공:', transaction.id, `${transaction.amount}원`);\n+      return transaction.id;\n+    } catch (error) {\n+      console.error('포인트 거래 추가 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * FIFO 방식 포인트 사용\n+   */\n+  async usePointsFIFO(memberId: string, amount: number, orderId: string, source: string = '상품구매'): Promise<void> {\n+    try {\n+      // 1. 사용 가능한 포인트를 적립일 순으로 조회\n+      const availablePoints = await this.getAvailablePointsOrderByEarnedDate(memberId);\n+      \n+      let remainingAmount = amount;\n+      const usageRecords = [];\n+      \n+      // 2. FIFO 방식으로 포인트 차감 계획 수립\n+      for (const pointBatch of availablePoints) {\n+        if (remainingAmount <= 0) break;\n+        \n+        const useAmount = Math.min(remainingAmount, pointBatch.availableAmount);\n+        usageRecords.push({\n+          originalTransactionId: pointBatch.id,\n+          amount: useAmount,\n+          earnedDate: pointBatch.earnedDate\n+        });\n+        \n+        remainingAmount -= useAmount;\n+      }\n+      \n+      if (remainingAmount > 0) {\n+        throw new Error(`포인트 잔액이 부족합니다. 부족 금액: ${remainingAmount.toLocaleString()}원`);\n+      }\n+      \n+      // 3. 사용 내역 기록\n+      const member = await this.getMemberById(memberId);\n+      for (const usage of usageRecords) {\n+        await this.addPointTransaction({\n+          memberId,\n+          memberName: member?.name || '',\n+          amount: -usage.amount,\n+          transactionType: 'use',\n+          relatedOrderId: orderId,\n+          earnedDate: usage.earnedDate,\n+          originalTransactionId: usage.originalTransactionId,\n+          isExpired: false,\n+          source,\n+          description: `FIFO 방식 포인트 사용 (원본: ${usage.originalTransactionId.slice(-8)})`\n+        });\n+      }\n+      \n+      console.log(`FIFO 포인트 사용 완료: ${amount.toLocaleString()}원, ${usageRecords.length}개 배치에서 차감`);\n+    } catch (error) {\n+      console.error('FIFO 포인트 사용 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 적립일 순으로 사용 가능한 포인트 조회\n+   */\n+  async getAvailablePointsOrderByEarnedDate(memberId: string): Promise<Array<{\n+    id: string;\n+    availableAmount: number;\n+    earnedDate: Date;\n+  }>> {\n+    try {\n+      const transactions = await this.executeTransaction('pointTransactions', 'readonly', (store) => {\n+        return store.getAll();\n+      }).then(allTransactions => \n+        allTransactions.filter(t => t.memberId === memberId)\n+      );\n+\n+      // 적립된 포인트들을 그룹화하고 사용/만료된 포인트를 차감\n+      const earnedTransactions = transactions.filter(t => \n+        t.transactionType === 'earn' && \n+        !t.isExpired &&\n+        (!t.expiryDate || t.expiryDate > new Date())\n+      );\n+\n+      const availablePoints = [];\n+      \n+      for (const earnedTx of earnedTransactions) {\n+        // 해당 적립 포인트에서 사용/만료된 금액 계산\n+        const usedAmount = transactions\n+          .filter(t => \n+            t.originalTransactionId === earnedTx.id && \n+            (t.transactionType === 'use' || t.transactionType === 'expire')\n+          )\n+          .reduce((sum, t) => sum + Math.abs(t.amount), 0);\n+\n+        const availableAmount = earnedTx.amount - usedAmount;\n+        \n+        if (availableAmount > 0) {\n+          availablePoints.push({\n+            id: earnedTx.id,\n+            availableAmount,\n+            earnedDate: earnedTx.earnedDate || earnedTx.createdAt\n+          });\n+        }\n+      }\n+\n+      // 적립일 순으로 정렬 (오래된 것부터)\n+      return availablePoints.sort((a, b) => a.earnedDate.getTime() - b.earnedDate.getTime());\n+    } catch (error) {\n+      console.error('사용 가능한 포인트 조회 실패:', error);\n+      return [];\n+    }\n+  }\n+\n+  /**\n+   * 포인트 잔액 테이블 업데이트\n+   */\n+  async updatePointBalance(memberId: string): Promise<void> {\n+    try {\n+      const transactions = await this.executeTransaction('pointTransactions', 'readonly', (store) => {\n+        const index = store.index('memberId');\n+        return index.getAll(memberId);\n+      });\n+\n+      const now = new Date();\n+      const validTransactions = transactions.filter(t => \n+        !t.isExpired && (!t.expiryDate || t.expiryDate > now)\n+      );\n+\n+      const totalBalance = validTransactions.reduce((sum, t) => sum + t.amount, 0);\n+      const earnedPoints = transactions.filter(t => t.transactionType === 'earn').reduce((sum, t) => sum + t.amount, 0);\n+      const usedPoints = Math.abs(transactions.filter(t => t.transactionType === 'use').reduce((sum, t) => sum + t.amount, 0));\n+      const expiredPoints = Math.abs(transactions.filter(t => t.transactionType === 'expire').reduce((sum, t) => sum + t.amount, 0));\n+\n+      // 만료 예정 포인트 계산\n+      const in30Days = new Date();\n+      in30Days.setDate(in30Days.getDate() + 30);\n+      const in7Days = new Date();\n+      in7Days.setDate(in7Days.getDate() + 7);\n+\n+      const expiringIn30Days = validTransactions.filter(t => \n+        t.expiryDate && t.expiryDate <= in30Days && t.transactionType === 'earn'\n+      ).reduce((sum, t) => sum + t.amount, 0);\n+\n+      const expiringIn7Days = validTransactions.filter(t => \n+        t.expiryDate && t.expiryDate <= in7Days && t.transactionType === 'earn'\n+      ).reduce((sum, t) => sum + t.amount, 0);\n+\n+      const balanceData: PointBalance = {\n+        id: `balance_${memberId}`,\n+        memberId,\n+        totalBalance,\n+        earnedPoints,\n+        usedPoints,\n+        expiredPoints,\n+        expiringIn30Days,\n+        expiringIn7Days,\n+        lastUpdated: new Date(),\n+        createdAt: new Date(),\n+        updatedAt: new Date()\n+      };\n+\n+      await this.executeTransaction('pointBalances', 'readwrite', (store) => \n+        store.put(balanceData)\n+      );\n+\n+      console.log(`포인트 잔액 업데이트 완료: ${memberId} - ${totalBalance.toLocaleString()}원`);\n+    } catch (error) {\n+      console.error('포인트 잔액 업데이트 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 포인트 잔액 조회 (캐시된 값 사용)\n+   */\n+  async getMemberPointBalanceCached(memberId: string): Promise<number> {\n+    try {\n+      const balance = await this.executeTransaction('pointBalances', 'readonly', (store) => \n+        store.get(`balance_${memberId}`)\n+      );\n+\n+      if (balance) {\n+        // 캐시된 값이 너무 오래되었다면 새로 계산\n+        const hoursSinceUpdate = (new Date().getTime() - balance.lastUpdated.getTime()) / (1000 * 60 * 60);\n+        if (hoursSinceUpdate < 1) { // 1시간 이내면 캐시 사용\n+          return balance.totalBalance;\n+        }\n+      }\n+\n+      // 캐시가 없거나 오래되었으면 실시간 계산 후 캐시 업데이트\n+      await this.updatePointBalance(memberId);\n+      const updatedBalance = await this.executeTransaction('pointBalances', 'readonly', (store) => \n+        store.get(`balance_${memberId}`)\n+      );\n+      \n+      return updatedBalance?.totalBalance || 0;\n+    } catch (error) {\n+      console.error('포인트 잔액 조회 실패:', error);\n+      return 0;\n+    }\n+  }\n+\n+  /**\n+   * 개선된 포인트 만료 처리\n+   */\n+  async expirePointsImproved(): Promise<number> {\n+    try {\n+      const now = new Date();\n+      \n+      // 만료된 적립 포인트 조회 (아직 만료 처리되지 않은 것만)\n+      const expiredTransactions = await this.executeTransaction('pointTransactions', 'readonly', (store) => {\n+        return store.getAll();\n+      }).then(transactions => \n+        transactions.filter(t => \n+          t.transactionType === 'earn' && \n+          !t.isExpired &&\n+          t.expiryDate && \n+          t.expiryDate <= now\n+        )\n+      );\n+\n+      let expiredCount = 0;\n+      const memberGroups = new Map<string, PointTransaction[]>();\n+\n+      // 회원별로 그룹화\n+      for (const transaction of expiredTransactions) {\n+        const memberId = transaction.memberId;\n+        if (!memberGroups.has(memberId)) {\n+          memberGroups.set(memberId, []);\n+        }\n+        memberGroups.get(memberId)!.push(transaction);\n+      }\n+\n+      // 각 회원별로 만료 처리\n+      for (const memberData of Array.from(memberGroups.entries())) {\n+        const [memberId, transactions] = memberData;\n+        for (const transaction of transactions) {\n+          // 해당 적립 포인트에서 실제 사용 가능한 금액 계산\n+          const availablePoints = await this.getAvailablePointsOrderByEarnedDate(memberId);\n+          const availablePoint = availablePoints.find(p => p.id === transaction.id);\n+          \n+          if (availablePoint && availablePoint.availableAmount > 0) {\n+            // 만료 처리 기록\n+            await this.addPointTransaction({\n+              memberId,\n+              memberName: transaction.memberName,\n+              amount: -availablePoint.availableAmount,\n+              transactionType: 'expire',\n+              originalTransactionId: transaction.id,\n+              earnedDate: transaction.earnedDate,\n+              isExpired: false,\n+              source: '포인트 만료',\n+              description: `만료일: ${transaction.expiryDate?.toLocaleDateString()}`\n+            });\n+\n+            // 원본 거래를 만료 상태로 표시\n+            await this.markTransactionAsExpired(transaction.id);\n+            expiredCount++;\n+          }\n+        }\n+      }\n+\n+      console.log(`만료된 포인트 처리 완료: ${expiredCount}건`);\n+      return expiredCount;\n+    } catch (error) {\n+      console.error('포인트 만료 처리 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 거래를 만료 상태로 표시\n+   */\n+  async markTransactionAsExpired(transactionId: string): Promise<void> {\n+    try {\n+      const transaction = await this.executeTransaction('pointTransactions', 'readonly', (store) => \n+        store.get(transactionId)\n+      );\n+\n+      if (transaction) {\n+        transaction.isExpired = true;\n+        transaction.updatedAt = new Date();\n+\n+        await this.executeTransaction('pointTransactions', 'readwrite', (store) => \n+          store.put(transaction)\n+        );\n+      }\n+    } catch (error) {\n+      console.error('거래 만료 상태 표시 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  // ==================== 통합 주문 처리 로직 ====================\n+\n+  /**\n+   * 회원가입/수강등록 통합 주문 처리\n+   */\n+  async processOrderWithPayments(orderData: {\n+    memberInfo: {\n+      id: string;\n+      name: string;\n+      branchId: string;\n+      branchName: string;\n+      coach: string;\n+      coachName: string;\n+    };\n+    products: Array<{\n+      id: string;\n+      name: string;\n+      price: number;\n+      programId: string;\n+      programName: string;\n+      programType: string;\n+    }>;\n+    payments: {\n+      cash: number;\n+      card: number;\n+      transfer: number;\n+      points: number;\n+    };\n+    orderType: 'registration' | 'course_enrollment';\n+  }): Promise<string> {\n+    try {\n+      const totalAmount = orderData.products.reduce((sum, p) => sum + p.price, 0);\n+      const totalPaid = orderData.payments.cash + orderData.payments.card + \n+                       orderData.payments.transfer + orderData.payments.points;\n+      const unpaidAmount = Math.max(0, totalAmount - totalPaid);\n+      const excessAmount = Math.max(0, totalPaid - totalAmount);\n+\n+      // 1. 주문 생성\n+      const orderId = await this.createOrder({\n+        memberId: orderData.memberInfo.id,\n+        memberName: orderData.memberInfo.name,\n+        branchId: orderData.memberInfo.branchId,\n+        branchName: orderData.memberInfo.branchName,\n+        coach: orderData.memberInfo.coach,\n+        coachName: orderData.memberInfo.coachName,\n+        orderItems: orderData.products.map(p => ({\n+          productId: p.id,\n+          productName: p.name,\n+          programId: p.programId,\n+          programName: p.programName,\n+          programType: p.programType,\n+          price: p.price,\n+          quantity: 1\n+        })),\n+        totalAmount,\n+        paidAmount: totalPaid,\n+        unpaidAmount,\n+        pointsUsed: orderData.payments.points,\n+        pointsEarned: excessAmount,\n+        orderStatus: unpaidAmount > 0 ? 'partially_paid' : 'completed',\n+        orderType: orderData.orderType\n+      });\n+\n+      // 2. 개별 결제 기록 생성\n+      const paymentMethods = [\n+        { method: 'cash', amount: orderData.payments.cash },\n+        { method: 'card', amount: orderData.payments.card },\n+        { method: 'transfer', amount: orderData.payments.transfer }\n+      ];\n+\n+      for (const payment of paymentMethods) {\n+        if (payment.amount > 0) {\n+          await this.addPayment({\n+            orderId,\n+            memberId: orderData.memberInfo.id,\n+            memberName: orderData.memberInfo.name,\n+            branchId: orderData.memberInfo.branchId,\n+            branchName: orderData.memberInfo.branchName,\n+            coach: orderData.memberInfo.coach,\n+            coachName: orderData.memberInfo.coachName,\n+            products: orderData.products.map(p => ({\n+              id: p.id,\n+              name: p.name,\n+              price: p.price,\n+              quantity: 1,\n+              programId: p.programId,\n+              programName: p.programName,\n+              programType: p.programType\n+            })),\n+            totalAmount: payment.amount,\n+            paidAmount: payment.amount,\n+            unpaidAmount: 0,\n+            paymentStatus: 'completed',\n+            paymentMethod: payment.method,\n+            paymentDate: new Date(),\n+            paymentType: 'course',\n+            amount: payment.amount,\n+            memo: `${orderData.orderType} - ${payment.method} 결제`\n+          });\n+        }\n+      }\n+\n+      // 3. 포인트 사용 처리\n+      if (orderData.payments.points > 0) {\n+        await this.usePointsFIFO(\n+          orderData.memberInfo.id,\n+          orderData.payments.points,\n+          orderId,\n+          `${orderData.orderType} 포인트 결제`\n+        );\n+      }\n+\n+      // 4. 초과금 포인트 적립\n+      if (excessAmount > 0) {\n+        const expiryDate = new Date();\n+        expiryDate.setFullYear(expiryDate.getFullYear() + 1);\n+\n+        await this.addPointTransaction({\n+          memberId: orderData.memberInfo.id,\n+          memberName: orderData.memberInfo.name,\n+          amount: excessAmount,\n+          transactionType: 'earn',\n+          relatedOrderId: orderId,\n+          earnedDate: new Date(),\n+          expiryDate,\n+          isExpired: false,\n+          source: `${orderData.orderType} 초과금액`,\n+          description: `${orderData.orderType} 초과금액 포인트 적립`\n+        });\n+      }\n+\n+      // 5. 수강 등록 생성 (상품별)\n+      for (const product of orderData.products) {\n+        await this.addCourseEnrollment({\n+          orderId,\n+          memberId: orderData.memberInfo.id,\n+          memberName: orderData.memberInfo.name,\n+          productId: product.id,\n+          productName: product.name,\n+          productPrice: product.price,\n+          programId: product.programId,\n+          programName: product.programName,\n+          programType: product.programType,\n+          branchId: orderData.memberInfo.branchId,\n+          branchName: orderData.memberInfo.branchName,\n+          coach: orderData.memberInfo.coach,\n+          coachName: orderData.memberInfo.coachName,\n+          enrollmentStatus: unpaidAmount > 0 ? 'unpaid' : 'active',\n+          paidAmount: totalPaid,\n+          unpaidAmount: Math.max(0, product.price - totalPaid),\n+          startDate: new Date(),\n+          completedSessions: 0,\n+          notes: `${orderData.orderType}을 통한 등록`\n+        });\n+      }\n+\n+      console.log(`통합 주문 처리 완료: ${orderId}`);\n+      return orderId;\n+    } catch (error) {\n+      console.error('통합 주문 처리 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  // ==================== 데이터 마이그레이션 ====================\n+\n+  /**\n+   * 기존 Point 데이터를 새로운 PointTransaction으로 마이그레이션\n+   */\n+  async migratePointsToTransactions(): Promise<void> {\n+    try {\n+      console.log('포인트 데이터 마이그레이션 시작...');\n+      \n+      // 1. 기존 포인트 데이터 조회\n+      const oldPoints = await this.getAllPoints();\n+      \n+      // 2. 이미 마이그레이션된 데이터가 있는지 확인\n+      const existingTransactions = await this.executeTransaction('pointTransactions', 'readonly', (store) => \n+        store.getAll()\n+      );\n+      \n+      if (existingTransactions.length > 0) {\n+        console.log('이미 마이그레이션된 포인트 거래내역이 있습니다. 스킵합니다.');\n+        return;\n+      }\n+      \n+      // 3. 각 포인트를 PointTransaction으로 변환\n+      for (const point of oldPoints) {\n+        const transactionType = point.amount > 0 ? 'earn' : \n+                               point.type === 'used' ? 'use' :\n+                               point.type === 'expired' ? 'expire' : 'adjust';\n+        \n+        await this.addPointTransaction({\n+          memberId: point.memberId,\n+          memberName: point.memberName,\n+          amount: point.amount,\n+          transactionType: transactionType as any,\n+          earnedDate: point.createdAt,\n+          expiryDate: point.expiryDate || undefined,\n+          isExpired: point.type === 'expired',\n+          source: point.source,\n+          description: point.description,\n+          relatedPaymentId: point.relatedPaymentId\n+        });\n+      }\n+      \n+      // 4. 모든 회원의 포인트 잔액 업데이트\n+      const members = await this.getAllMembers();\n+      for (const member of members) {\n+        await this.updatePointBalance(member.id);\n+      }\n+      \n+      console.log(`포인트 데이터 마이그레이션 완료: ${oldPoints.length}건 처리`);\n+    } catch (error) {\n+      console.error('포인트 데이터 마이그레이션 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 기존 결제 데이터에 orderId 추가 (역호환성)\n+   */\n+  async migratePaymentsWithOrderId(): Promise<void> {\n+    try {\n+      console.log('결제 데이터 주문 ID 마이그레이션 시작...');\n+      \n+      const payments = await this.getAllPayments();\n+      const paymentsWithoutOrderId = payments.filter(p => !p.orderId);\n+      \n+      if (paymentsWithoutOrderId.length === 0) {\n+        console.log('마이그레이션이 필요한 결제 데이터가 없습니다.');\n+        return;\n+      }\n+      \n+      // 각 결제에 대해 가상의 주문 생성\n+      for (const payment of paymentsWithoutOrderId) {\n+        // 1. 기존 결제를 위한 주문 생성\n+        const orderId = await this.createOrder({\n+          memberId: payment.memberId,\n+          memberName: payment.memberName,\n+          branchId: payment.branchId,\n+          branchName: payment.branchName,\n+          coach: payment.coach,\n+          coachName: payment.coachName,\n+          orderItems: payment.products.map(p => ({\n+            productId: p.id,\n+            productName: p.name,\n+            programId: p.programId || '',\n+            programName: p.programName || '',\n+            programType: p.programType || '',\n+            price: p.price,\n+            quantity: p.quantity\n+          })),\n+          totalAmount: payment.totalAmount,\n+          paidAmount: payment.paidAmount,\n+          unpaidAmount: payment.unpaidAmount,\n+          pointsUsed: 0, // 기존 데이터에서는 포인트 사용 정보 없음\n+          pointsEarned: 0,\n+          orderStatus: payment.paymentStatus === 'completed' ? 'completed' : \n+                      payment.paymentStatus === 'unpaid' ? 'partially_paid' : 'pending',\n+          orderType: payment.paymentType === 'course' ? 'course_enrollment' : 'product_purchase',\n+          memo: `마이그레이션된 기존 결제 (원본 결제 ID: ${payment.id.slice(-8)})`\n+        });\n+        \n+        // 2. 결제에 주문 ID 추가\n+        await this.updatePayment(payment.id, { orderId });\n+        \n+        // 3. 관련 수강 등록에도 주문 ID 추가\n+        if (payment.relatedCourseId) {\n+          await this.updateCourseEnrollment(payment.relatedCourseId, { orderId });\n+        }\n+      }\n+      \n+      console.log(`결제 데이터 주문 ID 마이그레이션 완료: ${paymentsWithoutOrderId.length}건 처리`);\n+    } catch (error) {\n+      console.error('결제 데이터 주문 ID 마이그레이션 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * 전체 데이터 마이그레이션 실행\n+   */\n+  async runMigrations(): Promise<void> {\n+    try {\n+      console.log('=== 데이터 마이그레이션 시작 ===');\n+      \n+      // 1. 포인트 데이터 마이그레이션\n+      await this.migratePointsToTransactions();\n+      \n+      // 2. 결제 데이터에 주문 ID 추가\n+      await this.migratePaymentsWithOrderId();\n+      \n+      console.log('=== 데이터 마이그레이션 완료 ===');\n+    } catch (error) {\n+      console.error('데이터 마이그레이션 실패:', error);\n+      throw error;\n+    }\n+  }\n+\n+  // ==================== 개선된 포인트 잔액 조회 (호환성 유지) ====================\n+\n+  /**\n+   * 회원 포인트 잔액 조회 (기존 메서드 오버라이드 - 호환성 유지)\n+   */\n+  async getMemberPointBalanceV2(memberId: string): Promise<number> {\n+    try {\n+      // 1. 새로운 PointTransaction 데이터가 있는지 확인\n+      const transactions = await this.executeTransaction('pointTransactions', 'readonly', (store) => {\n+        const index = store.index('memberId');\n+        return index.getAll(memberId);\n+      });\n+\n+      if (transactions.length > 0) {\n+        // 새로운 시스템 사용: 캐시된 잔액 조회\n+        return await this.getMemberPointBalanceCached(memberId);\n+      } else {\n+        // 기존 시스템 사용: Point 테이블에서 계산\n+        const points = await this.getPointsByMember(memberId);\n+        const now = new Date();\n+        \n+        const validPoints = points.filter(point => {\n+          return !point.expiryDate || point.expiryDate > now;\n+        });\n+        \n+        return validPoints.reduce((total, point) => total + point.amount, 0);\n+      }\n+    } catch (error) {\n+      console.error('포인트 잔액 조회 실패:', error);\n+      return 0;\n+    }\n+  }\n }\n \n // 싱글톤 인스턴스 생성\n export const dbManager = new IndexedDBManager();\n"
                },
                {
                    "date": 1761366849352,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3437,8 +3437,14 @@\n                        orderData.payments.transfer + orderData.payments.points;\n       const unpaidAmount = Math.max(0, totalAmount - totalPaid);\n       const excessAmount = Math.max(0, totalPaid - totalAmount);\n \n+      console.log('=== processOrderWithPayments 계산 ===');\n+      console.log(`총 주문금액: ${totalAmount.toLocaleString()}원`);\n+      console.log(`총 결제금액: ${totalPaid.toLocaleString()}원`);\n+      console.log(`미수금액: ${unpaidAmount.toLocaleString()}원`);\n+      console.log(`초과금액: ${excessAmount.toLocaleString()}원`);\n+\n       // 1. 주문 생성\n       const orderId = await this.createOrder({\n         memberId: orderData.memberInfo.id,\n         memberName: orderData.memberInfo.name,\n@@ -3514,8 +3520,9 @@\n       }\n \n       // 4. 초과금 포인트 적립\n       if (excessAmount > 0) {\n+        console.log(`=== 초과금 포인트 적립 시작: ${excessAmount.toLocaleString()}원 ===`);\n         const expiryDate = new Date();\n         expiryDate.setFullYear(expiryDate.getFullYear() + 1);\n \n         await this.addPointTransaction({\n@@ -3529,12 +3536,31 @@\n           isExpired: false,\n           source: `${orderData.orderType} 초과금액`,\n           description: `${orderData.orderType} 초과금액 포인트 적립`\n         });\n+        console.log(`포인트 적립 완료: ${excessAmount.toLocaleString()}원`);\n+      } else {\n+        console.log('초과금액이 없어 포인트 적립 없음');\n       }\n \n       // 5. 수강 등록 생성 (상품별)\n+      let remainingPaid = totalPaid;\n       for (const product of orderData.products) {\n+        // 이 상품에 할당될 결제액 계산\n+        const productPaidAmount = Math.min(remainingPaid, product.price);\n+        const productUnpaidAmount = Math.max(0, product.price - productPaidAmount);\n+        remainingPaid -= productPaidAmount;\n+\n+        // 상품 상세 정보 조회 (세션 수와 기간 정보를 위해)\n+        const productDetails = await this.getProductById(product.id);\n+        \n+        // 종료일 계산 (기간제인 경우)\n+        let endDate: Date | undefined;\n+        if (product.programType === '기간제' && productDetails?.duration) {\n+          endDate = new Date();\n+          endDate.setMonth(endDate.getMonth() + productDetails.duration);\n+        }\n+\n         await this.addCourseEnrollment({\n           orderId,\n           memberId: orderData.memberInfo.id,\n           memberName: orderData.memberInfo.name,\n@@ -3547,12 +3573,14 @@\n           branchId: orderData.memberInfo.branchId,\n           branchName: orderData.memberInfo.branchName,\n           coach: orderData.memberInfo.coach,\n           coachName: orderData.memberInfo.coachName,\n-          enrollmentStatus: unpaidAmount > 0 ? 'unpaid' : 'active',\n-          paidAmount: totalPaid,\n-          unpaidAmount: Math.max(0, product.price - totalPaid),\n+          enrollmentStatus: productUnpaidAmount > 0 ? 'unpaid' : 'active',\n+          paidAmount: productPaidAmount,\n+          unpaidAmount: productUnpaidAmount,\n           startDate: new Date(),\n+          endDate: endDate,\n+          sessionCount: product.programType === '횟수제' ? productDetails?.sessions : undefined,\n           completedSessions: 0,\n           notes: `${orderData.orderType}을 통한 등록`\n         });\n       }\n"
                },
                {
                    "date": 1761367119177,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3524,44 +3524,59 @@\n         console.log(`=== 초과금 포인트 적립 시작: ${excessAmount.toLocaleString()}원 ===`);\n         const expiryDate = new Date();\n         expiryDate.setFullYear(expiryDate.getFullYear() + 1);\n \n-        await this.addPointTransaction({\n-          memberId: orderData.memberInfo.id,\n-          memberName: orderData.memberInfo.name,\n-          amount: excessAmount,\n-          transactionType: 'earn',\n-          relatedOrderId: orderId,\n-          earnedDate: new Date(),\n-          expiryDate,\n-          isExpired: false,\n-          source: `${orderData.orderType} 초과금액`,\n-          description: `${orderData.orderType} 초과금액 포인트 적립`\n-        });\n-        console.log(`포인트 적립 완료: ${excessAmount.toLocaleString()}원`);\n+        try {\n+          await this.addPointTransaction({\n+            memberId: orderData.memberInfo.id,\n+            memberName: orderData.memberInfo.name,\n+            amount: excessAmount,\n+            transactionType: 'earn',\n+            relatedOrderId: orderId,\n+            earnedDate: new Date(),\n+            expiryDate,\n+            isExpired: false,\n+            source: `${orderData.orderType} 초과금액`,\n+            description: `${orderData.orderType} 초과금액 포인트 적립`\n+          });\n+          console.log(`포인트 적립 완료: ${excessAmount.toLocaleString()}원`);\n+          alert(`포인트 적립 완료: ${excessAmount.toLocaleString()}원`);\n+        } catch (pointError) {\n+          console.error('포인트 적립 실패:', pointError);\n+          alert(`포인트 적립 실패: ${pointError}`);\n+          throw pointError;\n+        }\n       } else {\n         console.log('초과금액이 없어 포인트 적립 없음');\n       }\n \n       // 5. 수강 등록 생성 (상품별)\n+      console.log('=== 수강 등록 생성 시작 ===');\n       let remainingPaid = totalPaid;\n       for (const product of orderData.products) {\n+        console.log(`상품 처리: ${product.name} (${product.price.toLocaleString()}원)`);\n+        \n         // 이 상품에 할당될 결제액 계산\n         const productPaidAmount = Math.min(remainingPaid, product.price);\n         const productUnpaidAmount = Math.max(0, product.price - productPaidAmount);\n         remainingPaid -= productPaidAmount;\n \n+        console.log(`- 상품별 결제액: ${productPaidAmount.toLocaleString()}원`);\n+        console.log(`- 상품별 미수액: ${productUnpaidAmount.toLocaleString()}원`);\n+\n         // 상품 상세 정보 조회 (세션 수와 기간 정보를 위해)\n         const productDetails = await this.getProductById(product.id);\n+        console.log('- 상품 상세 정보:', productDetails);\n         \n         // 종료일 계산 (기간제인 경우)\n         let endDate: Date | undefined;\n         if (product.programType === '기간제' && productDetails?.duration) {\n           endDate = new Date();\n           endDate.setMonth(endDate.getMonth() + productDetails.duration);\n+          console.log(`- 기간제 종료일 설정: ${endDate.toISOString()}`);\n         }\n \n-        await this.addCourseEnrollment({\n+        const courseData = {\n           orderId,\n           memberId: orderData.memberInfo.id,\n           memberName: orderData.memberInfo.name,\n           productId: product.id,\n@@ -3573,18 +3588,31 @@\n           branchId: orderData.memberInfo.branchId,\n           branchName: orderData.memberInfo.branchName,\n           coach: orderData.memberInfo.coach,\n           coachName: orderData.memberInfo.coachName,\n-          enrollmentStatus: productUnpaidAmount > 0 ? 'unpaid' : 'active',\n+          enrollmentStatus: (productUnpaidAmount > 0 ? 'unpaid' : 'active') as 'unpaid' | 'active',\n           paidAmount: productPaidAmount,\n           unpaidAmount: productUnpaidAmount,\n           startDate: new Date(),\n           endDate: endDate,\n           sessionCount: product.programType === '횟수제' ? productDetails?.sessions : undefined,\n           completedSessions: 0,\n           notes: `${orderData.orderType}을 통한 등록`\n-        });\n+        };\n+\n+        console.log('- 수강 등록 데이터:', courseData);\n+\n+        try {\n+          const courseId = await this.addCourseEnrollment(courseData);\n+          console.log(`✓ 수강 등록 성공: ${courseId}`);\n+          alert(`수강 등록 성공: ${product.name} - ID: ${courseId.slice(-8)}`);\n+        } catch (courseError) {\n+          console.error(`✗ 수강 등록 실패:`, courseError);\n+          alert(`수강 등록 실패: ${product.name} - 오류: ${courseError}`);\n+          throw courseError;\n+        }\n       }\n+      console.log('=== 수강 등록 생성 완료 ===');\n \n       console.log(`통합 주문 처리 완료: ${orderId}`);\n       return orderId;\n     } catch (error) {\n"
                },
                {
                    "date": 1761368451118,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,3800 +1,32 @@\n /**\n  * IndexedDB를 활용한 로컬 데이터베이스 관리 유틸리티\n- * 백엔드 연결 전까지 브라우저에서 데이터를 영구 저장\n+ * \n+ * ⚠️ 주의: 이 파일은 더 이상 사용되지 않습니다.\n+ * 새로운 모듈화된 구조를 사용하세요:\n+ * \n+ * import { dbManager } from './db';\n+ * \n+ * 사용 예시:\n+ * - 지점 관리: dbManager.branch.getAllBranches()\n+ * - 직원 관리: dbManager.staff.getAllStaff()\n+ * - 회원 관리: dbManager.member.getAllMembers()\n+ * - 결제 관리: dbManager.payment.getAllPayments()\n+ * - 포인트 관리: dbManager.point.getMemberPointBalance()\n+ * - 수강 관리: dbManager.course.getAllCourseEnrollments()\n+ * - 약관 관리: dbManager.terms.getAllTermsDocuments()\n+ * \n+ * 기존 호환성을 위해 이 파일은 유지되지만, \n+ * 새로운 코드는 모듈화된 구조를 사용하는 것을 권장합니다.\n  */\n \n-import { SYSTEM_ADMIN_CONFIG } from '../constants/staffConstants';\n+import { dbManager } from './db';\n \n-export interface DBRecord {\n-  id: string;\n-  createdAt: Date;\n-  updatedAt: Date;\n-}\n+// 기존 호환성을 위한 re-export\n+export { IndexedDBManager } from './db';\n+export * from './db/types';\n \n-export interface Branch extends DBRecord {\n-  name: string;\n-  address?: string;\n-  phone?: string;\n-  isActive: boolean;\n-}\n+// 기본 export\n+export { dbManager };\n \n-export interface AppSettings extends DBRecord {\n-  key: string;\n-  value: string;\n-}\n-\n-export interface Staff extends DBRecord {\n-  name: string;\n-  loginId: string; // 로그인 ID\n-  password: string; // 비밀번호\n-  phone: string;\n-  email: string;\n-  branchId: string;\n-  position: string; // 직급\n-  role: string; // 직책\n-  employmentType: string; // 고용형태\n-  permission: string; // 권한\n-  program?: string; // 담당프로그램 (코치일 경우만)\n-  contractStartDate: Date;\n-  contractEndDate?: Date | null; // 계약종료일 (정규직은 없을 수 있음)\n-  contractFile?: File | null; // 계약서 파일\n-  contractFileName?: string; // 계약서 파일명 저장용\n-  contractFileData?: ArrayBuffer; // 계약서 파일 데이터 저장용\n-  workingHours?: {\n-    start: number; // 기본 근무 시작 시간 (시)\n-    end: number; // 기본 근무 종료 시간 (시)\n-  };\n-  isActive: boolean; // 활성/비활성 상태\n-}\n-\n-export interface Program extends DBRecord {\n-  name: string;\n-  type: string; // '횟수제' | '기간제'\n-  isActive: boolean;\n-}\n-\n-export interface Product extends DBRecord {\n-  name: string;\n-  branchId: string;\n-  programId: string;\n-  programName: string; // 프로그램명 저장 (조회 성능 향상)\n-  programType: string; // 프로그램 종류 저장 (조회 성능 향상)\n-  sessions?: number; // 횟수 (횟수제인 경우에만 필요)\n-  duration?: number; // 소요시간 (분 단위, 횟수제인 경우에만 필요)\n-  price?: number; // 가격\n-  description?: string; // 상품소개\n-  isActive: boolean;\n-}\n-\n-export interface HolidaySettings extends DBRecord {\n-  staffId: string;\n-  date: string; // YYYY-MM-DD 형식\n-  isHoliday: boolean; // true: 휴일, false: 근무일\n-  workingHours?: {\n-    start: number;\n-    end: number;\n-  }; // 해당 날짜의 근무시간 (휴일이 아닌 경우)\n-}\n-\n-export interface TermsDocument extends DBRecord {\n-  type: 'privacy_policy' | 'terms_of_service' | 'business_info' | 'marketing_consent' | 'member_terms' | 'contract';\n-  title: string;\n-  content: string;\n-  version: number; // 버전 관리\n-  isActive: boolean;\n-  publishedAt?: Date | null; // 발행일\n-}\n-\n-export interface Member extends DBRecord {\n-  name: string;\n-  phone: string;\n-  email: string;\n-  birth: string;\n-  gender: 'male' | 'female' | '';\n-  address: string;\n-  sigunguCode: string;\n-  dong: string;\n-  roadAddress: string;\n-  jibunAddress: string;\n-  branchId: string;\n-  branchName: string; // 조회 성능을 위해 저장\n-  coach: string; // 담당 코치 ID\n-  coachName: string; // 조회 성능을 위해 저장\n-  joinPath: string;\n-  loginId: string; // 로그인 ID (공란일 때는 임시값 생성)\n-  loginPassword: string | null; // 로그인 비밀번호 (공란 가능)\n-  enableLogin: boolean;\n-  agreementInfo: {\n-    agreements: Array<{\n-      id: string;\n-      title: string;\n-      content: string;\n-      required: boolean;\n-      agreed: boolean;\n-    }>;\n-    customerSignature: string;\n-    staffSignature: string;\n-  };\n-  isActive: boolean;\n-  registrationDate: string; // 회원가입일\n-  remarks?: string; // 비고\n-}\n-\n-export interface Payment extends DBRecord {\n-  orderId?: string;           // 주문 ID 참조 (기존 데이터 호환성을 위해 optional)\n-  memberId: string;\n-  memberName: string; // 조회 성능을 위해 저장\n-  branchId: string;\n-  branchName: string; // 지점명\n-  coach: string; // 담당 코치 ID\n-  coachName: string; // 담당 코치명\n-  products: Array<{\n-    id: string;\n-    name: string;\n-    price: number;\n-    quantity: number;\n-    programId?: string;\n-    programName?: string;\n-    programType?: string;\n-    description?: string;\n-  }>;\n-  totalAmount: number; // 총 결제 예정 금액\n-  paidAmount: number; // 실제 결제된 금액\n-  unpaidAmount: number; // 미결제 금액 (totalAmount - paidAmount)\n-  paymentStatus: 'pending' | 'completed' | 'cancelled' | 'refunded' | 'unpaid';\n-  paymentMethod?: string;\n-  paymentDate?: Date | null;\n-  // 결제 타입 및 연결 정보 추가\n-  paymentType: 'course' | 'asset' | 'other'; // 수강 결제 | 자산 결제 | 기타\n-  relatedCourseId?: string | null; // 연결된 수강 이력 ID\n-  relatedAssetId?: string | null; // 연결된 자산 ID (향후 사용)\n-  memo?: string; // 메모\n-  \n-  // 새로운 필드 추가\n-  amount?: number;            // 해당 결제수단으로 결제한 금액 (개별 결제 기록용)\n-  paymentReference?: string;  // 결제 참조번호 (카드 승인번호 등)\n-}\n-\n-export interface Point extends DBRecord {\n-  memberId: string;\n-  memberName: string; // 조회 성능을 위해 저장\n-  amount: number; // 포인트 금액 (양수: 적립, 음수: 사용)\n-  type: 'earned' | 'used' | 'expired' | 'adjusted'; // 적립, 사용, 만료, 조정\n-  source: string; // 포인트 발생 출처 (예: '회원등록 초과금', '상품구매', '포인트사용' 등)\n-  description?: string; // 상세 설명\n-  expiryDate?: Date | null; // 만료일 (적립된 포인트의 경우)\n-  relatedPaymentId?: string; // 연관된 결제 ID (있는 경우)\n-}\n-\n-export interface CourseEnrollment extends DBRecord {\n-  orderId?: string; // 주문 ID 참조 (기존 데이터 호환성을 위해 optional)\n-  memberId: string;\n-  memberName: string; // 조회 성능을 위해 저장\n-  productId: string;\n-  productName: string; // 상품명\n-  productPrice: number; // 상품 가격\n-  programId: string;\n-  programName: string; // 프로그램명\n-  programType: string; // 프로그램 타입 ('횟수제' | '기간제')\n-  branchId: string;\n-  branchName: string; // 지점명\n-  coach: string; // 담당 코치 ID\n-  coachName: string; // 담당 코치명\n-  enrollmentStatus: 'active' | 'completed' | 'suspended' | 'cancelled' | 'unpaid'; // 수강 상태 확장\n-  paidAmount: number; // 실제 지불한 금액\n-  unpaidAmount: number; // 미납 금액 (productPrice - paidAmount)\n-  startDate?: Date | null; // 수강 시작일\n-  endDate?: Date | null; // 수강 종료일 (기간제인 경우)\n-  sessionCount?: number; // 총 수업 횟수 (횟수제인 경우)\n-  completedSessions?: number; // 완료된 수업 횟수 (횟수제인 경우, 기본값 0)\n-  notes?: string; // 비고\n-  relatedPaymentId?: string; // 연관된 결제 ID (기존 호환성)\n-}\n-\n-// ==================== 새로운 개선된 스키마 ====================\n-\n-export interface Order extends DBRecord {\n-  memberId: string;\n-  memberName: string;\n-  branchId: string;\n-  branchName: string;\n-  coach: string;\n-  coachName: string;\n-  \n-  // 주문 상품 정보\n-  orderItems: Array<{\n-    productId: string;\n-    productName: string;\n-    programId: string;\n-    programName: string;\n-    programType: string;\n-    price: number;\n-    quantity: number;\n-  }>;\n-  \n-  // 금액 정보\n-  totalAmount: number;        // 총 주문 금액\n-  paidAmount: number;         // 총 지불 금액\n-  unpaidAmount: number;       // 총 미수 금액\n-  pointsUsed: number;         // 사용된 포인트\n-  pointsEarned: number;       // 적립된 포인트 (초과금)\n-  \n-  // 상태 정보\n-  orderStatus: 'pending' | 'completed' | 'partially_paid' | 'cancelled';\n-  orderType: 'registration' | 'course_enrollment' | 'product_purchase';\n-  \n-  memo?: string;\n-}\n-\n-export interface PointTransaction extends DBRecord {\n-  memberId: string;\n-  memberName: string;\n-  \n-  // 거래 정보\n-  amount: number;             // 포인트 금액 (+ 적립, - 사용)\n-  balance: number;            // 거래 후 잔액 (성능 최적화)\n-  transactionType: 'earn' | 'use' | 'expire' | 'adjust' | 'refund';\n-  \n-  // 관련 정보\n-  relatedOrderId?: string;    // 관련 주문 ID\n-  relatedPaymentId?: string;  // 관련 결제 ID (기존 호환성)\n-  \n-  // 포인트 정책\n-  earnedDate?: Date;          // 적립일 (사용/만료 추적용)\n-  expiryDate?: Date;          // 만료일\n-  isExpired: boolean;         // 만료 여부\n-  \n-  source: string;             // 포인트 발생 출처\n-  description?: string;\n-  \n-  // FIFO 처리를 위한 추가 필드\n-  originalTransactionId?: string; // 원본 적립 거래 ID (사용/만료 시)\n-}\n-\n-export interface PointBalance extends DBRecord {\n-  memberId: string;\n-  \n-  // 실시간 잔액 정보\n-  totalBalance: number;       // 총 사용가능 포인트\n-  earnedPoints: number;       // 총 적립 포인트\n-  usedPoints: number;         // 총 사용 포인트\n-  expiredPoints: number;      // 총 만료 포인트\n-  \n-  // 만료 예정 포인트 (성능 최적화)\n-  expiringIn30Days: number;   // 30일 내 만료 예정\n-  expiringIn7Days: number;    // 7일 내 만료 예정\n-  \n-  lastUpdated: Date;          // 마지막 업데이트 시간\n-}\n-\n-class IndexedDBManager {\n-  private dbName: string = 'LavidaDB';\n-  private version: number = 12; // 버전 업데이트 (새로운 스키마 추가)\n-  private db: IDBDatabase | null = null;\n-  private isInitializing: boolean = false; // 단순한 플래그로 변경\n-\n-  constructor() {\n-    this.initDB();\n-  }\n-\n-  /**\n-   * IndexedDB 초기화\n-   */\n-  private async initDB(): Promise<void> {\n-    // 이미 초기화되었으면 바로 반환\n-    if (this.db) {\n-      console.log('IndexedDB가 이미 연결되어 있습니다.');\n-      return Promise.resolve();\n-    }\n-\n-    // 이미 초기화 중이면 대기\n-    if (this.isInitializing) {\n-      console.log('IndexedDB 초기화가 이미 진행 중입니다. 대기 중...');\n-      // 최대 5초까지 대기\n-      for (let i = 0; i < 50; i++) {\n-        await new Promise(resolve => setTimeout(resolve, 100));\n-        if (this.db) {\n-          return;\n-        }\n-      }\n-      throw new Error('IndexedDB 초기화 대기 시간 초과');\n-    }\n-\n-    console.log('IndexedDB 초기화를 시작합니다...');\n-    this.isInitializing = true;\n-    \n-    try {\n-      await new Promise<void>((resolve, reject) => {\n-        const request = indexedDB.open(this.dbName, this.version);\n-\n-        request.onerror = () => {\n-          console.error('❌ IndexedDB 열기 실패:', request.error);\n-          this.isInitializing = false;\n-          reject(request.error);\n-        };\n-\n-        request.onsuccess = () => {\n-          this.db = request.result;\n-          console.log('✅ IndexedDB 연결 성공');\n-          \n-          // DB 연결 오류 핸들러 설정\n-          this.db.onerror = (event) => {\n-            console.error('IndexedDB 오류:', event);\n-          };\n-          \n-          this.isInitializing = false;\n-          resolve();\n-        };\n-\n-        request.onupgradeneeded = (event) => {\n-          console.log('🔄 IndexedDB 스키마 업데이트 중...');\n-          const db = (event.target as IDBOpenDBRequest).result;\n-\n-        // 지점 테이블 생성\n-        if (!db.objectStoreNames.contains('branches')) {\n-          const branchStore = db.createObjectStore('branches', { keyPath: 'id' });\n-          branchStore.createIndex('name', 'name', { unique: true }); // 지점명 고유 제약\n-          branchStore.createIndex('isActive', 'isActive', { unique: false });\n-          branchStore.createIndex('createdAt', 'createdAt', { unique: false });\n-        } else {\n-          // 기존 테이블이 있으면 인덱스 업데이트\n-          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n-          const branchStore = transaction.objectStore('branches');\n-          \n-          // 기존 name 인덱스 삭제 후 unique로 재생성\n-          if (branchStore.indexNames.contains('name')) {\n-            branchStore.deleteIndex('name');\n-          }\n-          branchStore.createIndex('name', 'name', { unique: true });\n-        }\n-\n-        // 직원 테이블 생성\n-        if (!db.objectStoreNames.contains('staff')) {\n-          const staffStore = db.createObjectStore('staff', { keyPath: 'id' });\n-          staffStore.createIndex('name', 'name', { unique: false });\n-          staffStore.createIndex('loginId', 'loginId', { unique: true });\n-          staffStore.createIndex('email', 'email', { unique: true });\n-          staffStore.createIndex('branchId', 'branchId', { unique: false });\n-          staffStore.createIndex('position', 'position', { unique: false });\n-          staffStore.createIndex('role', 'role', { unique: false });\n-          staffStore.createIndex('employmentType', 'employmentType', { unique: false });\n-          staffStore.createIndex('permission', 'permission', { unique: false });\n-          staffStore.createIndex('isActive', 'isActive', { unique: false });\n-          staffStore.createIndex('createdAt', 'createdAt', { unique: false });\n-        } else {\n-          // 기존 테이블이 있으면 인덱스 업데이트 (isActive 인덱스 추가)\n-          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n-          const staffStore = transaction.objectStore('staff');\n-          \n-          if (!staffStore.indexNames.contains('isActive')) {\n-            staffStore.createIndex('isActive', 'isActive', { unique: false });\n-          }\n-        }\n-\n-        // 프로그램 테이블 생성\n-        if (!db.objectStoreNames.contains('programs')) {\n-          const programStore = db.createObjectStore('programs', { keyPath: 'id' });\n-          programStore.createIndex('name', 'name', { unique: true }); // 프로그램명 고유 제약\n-          programStore.createIndex('type', 'type', { unique: false });\n-          programStore.createIndex('isActive', 'isActive', { unique: false });\n-          programStore.createIndex('createdAt', 'createdAt', { unique: false });\n-        } else {\n-          // 기존 테이블이 있으면 인덱스 업데이트\n-          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n-          const programStore = transaction.objectStore('programs');\n-          \n-          // 기존 name 인덱스 삭제 후 unique로 재생성\n-          if (programStore.indexNames.contains('name')) {\n-            programStore.deleteIndex('name');\n-          }\n-          programStore.createIndex('name', 'name', { unique: true });\n-        }\n-\n-        // 상품 테이블 생성\n-        if (!db.objectStoreNames.contains('products')) {\n-          const productStore = db.createObjectStore('products', { keyPath: 'id' });\n-          productStore.createIndex('name', 'name', { unique: false });\n-          productStore.createIndex('branchId', 'branchId', { unique: false });\n-          productStore.createIndex('programId', 'programId', { unique: false });\n-          productStore.createIndex('programType', 'programType', { unique: false });\n-          productStore.createIndex('isActive', 'isActive', { unique: false });\n-          productStore.createIndex('createdAt', 'createdAt', { unique: false });\n-          // 복합 인덱스: 지점별, 프로그램별 조회 최적화\n-          productStore.createIndex('branchProgram', ['branchId', 'programId'], { unique: false });\n-        }\n-\n-        // 휴일설정 테이블 생성\n-        if (!db.objectStoreNames.contains('holidaySettings')) {\n-          const holidayStore = db.createObjectStore('holidaySettings', { keyPath: 'id' });\n-          holidayStore.createIndex('staffId', 'staffId', { unique: false });\n-          holidayStore.createIndex('date', 'date', { unique: false });\n-          holidayStore.createIndex('isHoliday', 'isHoliday', { unique: false });\n-          // 복합 인덱스: 직원별, 날짜별 조회 최적화\n-          holidayStore.createIndex('staffDate', ['staffId', 'date'], { unique: true });\n-        }\n-\n-        // 약관/문서 테이블 생성\n-        if (!db.objectStoreNames.contains('termsDocuments')) {\n-          const termsStore = db.createObjectStore('termsDocuments', { keyPath: 'id' });\n-          termsStore.createIndex('type', 'type', { unique: false });\n-          termsStore.createIndex('language', 'language', { unique: false });\n-          termsStore.createIndex('title', 'title', { unique: false });\n-          termsStore.createIndex('version', 'version', { unique: false });\n-          termsStore.createIndex('isActive', 'isActive', { unique: false });\n-          termsStore.createIndex('publishedAt', 'publishedAt', { unique: false });\n-          termsStore.createIndex('createdAt', 'createdAt', { unique: false });\n-          // 복합 인덱스: 타입별, 언어별 조회 최적화\n-          termsStore.createIndex('typeLanguage', ['type', 'language'], { unique: false });\n-          // 활성 상태 및 최신 버전 조회 최적화\n-          termsStore.createIndex('typeLanguageActive', ['type', 'language', 'isActive'], { unique: false });\n-        }\n-\n-        // 회원 테이블 생성\n-        if (!db.objectStoreNames.contains('members')) {\n-          const memberStore = db.createObjectStore('members', { keyPath: 'id' });\n-          memberStore.createIndex('name', 'name', { unique: false });\n-          memberStore.createIndex('phone', 'phone', { unique: true }); // 전화번호는 고유\n-          memberStore.createIndex('email', 'email', { unique: false });\n-          memberStore.createIndex('branchId', 'branchId', { unique: false });\n-          memberStore.createIndex('coach', 'coach', { unique: false });\n-          memberStore.createIndex('loginId', 'loginId', { unique: true }); // 로그인 ID는 고유\n-          memberStore.createIndex('isActive', 'isActive', { unique: false });\n-          memberStore.createIndex('createdAt', 'createdAt', { unique: false });\n-          // 복합 인덱스: 지점별 회원 조회 최적화\n-          memberStore.createIndex('branchActive', ['branchId', 'isActive'], { unique: false });\n-        }\n-\n-        // 결제 테이블 생성\n-        if (!db.objectStoreNames.contains('payments')) {\n-          const paymentStore = db.createObjectStore('payments', { keyPath: 'id' });\n-          paymentStore.createIndex('memberId', 'memberId', { unique: false });\n-          paymentStore.createIndex('memberName', 'memberName', { unique: false });\n-          paymentStore.createIndex('paymentStatus', 'paymentStatus', { unique: false });\n-          paymentStore.createIndex('paymentDate', 'paymentDate', { unique: false });\n-          paymentStore.createIndex('totalAmount', 'totalAmount', { unique: false });\n-          paymentStore.createIndex('receivedAmount', 'receivedAmount', { unique: false });\n-          paymentStore.createIndex('createdAt', 'createdAt', { unique: false });\n-          // 복합 인덱스: 회원별 결제 조회 최적화\n-          paymentStore.createIndex('memberStatus', ['memberId', 'paymentStatus'], { unique: false });\n-        } else {\n-          // 기존 결제 테이블에 새 인덱스 추가 (receivedAmount)\n-          const transaction = (event.target as IDBOpenDBRequest).transaction!;\n-          const paymentStore = transaction.objectStore('payments');\n-          \n-          if (!paymentStore.indexNames.contains('receivedAmount')) {\n-            paymentStore.createIndex('receivedAmount', 'receivedAmount', { unique: false });\n-          }\n-        }\n-\n-        // 포인트 테이블 생성\n-        if (!db.objectStoreNames.contains('points')) {\n-          const pointStore = db.createObjectStore('points', { keyPath: 'id' });\n-          pointStore.createIndex('memberId', 'memberId', { unique: false });\n-          pointStore.createIndex('memberName', 'memberName', { unique: false });\n-          pointStore.createIndex('type', 'type', { unique: false });\n-          pointStore.createIndex('source', 'source', { unique: false });\n-          pointStore.createIndex('amount', 'amount', { unique: false });\n-          pointStore.createIndex('expiryDate', 'expiryDate', { unique: false });\n-          pointStore.createIndex('relatedPaymentId', 'relatedPaymentId', { unique: false });\n-          pointStore.createIndex('createdAt', 'createdAt', { unique: false });\n-          // 복합 인덱스: 회원별 포인트 조회 최적화\n-          pointStore.createIndex('memberType', ['memberId', 'type'], { unique: false });\n-          // 만료되지 않은 포인트 조회 최적화\n-          pointStore.createIndex('memberActive', ['memberId', 'expiryDate'], { unique: false });\n-        }\n-\n-        // 수강정보 테이블 생성\n-        if (!db.objectStoreNames.contains('courseEnrollments')) {\n-          const courseStore = db.createObjectStore('courseEnrollments', { keyPath: 'id' });\n-          courseStore.createIndex('memberId', 'memberId', { unique: false });\n-          courseStore.createIndex('memberName', 'memberName', { unique: false });\n-          courseStore.createIndex('productId', 'productId', { unique: false });\n-          courseStore.createIndex('productName', 'productName', { unique: false });\n-          courseStore.createIndex('programId', 'programId', { unique: false });\n-          courseStore.createIndex('programName', 'programName', { unique: false });\n-          courseStore.createIndex('programType', 'programType', { unique: false });\n-          courseStore.createIndex('branchId', 'branchId', { unique: false });\n-          courseStore.createIndex('branchName', 'branchName', { unique: false });\n-          courseStore.createIndex('coach', 'coach', { unique: false });\n-          courseStore.createIndex('coachName', 'coachName', { unique: false });\n-          courseStore.createIndex('enrollmentStatus', 'enrollmentStatus', { unique: false });\n-          courseStore.createIndex('paidAmount', 'paidAmount', { unique: false });\n-          courseStore.createIndex('unpaidAmount', 'unpaidAmount', { unique: false });\n-          courseStore.createIndex('startDate', 'startDate', { unique: false });\n-          courseStore.createIndex('endDate', 'endDate', { unique: false });\n-          courseStore.createIndex('relatedPaymentId', 'relatedPaymentId', { unique: false });\n-          courseStore.createIndex('orderId', 'orderId', { unique: false }); // 새로운 필드\n-          courseStore.createIndex('createdAt', 'createdAt', { unique: false });\n-          // 복합 인덱스: 회원별 수강 조회 최적화\n-          courseStore.createIndex('memberStatus', ['memberId', 'enrollmentStatus'], { unique: false });\n-          // 지점별, 프로그램별 수강 조회 최적화\n-          courseStore.createIndex('branchProgram', ['branchId', 'programId'], { unique: false });\n-          // 코치별 수강 조회 최적화\n-          courseStore.createIndex('coachStatus', ['coach', 'enrollmentStatus'], { unique: false });\n-        }\n-\n-        // 주문 테이블 생성 (새로운 스키마)\n-        if (!db.objectStoreNames.contains('orders')) {\n-          const orderStore = db.createObjectStore('orders', { keyPath: 'id' });\n-          orderStore.createIndex('memberId', 'memberId', { unique: false });\n-          orderStore.createIndex('memberName', 'memberName', { unique: false });\n-          orderStore.createIndex('branchId', 'branchId', { unique: false });\n-          orderStore.createIndex('branchName', 'branchName', { unique: false });\n-          orderStore.createIndex('coach', 'coach', { unique: false });\n-          orderStore.createIndex('coachName', 'coachName', { unique: false });\n-          orderStore.createIndex('orderStatus', 'orderStatus', { unique: false });\n-          orderStore.createIndex('orderType', 'orderType', { unique: false });\n-          orderStore.createIndex('totalAmount', 'totalAmount', { unique: false });\n-          orderStore.createIndex('unpaidAmount', 'unpaidAmount', { unique: false });\n-          orderStore.createIndex('createdAt', 'createdAt', { unique: false });\n-          // 복합 인덱스\n-          orderStore.createIndex('memberStatus', ['memberId', 'orderStatus'], { unique: false });\n-          orderStore.createIndex('branchStatus', ['branchId', 'orderStatus'], { unique: false });\n-        }\n-\n-        // 포인트 거래내역 테이블 생성 (새로운 스키마)\n-        if (!db.objectStoreNames.contains('pointTransactions')) {\n-          const ptStore = db.createObjectStore('pointTransactions', { keyPath: 'id' });\n-          ptStore.createIndex('memberId', 'memberId', { unique: false });\n-          ptStore.createIndex('memberName', 'memberName', { unique: false });\n-          ptStore.createIndex('transactionType', 'transactionType', { unique: false });\n-          ptStore.createIndex('relatedOrderId', 'relatedOrderId', { unique: false });\n-          ptStore.createIndex('relatedPaymentId', 'relatedPaymentId', { unique: false });\n-          ptStore.createIndex('earnedDate', 'earnedDate', { unique: false });\n-          ptStore.createIndex('expiryDate', 'expiryDate', { unique: false });\n-          ptStore.createIndex('isExpired', 'isExpired', { unique: false });\n-          ptStore.createIndex('originalTransactionId', 'originalTransactionId', { unique: false });\n-          ptStore.createIndex('createdAt', 'createdAt', { unique: false });\n-          // 복합 인덱스\n-          ptStore.createIndex('memberType', ['memberId', 'transactionType'], { unique: false });\n-          ptStore.createIndex('memberExpiry', ['memberId', 'expiryDate', 'isExpired'], { unique: false });\n-        }\n-\n-        // 포인트 잔액 테이블 생성 (새로운 스키마)\n-        if (!db.objectStoreNames.contains('pointBalances')) {\n-          const pbStore = db.createObjectStore('pointBalances', { keyPath: 'id' });\n-          pbStore.createIndex('memberId', 'memberId', { unique: true }); // 회원당 하나의 잔액 레코드\n-          pbStore.createIndex('totalBalance', 'totalBalance', { unique: false });\n-          pbStore.createIndex('lastUpdated', 'lastUpdated', { unique: false });\n-        }\n-\n-        // 향후 다른 테이블들도 여기에 추가 가능\n-        // 예: 회원, 방문기록 등\n-        };\n-        \n-        // DB 초기화 완료 후 마이그레이션 실행\n-        request.onsuccess = async () => {\n-          this.db = request.result;\n-          this.isInitializing = false;\n-          \n-          try {\n-            // 데이터 마이그레이션 실행 (백그라운드에서)\n-            setTimeout(() => {\n-              this.runMigrations().catch(error => {\n-                console.error('백그라운드 마이그레이션 실패:', error);\n-              });\n-            }, 1000); // 1초 후 실행하여 초기화 완료 후 진행\n-          } catch (error) {\n-            console.error('마이그레이션 스케줄링 실패:', error);\n-          }\n-        };\n-      });\n-    } catch (error) {\n-      console.error('❌ IndexedDB 초기화 중 오류:', error);\n-      this.isInitializing = false;\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 고유 ID 생성 (UUID v4 형식)\n-   */\n-  private generateUUID(): string {\n-    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n-      const r = Math.random() * 16 | 0;\n-      const v = c === 'x' ? r : ((r & 0x3) | 0x8);\n-      return v.toString(16);\n-    });\n-  }\n-\n-  /**\n-   * 트랜잭션 실행 헬퍼\n-   */\n-  private async executeTransaction<T>(\n-    storeName: string,\n-    mode: IDBTransactionMode,\n-    operation: (store: IDBObjectStore) => IDBRequest<T>\n-  ): Promise<T> {\n-    // DB가 없으면 최대 3번 초기화 시도\n-    if (!this.db) {\n-      for (let attempt = 1; attempt <= 3; attempt++) {\n-        try {\n-          await this.initDB();\n-          if (this.db) break;\n-        } catch (error) {\n-          if (attempt === 3) {\n-            throw new Error(`IndexedDB 초기화 실패 (${attempt}번 시도): ${error}`);\n-          }\n-          await new Promise(resolve => setTimeout(resolve, 100 * attempt));\n-        }\n-      }\n-    }\n-    \n-    if (!this.db) {\n-      throw new Error('IndexedDB 연결에 실패했습니다');\n-    }\n-\n-    return new Promise((resolve, reject) => {\n-      try {\n-        const transaction = this.db!.transaction([storeName], mode);\n-        const store = transaction.objectStore(storeName);\n-        \n-        transaction.onerror = () => {\n-          reject(transaction.error || new Error('트랜잭션 오류'));\n-        };\n-        \n-        transaction.onabort = () => {\n-          reject(new Error('트랜잭션이 중단되었습니다'));\n-        };\n-\n-        const request = operation(store);\n-        \n-        request.onsuccess = () => {\n-          resolve(request.result);\n-        };\n-        \n-        request.onerror = () => {\n-          reject(request.error || new Error('요청 오류'));\n-        };\n-      } catch (error) {\n-        reject(error);\n-      }\n-    });\n-  }\n-\n-  // === 지점 관리 메서드들 ===\n-\n-  /**\n-   * 모든 지점 조회\n-   */\n-  async getAllBranches(): Promise<Branch[]> {\n-    try {\n-      return await this.executeTransaction('branches', 'readonly', (store) => \n-        store.getAll()\n-      );\n-    } catch (error) {\n-      console.error('지점 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * ID로 지점 조회\n-   */\n-  async getBranchById(id: string): Promise<Branch | null> {\n-    try {\n-      const result = await this.executeTransaction('branches', 'readonly', (store) => \n-        store.get(id)\n-      );\n-      return result || null;\n-    } catch (error) {\n-      console.error('지점 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 지점 추가\n-   */\n-  async addBranch(branchData: Omit<Branch, 'id' | 'createdAt' | 'updatedAt'>): Promise<Branch> {\n-    const now = new Date();\n-    const newBranch: Branch = {\n-      ...branchData,\n-      id: this.generateUUID(),\n-      createdAt: now,\n-      updatedAt: now,\n-    };\n-\n-    try {\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.add(newBranch)\n-      );\n-      console.log('지점 추가 성공:', newBranch);\n-      return newBranch;\n-    } catch (error) {\n-      console.error('지점 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 지점 수정\n-   */\n-  async updateBranch(id: string, updates: Partial<Omit<Branch, 'id' | 'createdAt'>>): Promise<Branch | null> {\n-    try {\n-      const existing = await this.getBranchById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 지점입니다.');\n-      }\n-\n-      const updatedBranch: Branch = {\n-        ...existing,\n-        ...updates,\n-        updatedAt: new Date(),\n-      };\n-\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.put(updatedBranch)\n-      );\n-\n-      console.log('지점 수정 성공:', updatedBranch);\n-      return updatedBranch;\n-    } catch (error) {\n-      console.error('지점 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 지점 삭제\n-   */\n-  async deleteBranch(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-      console.log('지점 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('지점 삭제 실패:', error);\n-      return false;\n-    }\n-  }\n-\n-  /**\n-   * 활성 지점만 조회\n-   */\n-  async getActiveBranches(): Promise<Branch[]> {\n-    try {\n-      return await this.executeTransaction('branches', 'readonly', (store) => {\n-        const index = store.index('isActive');\n-        return index.getAll(IDBKeyRange.only(true));\n-      });\n-    } catch (error) {\n-      console.error('활성 지점 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 지점명으로 정확히 일치하는 지점 조회 또는 생성 (원자적 처리)\n-   * 동시 실행 시 race condition 방지\n-   */\n-  async getOrCreateBranchByName(name: string, branchData?: Omit<Branch, 'id' | 'createdAt' | 'updatedAt' | 'name'>): Promise<Branch> {\n-    if (!this.db) {\n-      await this.initDB();\n-    }\n-\n-    return new Promise((resolve, reject) => {\n-      const transaction = this.db!.transaction(['branches'], 'readwrite');\n-      const store = transaction.objectStore('branches');\n-      const index = store.index('name');\n-      \n-      // 먼저 기존 지점 확인\n-      const getRequest = index.get(name);\n-      \n-      getRequest.onsuccess = () => {\n-        if (getRequest.result) {\n-          // 이미 존재함\n-          resolve(getRequest.result);\n-        } else {\n-          // 존재하지 않음, 새로 생성\n-          const now = new Date();\n-          const newBranch: Branch = {\n-            name,\n-            address: branchData?.address || '',\n-            phone: branchData?.phone || '',\n-            isActive: branchData?.isActive ?? true,\n-            id: this.generateUUID(),\n-            createdAt: now,\n-            updatedAt: now,\n-          };\n-\n-          const addRequest = store.add(newBranch);\n-          addRequest.onsuccess = () => {\n-            console.log('새 지점 생성 완료:', newBranch);\n-            resolve(newBranch);\n-          };\n-          addRequest.onerror = () => {\n-            console.error('지점 추가 실패:', addRequest.error);\n-            reject(addRequest.error);\n-          };\n-        }\n-      };\n-      \n-      getRequest.onerror = () => {\n-        console.error('지점 조회 실패:', getRequest.error);\n-        reject(getRequest.error);\n-      };\n-    });\n-  }\n-\n-  /**\n-   * 지점명으로 정확히 일치하는 지점 조회\n-   */\n-  async getBranchByName(name: string): Promise<Branch | null> {\n-    try {\n-      const allBranches = await this.getAllBranches();\n-      const branch = allBranches.find(branch => branch.name === name);\n-      return branch || null;\n-    } catch (error) {\n-      console.error('지점명으로 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 지점명으로 검색\n-   */\n-  async searchBranchesByName(name: string): Promise<Branch[]> {\n-    try {\n-      const allBranches = await this.getAllBranches();\n-      return allBranches.filter(branch => \n-        branch.name.toLowerCase().includes(name.toLowerCase())\n-      );\n-    } catch (error) {\n-      console.error('지점 검색 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  // === 직원 관리 메서드들 ===\n-\n-  /**\n-   * 모든 직원 조회\n-   */\n-  async getAllStaff(): Promise<Staff[]> {\n-    try {\n-      const staffList = await this.executeTransaction('staff', 'readonly', (store) => \n-        store.getAll()\n-      );\n-\n-      // 저장된 파일 데이터를 File 객체로 복원\n-      return staffList.map(staff => {\n-        if (staff.contractFileData && staff.contractFileName) {\n-          // 파일 확장자로부터 MIME 타입 추정\n-          const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n-          let mimeType = 'application/octet-stream';\n-          \n-          if (extension === 'pdf') {\n-            mimeType = 'application/pdf';\n-          } else if (['jpg', 'jpeg'].includes(extension || '')) {\n-            mimeType = 'image/jpeg';\n-          } else if (extension === 'png') {\n-            mimeType = 'image/png';\n-          }\n-\n-          staff.contractFile = this.arrayBufferToFile(\n-            staff.contractFileData, \n-            staff.contractFileName, \n-            mimeType\n-          );\n-        }\n-        return staff;\n-      });\n-    } catch (error) {\n-      console.error('직원 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * ID로 직원 조회\n-   */\n-  async getStaffById(id: string): Promise<Staff | null> {\n-    try {\n-      const staff = await this.executeTransaction('staff', 'readonly', (store) => \n-        store.get(id)\n-      );\n-\n-      if (!staff) return null;\n-\n-      // 저장된 파일 데이터를 File 객체로 복원\n-      if (staff.contractFileData && staff.contractFileName) {\n-        const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n-        let mimeType = 'application/octet-stream';\n-        \n-        if (extension === 'pdf') {\n-          mimeType = 'application/pdf';\n-        } else if (['jpg', 'jpeg'].includes(extension || '')) {\n-          mimeType = 'image/jpeg';\n-        } else if (extension === 'png') {\n-          mimeType = 'image/png';\n-        }\n-\n-        staff.contractFile = this.arrayBufferToFile(\n-          staff.contractFileData, \n-          staff.contractFileName, \n-          mimeType\n-        );\n-      }\n-\n-      return staff;\n-    } catch (error) {\n-      console.error('직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 직원 추가\n-   */\n-  async addStaff(staffData: Omit<Staff, 'id' | 'createdAt' | 'updatedAt'>): Promise<Staff> {\n-    const now = new Date();\n-    \n-    // 파일 데이터 처리\n-    let contractFileData: ArrayBuffer | undefined;\n-    let contractFileName: string | undefined;\n-    \n-    if (staffData.contractFile) {\n-      contractFileData = await this.fileToArrayBuffer(staffData.contractFile);\n-      contractFileName = staffData.contractFile.name;\n-    }\n-\n-    const newStaff: Staff = {\n-      ...staffData,\n-      id: this.generateUUID(),\n-      createdAt: now,\n-      updatedAt: now,\n-      isActive: staffData.isActive !== undefined ? staffData.isActive : true, // 기본값 true\n-      contractFile: undefined, // File 객체는 저장하지 않음\n-      contractFileName,\n-      contractFileData,\n-    };\n-\n-    try {\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.add(newStaff)\n-      );\n-      console.log('직원 추가 성공:', newStaff);\n-      return newStaff;\n-    } catch (error) {\n-      console.error('직원 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 시스템 관리자 계정인지 확인\n-   */\n-  private isSystemAdmin(staff: Staff): boolean {\n-    return staff.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID;\n-  }\n-\n-  /**\n-   * 시스템 관리자 보호 검증\n-   */\n-  private validateSystemAdminProtection(staff: Staff, operation: 'delete' | 'permission_change'): void {\n-    if (this.isSystemAdmin(staff)) {\n-      const message = operation === 'delete' \n-        ? '시스템 관리자 계정은 삭제할 수 없습니다.'\n-        : '시스템 관리자 계정의 권한은 변경할 수 없습니다.';\n-      throw new Error(message);\n-    }\n-  }\n-\n-  /**\n-   * 직원 수정\n-   */\n-  async updateStaff(id: string, updates: Partial<Omit<Staff, 'id' | 'createdAt'>>): Promise<Staff | null> {\n-    try {\n-      const existing = await this.getStaffById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 직원입니다.');\n-      }\n-\n-      // 시스템 관리자 권한 변경 보호\n-      if (updates.permission && updates.permission !== existing.permission) {\n-        this.validateSystemAdminProtection(existing, 'permission_change');\n-      }\n-\n-      // 파일 데이터 처리\n-      let contractFileData = existing.contractFileData;\n-      let contractFileName = existing.contractFileName;\n-      \n-      if (updates.contractFile) {\n-        contractFileData = await this.fileToArrayBuffer(updates.contractFile);\n-        contractFileName = updates.contractFile.name;\n-      }\n-\n-      const updatedStaff: Staff = {\n-        ...existing,\n-        ...updates,\n-        updatedAt: new Date(),\n-        contractFile: undefined, // File 객체는 저장하지 않음\n-        contractFileName,\n-        contractFileData,\n-      };\n-\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.put(updatedStaff)\n-      );\n-\n-      console.log('직원 수정 성공:', updatedStaff);\n-      return updatedStaff;\n-    } catch (error) {\n-      console.error('직원 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 직원 삭제\n-   */\n-  async deleteStaff(id: string): Promise<boolean> {\n-    try {\n-      const existing = await this.getStaffById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 직원입니다.');\n-      }\n-\n-      // 시스템 관리자 삭제 보호\n-      this.validateSystemAdminProtection(existing, 'delete');\n-\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-      console.log('직원 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('직원 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 직원 활성/비활성 상태 토글\n-   */\n-  async toggleStaffStatus(id: string): Promise<Staff | null> {\n-    try {\n-      const existing = await this.getStaffById(id);\n-      if (!existing) {\n-        throw new Error('존재하지 않는 직원입니다.');\n-      }\n-\n-      // 시스템 관리자 상태 변경 보호\n-      if (existing.loginId === SYSTEM_ADMIN_CONFIG.SYSTEM_ADMIN_LOGIN_ID) {\n-        throw new Error('시스템 관리자 계정의 상태는 변경할 수 없습니다.');\n-      }\n-\n-      const updatedStaff = {\n-        ...existing,\n-        isActive: !existing.isActive,\n-        updatedAt: new Date()\n-      };\n-\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.put(updatedStaff)\n-      );\n-\n-      console.log('직원 상태 변경 성공:', id, `-> ${updatedStaff.isActive ? '활성' : '비활성'}`);\n-      return updatedStaff;\n-    } catch (error) {\n-      console.error('직원 상태 변경 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 지점별 직원 조회\n-   */\n-  async getStaffByBranch(branchId: string): Promise<Staff[]> {\n-    try {\n-      return await this.executeTransaction('staff', 'readonly', (store) => {\n-        const index = store.index('branchId');\n-        return index.getAll(IDBKeyRange.only(branchId));\n-      });\n-    } catch (error) {\n-      console.error('지점별 직원 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 이메일로 직원 조회\n-   */\n-  async getStaffByEmail(email: string): Promise<Staff | null> {\n-    try {\n-      const result = await this.executeTransaction('staff', 'readonly', (store) => {\n-        const index = store.index('email');\n-        return index.get(email);\n-      });\n-      return result || null;\n-    } catch (error) {\n-      console.error('이메일로 직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 로그인ID로 직원 조회\n-   */\n-  async getStaffByLoginId(loginId: string): Promise<Staff | null> {\n-    try {\n-      const staff = await this.executeTransaction('staff', 'readonly', (store) => {\n-        const index = store.index('loginId');\n-        return index.get(loginId);\n-      });\n-\n-      if (!staff) return null;\n-\n-      // 저장된 파일 데이터를 File 객체로 복원\n-      if (staff.contractFileData && staff.contractFileName) {\n-        const extension = staff.contractFileName.split('.').pop()?.toLowerCase();\n-        let mimeType = 'application/octet-stream';\n-        \n-        if (extension === 'pdf') {\n-          mimeType = 'application/pdf';\n-        } else if (['jpg', 'jpeg'].includes(extension || '')) {\n-          mimeType = 'image/jpeg';\n-        } else if (extension === 'png') {\n-          mimeType = 'image/png';\n-        }\n-\n-        staff.contractFile = this.arrayBufferToFile(\n-          staff.contractFileData, \n-          staff.contractFileName, \n-          mimeType\n-        );\n-      }\n-\n-      return staff;\n-    } catch (error) {\n-      console.error('로그인ID로 직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 전화번호로 직원 조회\n-   */\n-  async getStaffByPhone(phone: string): Promise<Staff | null> {\n-    try {\n-      const allStaff = await this.getAllStaff();\n-      const found = allStaff.find(staff => staff.phone === phone);\n-      return found || null;\n-    } catch (error) {\n-      console.error('전화번호로 직원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 중복 체크 함수 (등록 시 사용)\n-   */\n-  async checkDuplicateStaff(loginId: string, email: string, phone: string): Promise<{\n-    isDuplicate: boolean;\n-    duplicateField?: 'loginId' | 'email' | 'phone';\n-    message?: string;\n-  }> {\n-    try {\n-      // 로그인 ID 중복 체크\n-      const existingByLoginId = await this.getStaffByLoginId(loginId);\n-      if (existingByLoginId) {\n-        return {\n-          isDuplicate: true,\n-          duplicateField: 'loginId',\n-          message: '이미 사용 중인 로그인 ID입니다.'\n-        };\n-      }\n-\n-      // 이메일 중복 체크\n-      const existingByEmail = await this.getStaffByEmail(email);\n-      if (existingByEmail) {\n-        return {\n-          isDuplicate: true,\n-          duplicateField: 'email',\n-          message: '이미 사용 중인 이메일입니다.'\n-        };\n-      }\n-\n-      // 전화번호 중복 체크\n-      const existingByPhone = await this.getStaffByPhone(phone);\n-      if (existingByPhone) {\n-        return {\n-          isDuplicate: true,\n-          duplicateField: 'phone',\n-          message: '이미 사용 중인 전화번호입니다.'\n-        };\n-      }\n-\n-      return { isDuplicate: false };\n-    } catch (error) {\n-      console.error('중복 체크 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 파일을 ArrayBuffer로 변환\n-   */\n-  private fileToArrayBuffer(file: File): Promise<ArrayBuffer> {\n-    return new Promise((resolve, reject) => {\n-      const reader = new FileReader();\n-      reader.onload = () => resolve(reader.result as ArrayBuffer);\n-      reader.onerror = () => reject(reader.error);\n-      reader.readAsArrayBuffer(file);\n-    });\n-  }\n-\n-  /**\n-   * ArrayBuffer를 Blob으로 변환 (파일 다운로드용)\n-   */\n-  arrayBufferToBlob(buffer: ArrayBuffer, mimeType: string): Blob {\n-    return new Blob([buffer], { type: mimeType });\n-  }\n-\n-  /**\n-   * ArrayBuffer를 File 객체로 변환\n-   */\n-  private arrayBufferToFile(buffer: ArrayBuffer, fileName: string, mimeType: string = 'application/octet-stream'): File {\n-    const blob = new Blob([buffer], { type: mimeType });\n-    return new File([blob], fileName, { type: mimeType });\n-  }\n-\n-  /**\n-   * 데이터베이스 초기화 (개발/테스트용)\n-   */\n-  async clearAllData(): Promise<void> {\n-    try {\n-      await this.executeTransaction('branches', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('staff', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('programs', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('products', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('points', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      await this.executeTransaction('courseEnrollments', 'readwrite', (store) => \n-        store.clear()\n-      );\n-      console.log('모든 데이터 삭제 완료');\n-    } catch (error) {\n-      console.error('데이터 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 기존 직원 데이터의 isActive 필드 초기화 (마이그레이션용)\n-   */\n-  async migrateStaffActiveStatus(): Promise<void> {\n-    try {\n-      const allStaff = await this.executeTransaction('staff', 'readonly', (store) => \n-        store.getAll()\n-      );\n-\n-      // isActive 필드가 없는 직원들을 찾아서 업데이트\n-      const staffToUpdate = allStaff.filter(staff => staff.isActive === undefined);\n-      \n-      if (staffToUpdate.length > 0) {\n-        console.log(`${staffToUpdate.length}명의 직원 isActive 필드를 초기화합니다.`);\n-        \n-        for (const staff of staffToUpdate) {\n-          const updatedStaff = {\n-            ...staff,\n-            isActive: true, // 기본값을 true로 설정\n-            updatedAt: new Date()\n-          };\n-          \n-          await this.executeTransaction('staff', 'readwrite', (store) => \n-            store.put(updatedStaff)\n-          );\n-        }\n-        \n-        console.log('직원 isActive 필드 초기화 완료');\n-      }\n-    } catch (error) {\n-      console.error('직원 isActive 필드 초기화 실패:', error);\n-    }\n-  }\n-\n-  // =================== 프로그램 관리 메서드 ===================\n-\n-  /**\n-   * 프로그램 추가\n-   */\n-  async addProgram(programData: Omit<Program, 'id' | 'createdAt' | 'updatedAt'>): Promise<Program> {\n-    try {\n-      // 프로그램명 중복 체크\n-      const existingProgram = await this.getProgramByName(programData.name);\n-      if (existingProgram) {\n-        throw new Error('이미 존재하는 프로그램명입니다.');\n-      }\n-\n-      const newProgram: Program = {\n-        id: this.generateUUID(),\n-        ...programData,\n-        createdAt: new Date(),\n-        updatedAt: new Date()\n-      };\n-\n-      await this.executeTransaction('programs', 'readwrite', (store) => \n-        store.add(newProgram)\n-      );\n-\n-      console.log('프로그램 추가 성공:', newProgram);\n-      return newProgram;\n-    } catch (error) {\n-      console.error('프로그램 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 모든 프로그램 조회\n-   */\n-  async getAllPrograms(): Promise<Program[]> {\n-    try {\n-      const programs = await this.executeTransaction('programs', 'readonly', (store) => \n-        store.getAll()\n-      );\n-      \n-      return programs.map(program => ({\n-        ...program,\n-        createdAt: new Date(program.createdAt),\n-        updatedAt: new Date(program.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('프로그램 목록 조회 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 프로그램명으로 조회\n-   */\n-  async getProgramByName(name: string): Promise<Program | null> {\n-    try {\n-      const program = await this.executeTransaction('programs', 'readonly', (store) => \n-        store.index('name').get(name)\n-      );\n-      \n-      if (program) {\n-        return {\n-          ...program,\n-          createdAt: new Date(program.createdAt),\n-          updatedAt: new Date(program.updatedAt)\n-        };\n-      }\n-      \n-      return null;\n-    } catch (error) {\n-      console.error('프로그램 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 프로그램 수정\n-   */\n-  async updateProgram(id: string, updates: Partial<Omit<Program, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Program | null> {\n-    try {\n-      const existingProgram = await this.executeTransaction('programs', 'readonly', (store) => \n-        store.get(id)\n-      );\n-\n-      if (!existingProgram) {\n-        console.error('수정할 프로그램을 찾을 수 없습니다:', id);\n-        return null;\n-      }\n-\n-      // 프로그램명 변경 시 중복 체크\n-      if (updates.name && updates.name !== existingProgram.name) {\n-        const duplicateProgram = await this.getProgramByName(updates.name);\n-        if (duplicateProgram) {\n-          throw new Error('이미 존재하는 프로그램명입니다.');\n-        }\n-      }\n-\n-      const updatedProgram: Program = {\n-        ...existingProgram,\n-        ...updates,\n-        id,\n-        createdAt: new Date(existingProgram.createdAt),\n-        updatedAt: new Date()\n-      };\n-\n-      await this.executeTransaction('programs', 'readwrite', (store) => \n-        store.put(updatedProgram)\n-      );\n-\n-      console.log('프로그램 수정 성공:', updatedProgram);\n-      return updatedProgram;\n-    } catch (error) {\n-      console.error('프로그램 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 프로그램 삭제\n-   */\n-  async deleteProgram(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('programs', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-\n-      console.log('프로그램 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('프로그램 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  // =================== 상품 관리 메서드 ===================\n-\n-  /**\n-   * 상품 추가\n-   */\n-  async addProduct(productData: Omit<Product, 'id' | 'createdAt' | 'updatedAt'>): Promise<Product> {\n-    try {\n-      const newProduct: Product = {\n-        id: this.generateUUID(),\n-        ...productData,\n-        createdAt: new Date(),\n-        updatedAt: new Date()\n-      };\n-\n-      await this.executeTransaction('products', 'readwrite', (store) => \n-        store.add(newProduct)\n-      );\n-\n-      console.log('상품 추가 성공:', newProduct);\n-      return newProduct;\n-    } catch (error) {\n-      console.error('상품 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 모든 상품 조회\n-   */\n-  async getAllProducts(): Promise<Product[]> {\n-    try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => \n-        store.getAll()\n-      );\n-      \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('상품 목록 조회 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * ID로 상품 조회\n-   */\n-  async getProductById(id: string): Promise<Product | null> {\n-    try {\n-      const product = await this.executeTransaction('products', 'readonly', (store) => \n-        store.get(id)\n-      );\n-      \n-      if (product) {\n-        return {\n-          ...product,\n-          createdAt: new Date(product.createdAt),\n-          updatedAt: new Date(product.updatedAt)\n-        };\n-      }\n-      \n-      return null;\n-    } catch (error) {\n-      console.error('상품 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 지점별 상품 조회\n-   */\n-  async getProductsByBranch(branchId: string): Promise<Product[]> {\n-    try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => {\n-        const index = store.index('branchId');\n-        return index.getAll(IDBKeyRange.only(branchId));\n-      });\n-      \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('지점별 상품 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 프로그램별 상품 조회\n-   */\n-  async getProductsByProgram(programId: string): Promise<Product[]> {\n-    try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => {\n-        const index = store.index('programId');\n-        return index.getAll(IDBKeyRange.only(programId));\n-      });\n-      \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('프로그램별 상품 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 지점과 프로그램으로 상품 조회\n-   */\n-  async getProductsByBranchAndProgram(branchId: string, programId: string): Promise<Product[]> {\n-    try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => {\n-        const index = store.index('branchProgram');\n-        return index.getAll(IDBKeyRange.only([branchId, programId]));\n-      });\n-      \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('지점-프로그램별 상품 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 상품 수정\n-   */\n-  async updateProduct(id: string, updates: Partial<Omit<Product, 'id' | 'createdAt' | 'updatedAt'>>): Promise<Product | null> {\n-    try {\n-      const existingProduct = await this.executeTransaction('products', 'readonly', (store) => \n-        store.get(id)\n-      );\n-\n-      if (!existingProduct) {\n-        console.error('수정할 상품을 찾을 수 없습니다:', id);\n-        return null;\n-      }\n-\n-      const updatedProduct: Product = {\n-        ...existingProduct,\n-        ...updates,\n-        id,\n-        createdAt: new Date(existingProduct.createdAt),\n-        updatedAt: new Date()\n-      };\n-\n-      await this.executeTransaction('products', 'readwrite', (store) => \n-        store.put(updatedProduct)\n-      );\n-\n-      console.log('상품 수정 성공:', updatedProduct);\n-      return updatedProduct;\n-    } catch (error) {\n-      console.error('상품 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 상품 삭제\n-   */\n-  async deleteProduct(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('products', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-\n-      console.log('상품 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('상품 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 활성 상품만 조회\n-   */\n-  async getActiveProducts(): Promise<Product[]> {\n-    try {\n-      const products = await this.executeTransaction('products', 'readonly', (store) => {\n-        const index = store.index('isActive');\n-        return index.getAll(IDBKeyRange.only(true));\n-      });\n-      \n-      return products.map(product => ({\n-        ...product,\n-        createdAt: new Date(product.createdAt),\n-        updatedAt: new Date(product.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('활성 상품 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 상품명으로 검색\n-   */\n-  async searchProductsByName(name: string): Promise<Product[]> {\n-    try {\n-      const allProducts = await this.getAllProducts();\n-      return allProducts.filter(product => \n-        product.name.toLowerCase().includes(name.toLowerCase())\n-      );\n-    } catch (error) {\n-      console.error('상품 검색 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  // ==================== 휴일설정 관련 메서드 ====================\n-\n-  /**\n-   * 휴일설정 추가/업데이트\n-   */\n-  async saveHolidaySettings(settingsArray: Omit<HolidaySettings, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<HolidaySettings[]> {\n-    try {\n-      const savedSettings: HolidaySettings[] = [];\n-      \n-      for (const setting of settingsArray) {\n-        // 기존 설정이 있는지 확인\n-        const existingSettings = await this.getHolidaySettingsByStaffAndDate(setting.staffId, setting.date);\n-        \n-        let savedSetting: HolidaySettings;\n-        \n-        if (existingSettings.length > 0) {\n-          // 업데이트\n-          const existing = existingSettings[0];\n-          savedSetting = {\n-            ...existing,\n-            ...setting,\n-            updatedAt: new Date()\n-          };\n-          \n-          await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n-            store.put(savedSetting)\n-          );\n-        } else {\n-          // 새로 추가\n-          savedSetting = {\n-            ...setting,\n-            id: this.generateUUID(),\n-            createdAt: new Date(),\n-            updatedAt: new Date()\n-          };\n-          \n-          await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n-            store.add(savedSetting)\n-          );\n-        }\n-        \n-        savedSettings.push(savedSetting);\n-      }\n-\n-      console.log('휴일설정 저장 성공:', savedSettings.length);\n-      return savedSettings;\n-    } catch (error) {\n-      console.error('휴일설정 저장 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 특정 직원의 모든 휴일설정 조회\n-   */\n-  async getHolidaySettingsByStaff(staffId: string): Promise<HolidaySettings[]> {\n-    try {\n-      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n-        const index = store.index('staffId');\n-        return index.getAll(IDBKeyRange.only(staffId));\n-      });\n-      \n-      return settings.map(setting => ({\n-        ...setting,\n-        createdAt: new Date(setting.createdAt),\n-        updatedAt: new Date(setting.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('직원별 휴일설정 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 특정 직원의 특정 날짜 휴일설정 조회\n-   */\n-  async getHolidaySettingsByStaffAndDate(staffId: string, date: string): Promise<HolidaySettings[]> {\n-    try {\n-      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n-        const index = store.index('staffDate');\n-        return index.getAll(IDBKeyRange.only([staffId, date]));\n-      });\n-      \n-      return settings.map(setting => ({\n-        ...setting,\n-        createdAt: new Date(setting.createdAt),\n-        updatedAt: new Date(setting.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('직원별 날짜별 휴일설정 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 특정 날짜의 모든 휴일설정 조회\n-   */\n-  async getHolidaySettingsByDate(date: string): Promise<HolidaySettings[]> {\n-    try {\n-      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n-        const index = store.index('date');\n-        return index.getAll(IDBKeyRange.only(date));\n-      });\n-      \n-      return settings.map(setting => ({\n-        ...setting,\n-        createdAt: new Date(setting.createdAt),\n-        updatedAt: new Date(setting.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('날짜별 휴일설정 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 날짜 범위의 휴일설정 조회\n-   */\n-  async getHolidaySettingsByDateRange(startDate: string, endDate: string): Promise<HolidaySettings[]> {\n-    try {\n-      const settings = await this.executeTransaction('holidaySettings', 'readonly', (store) => {\n-        const index = store.index('date');\n-        return index.getAll(IDBKeyRange.bound(startDate, endDate));\n-      });\n-      \n-      return settings.map(setting => ({\n-        ...setting,\n-        createdAt: new Date(setting.createdAt),\n-        updatedAt: new Date(setting.updatedAt)\n-      }));\n-    } catch (error) {\n-      console.error('날짜 범위별 휴일설정 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 휴일설정 삭제\n-   */\n-  async deleteHolidaySettings(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('holidaySettings', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-\n-      console.log('휴일설정 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('휴일설정 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 특정 직원의 모든 휴일설정 삭제\n-   */\n-  async deleteHolidaySettingsByStaff(staffId: string): Promise<boolean> {\n-    try {\n-      const settings = await this.getHolidaySettingsByStaff(staffId);\n-      \n-      for (const setting of settings) {\n-        await this.deleteHolidaySettings(setting.id);\n-      }\n-\n-      console.log('직원 휴일설정 전체 삭제 성공:', staffId);\n-      return true;\n-    } catch (error) {\n-      console.error('직원 휴일설정 전체 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  // ==================== 약관/문서 관련 메서드 ====================\n-\n-  /**\n-   * 약관/문서 추가\n-   */\n-  async addTermsDocument(documentData: Omit<TermsDocument, 'id' | 'createdAt' | 'updatedAt' | 'version'>): Promise<TermsDocument> {\n-    try {\n-      // 같은 타입의 기존 문서들의 최대 버전 찾기\n-      const existingDocs = await this.getTermsDocumentsByType(documentData.type);\n-      const maxVersion = existingDocs.length > 0 ? Math.max(...existingDocs.map(doc => doc.version)) : 0;\n-\n-      // 기존 활성 문서들 비활성화\n-      for (const doc of existingDocs.filter(d => d.isActive)) {\n-        await this.updateTermsDocument(doc.id, { isActive: false });\n-      }\n-\n-      const newDocument: TermsDocument = {\n-        ...documentData,\n-        id: this.generateUUID(),\n-        version: maxVersion + 1,\n-        createdAt: new Date(),\n-        updatedAt: new Date(),\n-        publishedAt: documentData.isActive ? new Date() : null\n-      };\n-\n-      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n-        store.add(newDocument)\n-      );\n-\n-      console.log('약관/문서 추가 성공:', newDocument);\n-      return newDocument;\n-    } catch (error) {\n-      console.error('약관/문서 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 모든 약관/문서 조회\n-   */\n-  async getAllTermsDocuments(): Promise<TermsDocument[]> {\n-    try {\n-      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n-        store.getAll()\n-      );\n-      \n-      return documents.map(doc => ({\n-        ...doc,\n-        createdAt: new Date(doc.createdAt),\n-        updatedAt: new Date(doc.updatedAt),\n-        publishedAt: doc.publishedAt ? new Date(doc.publishedAt) : null\n-      }));\n-    } catch (error) {\n-      console.error('약관/문서 목록 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * ID로 약관/문서 조회\n-   */\n-  async getTermsDocumentById(id: string): Promise<TermsDocument | null> {\n-    try {\n-      const document = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n-        store.get(id)\n-      );\n-      \n-      if (document) {\n-        return {\n-          ...document,\n-          createdAt: new Date(document.createdAt),\n-          updatedAt: new Date(document.updatedAt),\n-          publishedAt: document.publishedAt ? new Date(document.publishedAt) : null\n-        };\n-      }\n-      \n-      return null;\n-    } catch (error) {\n-      console.error('약관/문서 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 타입별 약관/문서 조회\n-   */\n-  async getTermsDocumentsByType(type: TermsDocument['type']): Promise<TermsDocument[]> {\n-    try {\n-      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => {\n-        return store.getAll();\n-      });\n-      \n-      const filteredDocs = documents.filter(doc => doc.type === type);\n-      \n-      return filteredDocs.map(doc => ({\n-        ...doc,\n-        createdAt: new Date(doc.createdAt),\n-        updatedAt: new Date(doc.updatedAt),\n-        publishedAt: doc.publishedAt ? new Date(doc.publishedAt) : null\n-      })).sort((a, b) => b.version - a.version); // 최신 버전부터\n-    } catch (error) {\n-      console.error('타입별 약관/문서 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 활성화된 약관/문서만 조회 (타입별)\n-   */\n-  async getActiveTermsDocument(type: TermsDocument['type']): Promise<TermsDocument | null> {\n-    try {\n-      const documents = await this.executeTransaction('termsDocuments', 'readonly', (store) => {\n-        return store.getAll();\n-      });\n-      \n-      const activeDoc = documents.find(doc => doc.type === type && doc.isActive);\n-      \n-      if (!activeDoc) return null;\n-\n-      return {\n-        ...activeDoc,\n-        createdAt: new Date(activeDoc.createdAt),\n-        updatedAt: new Date(activeDoc.updatedAt),\n-        publishedAt: activeDoc.publishedAt ? new Date(activeDoc.publishedAt) : null\n-      };\n-    } catch (error) {\n-      console.error('활성 약관/문서 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 약관/문서 수정\n-   */\n-  async updateTermsDocument(id: string, updates: Partial<Omit<TermsDocument, 'id' | 'createdAt' | 'updatedAt' | 'version'>>): Promise<TermsDocument | null> {\n-    try {\n-      const existingDocument = await this.executeTransaction('termsDocuments', 'readonly', (store) => \n-        store.get(id)\n-      );\n-\n-      if (!existingDocument) {\n-        console.error('수정할 약관/문서를 찾을 수 없습니다:', id);\n-        return null;\n-      }\n-\n-      // 활성화 시 같은 타입의 다른 문서들 비활성화\n-      if (updates.isActive === true && !existingDocument.isActive) {\n-        const otherDocs = await this.getTermsDocumentsByType(existingDocument.type);\n-        for (const doc of otherDocs.filter((d: TermsDocument) => d.id !== id && d.isActive)) {\n-          await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n-            store.put({\n-              ...doc,\n-              isActive: false,\n-              updatedAt: new Date()\n-            })\n-          );\n-        }\n-      }\n-\n-      const updatedDocument: TermsDocument = {\n-        ...existingDocument,\n-        ...updates,\n-        id,\n-        createdAt: new Date(existingDocument.createdAt),\n-        updatedAt: new Date(),\n-        publishedAt: updates.isActive === true && !existingDocument.isActive ? new Date() : \n-                    updates.isActive === false ? null : \n-                    existingDocument.publishedAt\n-      };\n-\n-      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n-        store.put(updatedDocument)\n-      );\n-\n-      console.log('약관/문서 수정 성공:', updatedDocument);\n-      return updatedDocument;\n-    } catch (error) {\n-      console.error('약관/문서 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 약관/문서 삭제\n-   */\n-  async deleteTermsDocument(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('termsDocuments', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-\n-      console.log('약관/문서 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('약관/문서 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 약관/문서 검색 (제목, 내용)\n-   */\n-  async searchTermsDocuments(searchTerm: string): Promise<TermsDocument[]> {\n-    try {\n-      const allDocuments = await this.getAllTermsDocuments();\n-      const lowerSearchTerm = searchTerm.toLowerCase();\n-      \n-      return allDocuments.filter(doc => \n-        doc.title.toLowerCase().includes(lowerSearchTerm) ||\n-        doc.content.toLowerCase().includes(lowerSearchTerm)\n-      );\n-    } catch (error) {\n-      console.error('약관/문서 검색 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  // ==================== 회원 관리 ====================\n-\n-  /**\n-   * 회원 추가\n-   */\n-  async addMember(memberData: Omit<Member, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n-    try {\n-      console.log('=== addMember 함수 시작 ===');\n-      console.log('받은 memberData:', memberData);\n-      \n-      // 데이터베이스 연결 확인\n-      if (!this.db) {\n-        console.log('데이터베이스가 연결되지 않음, 초기화 시도...');\n-        await this.initDB();\n-      }\n-      console.log('데이터베이스 연결 상태:', this.db ? '연결됨' : '연결 안됨');\n-      \n-      const member: Member = {\n-        id: this.generateUUID(),\n-        ...memberData,\n-        createdAt: new Date(),\n-        updatedAt: new Date(),\n-      };\n-\n-      console.log('생성할 회원 객체:', member);\n-      console.log('회원 ID:', member.id);\n-      \n-      console.log('트랜잭션 시작...');\n-      await this.executeTransaction('members', 'readwrite', (store) => {\n-        console.log('store.add 실행 중...');\n-        console.log('추가할 멤버 객체:', member);\n-        try {\n-          const request = store.add(member);\n-          console.log('store.add 요청 생성됨');\n-          return request;\n-        } catch (storeError) {\n-          console.error('❌ store.add에서 즉시 에러:', storeError);\n-          throw storeError;\n-        }\n-      });\n-\n-      console.log('✅ 회원 추가 성공:', member.id);\n-      \n-      // 즉시 확인\n-      console.log('=== 저장 확인 ===');\n-      const savedMember = await this.executeTransaction('members', 'readonly', (store) => \n-        store.get(member.id)\n-      );\n-      \n-      if (savedMember) {\n-        console.log('✅ 저장된 회원 확인됨:', savedMember);\n-      } else {\n-        console.error('❌ 방금 저장한 회원을 찾을 수 없음');\n-      }\n-      \n-      return member.id;\n-    } catch (error) {\n-      console.error('❌ 회원 추가 실패:', error);\n-      console.error('에러 상세:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 모든 회원 조회\n-   */\n-  async getAllMembers(): Promise<Member[]> {\n-    try {\n-      return await this.executeTransaction('members', 'readonly', (store) => \n-        store.getAll()\n-      );\n-    } catch (error) {\n-      console.error('회원 목록 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * ID로 회원 조회\n-   */\n-  async getMemberById(id: string): Promise<Member | null> {\n-    try {\n-      return await this.executeTransaction('members', 'readonly', (store) => \n-        store.get(id)\n-      ) || null;\n-    } catch (error) {\n-      console.error('회원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 전화번호로 회원 조회\n-   */\n-  async getMemberByPhone(phone: string): Promise<Member | null> {\n-    try {\n-      const result = await this.executeTransaction('members', 'readonly', (store) => {\n-        const index = store.index('phone');\n-        return index.get(phone);\n-      });\n-      \n-      // 활성 회원만 반환\n-      return (result && result.isActive) ? result : null;\n-    } catch (error) {\n-      console.error('전화번호로 회원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 지점별 회원 조회\n-   */\n-  async getMembersByBranch(branchId: string): Promise<Member[]> {\n-    try {\n-      return await this.executeTransaction('members', 'readonly', (store) => {\n-        const index = store.index('branchId');\n-        return index.getAll(branchId);\n-      });\n-    } catch (error) {\n-      console.error('지점별 회원 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 회원 정보 수정\n-   */\n-  async updateMember(id: string, updates: Partial<Omit<Member, 'id' | 'createdAt'>>): Promise<boolean> {\n-    try {\n-      const existingMember = await this.getMemberById(id);\n-      if (!existingMember) {\n-        throw new Error('수정할 회원을 찾을 수 없습니다.');\n-      }\n-\n-      const updatedMember: Member = {\n-        ...existingMember,\n-        ...updates,\n-        updatedAt: new Date(),\n-      };\n-\n-      await this.executeTransaction('members', 'readwrite', (store) => \n-        store.put(updatedMember)\n-      );\n-\n-      console.log('회원 정보 수정 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('회원 정보 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 회원 삭제 (비활성화)\n-   */\n-  async deleteMember(id: string): Promise<boolean> {\n-    try {\n-      await this.updateMember(id, { isActive: false });\n-      console.log('회원 삭제(비활성화) 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('회원 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 회원 검색 (이름, 전화번호, 이메일)\n-   */\n-  async searchMembers(searchTerm: string): Promise<Member[]> {\n-    try {\n-      const allMembers = await this.getAllMembers();\n-      const lowerSearchTerm = searchTerm.toLowerCase();\n-      \n-      return allMembers.filter(member => \n-        member.name.toLowerCase().includes(lowerSearchTerm) ||\n-        member.phone.includes(searchTerm) ||\n-        member.email.toLowerCase().includes(lowerSearchTerm)\n-      );\n-    } catch (error) {\n-      console.error('회원 검색 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 이메일로 회원 조회\n-   */\n-  async getMemberByEmail(email: string): Promise<Member | null> {\n-    try {\n-      // 이메일이 비어있으면 null 반환\n-      if (!email || email.trim() === '') {\n-        return null;\n-      }\n-\n-      // 모든 회원을 조회해서 이메일이 일치하는 회원 찾기 (대소문자 구분 없이)\n-      const allMembers = await this.getAllMembers();\n-      const member = allMembers.find(m => \n-        m.email.toLowerCase() === email.toLowerCase() && m.isActive\n-      );\n-      \n-      return member || null;\n-    } catch (error) {\n-      console.error('이메일로 회원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 회원 중복 체크 (연락처와 이메일)\n-   */\n-  async checkMemberDuplicate(phone: string, email?: string): Promise<{\n-    isDuplicate: boolean;\n-    duplicateField?: 'phone' | 'email';\n-    message?: string;\n-  }> {\n-    try {\n-      // 전화번호 중복 체크\n-      if (phone && phone.trim() !== '') {\n-        const existingByPhone = await this.getMemberByPhone(phone);\n-        if (existingByPhone) {\n-          return {\n-            isDuplicate: true,\n-            duplicateField: 'phone',\n-            message: `연락처 ${phone}는(은) 이미 등록된 회원입니다.`\n-          };\n-        }\n-      }\n-\n-      // 이메일 중복 체크 (이메일이 있는 경우만)\n-      if (email && email.trim() !== '') {\n-        const existingByEmail = await this.getMemberByEmail(email);\n-        if (existingByEmail) {\n-          return {\n-            isDuplicate: true,\n-            duplicateField: 'email',\n-            message: `이메일 ${email}는(은) 이미 등록된 회원입니다.`\n-          };\n-        }\n-      }\n-\n-      return { isDuplicate: false };\n-    } catch (error) {\n-      console.error('회원 중복 체크 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 로그인 ID로 회원 조회\n-   */\n-  async getMemberByLoginId(loginId: string): Promise<Member | null> {\n-    try {\n-      // 로그인 ID가 비어있으면 null 반환\n-      if (!loginId || loginId.trim() === '') {\n-        return null;\n-      }\n-\n-      return await this.executeTransaction('members', 'readonly', (store) => {\n-        const index = store.index('loginId');\n-        return index.get(loginId);\n-      }) || null;\n-    } catch (error) {\n-      console.error('로그인 ID로 회원 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 로그인 ID 중복 체크 (직원과 회원 모두 확인)\n-   */\n-  async checkLoginIdDuplicate(loginId: string): Promise<{\n-    isDuplicate: boolean;\n-    duplicateType?: 'staff' | 'member';\n-    message?: string;\n-  }> {\n-    try {\n-      // 로그인 ID가 비어있거나 임시 ID이면 중복 없음\n-      if (!loginId || loginId.trim() === '' || loginId.startsWith('temp_')) {\n-        return { isDuplicate: false };\n-      }\n-\n-      // 직원 테이블에서 중복 검사\n-      const existingStaff = await this.getStaffByLoginId(loginId);\n-      if (existingStaff) {\n-        return {\n-          isDuplicate: true,\n-          duplicateType: 'staff',\n-          message: `로그인 ID ${loginId}는(은) 이미 직원으로 등록되어 있습니다.`\n-        };\n-      }\n-\n-      // 회원 테이블에서 중복 검사\n-      const existingMember = await this.getMemberByLoginId(loginId);\n-      if (existingMember && !existingMember.loginId.startsWith('temp_')) {\n-        return {\n-          isDuplicate: true,\n-          duplicateType: 'member',\n-          message: `로그인 ID ${loginId}는(은) 이미 회원으로 등록되어 있습니다.`\n-        };\n-      }\n-\n-      return { isDuplicate: false };\n-    } catch (error) {\n-      console.error('로그인 ID 중복 체크 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  // ==================== 결제 관리 ====================\n-\n-  /**\n-   * 결제 정보 추가\n-   */\n-  async addPayment(paymentData: Omit<Payment, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n-    try {\n-      const payment: Payment = {\n-        id: this.generateUUID(),\n-        ...paymentData,\n-        createdAt: new Date(),\n-        updatedAt: new Date(),\n-      };\n-\n-      await this.executeTransaction('payments', 'readwrite', (store) => \n-        store.add(payment)\n-      );\n-\n-      console.log('결제 정보 추가 성공:', payment.id);\n-      return payment.id;\n-    } catch (error) {\n-      console.error('결제 정보 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 모든 결제 정보 조회\n-   */\n-  async getAllPayments(): Promise<Payment[]> {\n-    try {\n-      return await this.executeTransaction('payments', 'readonly', (store) => \n-        store.getAll()\n-      );\n-    } catch (error) {\n-      console.error('결제 목록 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * ID로 결제 정보 조회\n-   */\n-  async getPaymentById(id: string): Promise<Payment | null> {\n-    try {\n-      return await this.executeTransaction('payments', 'readonly', (store) => \n-        store.get(id)\n-      ) || null;\n-    } catch (error) {\n-      console.error('결제 정보 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 회원별 결제 정보 조회\n-   */\n-  async getPaymentsByMember(memberId: string): Promise<Payment[]> {\n-    try {\n-      return await this.executeTransaction('payments', 'readonly', (store) => {\n-        const index = store.index('memberId');\n-        return index.getAll(memberId);\n-      });\n-    } catch (error) {\n-      console.error('회원별 결제 정보 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 결제 정보 수정\n-   */\n-  async updatePayment(id: string, updates: Partial<Omit<Payment, 'id' | 'createdAt'>>): Promise<boolean> {\n-    try {\n-      const existingPayment = await this.getPaymentById(id);\n-      if (!existingPayment) {\n-        throw new Error('수정할 결제 정보를 찾을 수 없습니다.');\n-      }\n-\n-      const updatedPayment: Payment = {\n-        ...existingPayment,\n-        ...updates,\n-        updatedAt: new Date(),\n-      };\n-\n-      await this.executeTransaction('payments', 'readwrite', (store) => \n-        store.put(updatedPayment)\n-      );\n-\n-      console.log('결제 정보 수정 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('결제 정보 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 결제 정보 삭제\n-   */\n-  async deletePayment(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('payments', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-\n-      console.log('결제 정보 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('결제 정보 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  // ==================== 포인트 관리 ====================\n-\n-  /**\n-   * 포인트 적립\n-   */\n-  async addPoint(pointData: Omit<Point, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n-    try {\n-      const point: Point = {\n-        id: this.generateUUID(),\n-        ...pointData,\n-        createdAt: new Date(),\n-        updatedAt: new Date(),\n-      };\n-\n-      await this.executeTransaction('points', 'readwrite', (store) => \n-        store.add(point)\n-      );\n-\n-      console.log('포인트 적립 성공:', point.id, `${point.amount}원`);\n-      return point.id;\n-    } catch (error) {\n-      console.error('포인트 적립 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 회원별 포인트 내역 조회\n-   */\n-  async getPointsByMember(memberId: string): Promise<Point[]> {\n-    try {\n-      return await this.executeTransaction('points', 'readonly', (store) => {\n-        const index = store.index('memberId');\n-        return index.getAll(memberId);\n-      });\n-    } catch (error) {\n-      console.error('회원별 포인트 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 회원의 현재 사용 가능한 포인트 잔액 계산\n-   */\n-  async getMemberPointBalance(memberId: string): Promise<number> {\n-    try {\n-      const points = await this.getPointsByMember(memberId);\n-      const now = new Date();\n-      \n-      // 만료되지 않은 포인트들만 계산\n-      const validPoints = points.filter(point => {\n-        // 만료일이 없거나 만료일이 지나지 않은 경우\n-        return !point.expiryDate || point.expiryDate > now;\n-      });\n-      \n-      // 총 포인트 합계 (적립은 +, 사용은 -)\n-      return validPoints.reduce((total, point) => total + point.amount, 0);\n-    } catch (error) {\n-      console.error('포인트 잔액 계산 실패:', error);\n-      return 0;\n-    }\n-  }\n-\n-  /**\n-   * 포인트 사용\n-   */\n-  async usePoints(memberId: string, amount: number, source: string, description?: string, relatedPaymentId?: string): Promise<string> {\n-    try {\n-      // 사용 가능한 포인트 잔액 확인\n-      const currentBalance = await this.getMemberPointBalance(memberId);\n-      \n-      if (currentBalance < amount) {\n-        throw new Error(`포인트가 부족합니다. 현재 잔액: ${currentBalance.toLocaleString()}원, 사용 요청: ${amount.toLocaleString()}원`);\n-      }\n-\n-      // 회원 정보 조회\n-      const member = await this.getMemberById(memberId);\n-      if (!member) {\n-        throw new Error('회원 정보를 찾을 수 없습니다.');\n-      }\n-\n-      // 포인트 사용 내역 추가 (음수로 저장)\n-      return await this.addPoint({\n-        memberId,\n-        memberName: member.name,\n-        amount: -amount, // 사용은 음수\n-        type: 'used',\n-        source,\n-        description,\n-        relatedPaymentId\n-      });\n-    } catch (error) {\n-      console.error('포인트 사용 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 만료된 포인트 처리\n-   */\n-  async expirePoints(): Promise<number> {\n-    try {\n-      const now = new Date();\n-      const allPoints = await this.executeTransaction('points', 'readonly', (store) => \n-        store.getAll()\n-      );\n-      \n-      // 만료된 적립 포인트 찾기 (type이 'earned'이고 만료일이 지난 것들)\n-      const expiredPoints = allPoints.filter(point => \n-        point.type === 'earned' && \n-        point.expiryDate && \n-        point.expiryDate <= now &&\n-        point.amount > 0 // 적립된 포인트만\n-      );\n-      \n-      let expiredCount = 0;\n-      \n-      // 각 만료된 포인트에 대해 만료 처리 레코드 생성\n-      for (const expiredPoint of expiredPoints) {\n-        await this.addPoint({\n-          memberId: expiredPoint.memberId,\n-          memberName: expiredPoint.memberName,\n-          amount: -expiredPoint.amount, // 만료는 음수로 차감\n-          type: 'expired',\n-          source: '포인트 만료',\n-          description: `${expiredPoint.expiryDate.toLocaleDateString()} 만료된 포인트`,\n-          relatedPaymentId: expiredPoint.relatedPaymentId\n-        });\n-        \n-        expiredCount++;\n-      }\n-      \n-      console.log(`만료된 포인트 처리 완료: ${expiredCount}건`);\n-      return expiredCount;\n-    } catch (error) {\n-      console.error('포인트 만료 처리 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 포인트 내역 검색\n-   */\n-  async searchPoints(searchTerm: string): Promise<Point[]> {\n-    try {\n-      const allPoints = await this.executeTransaction('points', 'readonly', (store) => \n-        store.getAll()\n-      );\n-      \n-      const lowerSearchTerm = searchTerm.toLowerCase();\n-      \n-      return allPoints.filter(point => \n-        point.memberName.toLowerCase().includes(lowerSearchTerm) ||\n-        point.source.toLowerCase().includes(lowerSearchTerm) ||\n-        (point.description && point.description.toLowerCase().includes(lowerSearchTerm))\n-      );\n-    } catch (error) {\n-      console.error('포인트 검색 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 회원의 포인트 적립/사용 통계\n-   */\n-  async getMemberPointStats(memberId: string): Promise<{\n-    totalEarned: number;\n-    totalUsed: number;\n-    totalExpired: number;\n-    currentBalance: number;\n-    transactionCount: number;\n-  }> {\n-    try {\n-      const points = await this.getPointsByMember(memberId);\n-      \n-      const totalEarned = points\n-        .filter(p => p.type === 'earned')\n-        .reduce((sum, p) => sum + p.amount, 0);\n-        \n-      const totalUsed = Math.abs(points\n-        .filter(p => p.type === 'used')\n-        .reduce((sum, p) => sum + p.amount, 0));\n-        \n-      const totalExpired = Math.abs(points\n-        .filter(p => p.type === 'expired')\n-        .reduce((sum, p) => sum + p.amount, 0));\n-      \n-      const currentBalance = await this.getMemberPointBalance(memberId);\n-      \n-      return {\n-        totalEarned,\n-        totalUsed,\n-        totalExpired,\n-        currentBalance,\n-        transactionCount: points.length\n-      };\n-    } catch (error) {\n-      console.error('포인트 통계 조회 실패:', error);\n-      return {\n-        totalEarned: 0,\n-        totalUsed: 0,\n-        totalExpired: 0,\n-        currentBalance: 0,\n-        transactionCount: 0\n-      };\n-    }\n-  }\n-\n-  /**\n-   * 모든 포인트 내역 조회\n-   */\n-  async getAllPoints(): Promise<Point[]> {\n-    try {\n-      return await this.executeTransaction('points', 'readonly', (store) => \n-        store.getAll()\n-      );\n-    } catch (error) {\n-      console.error('포인트 내역 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  // ==================== 수강정보 관리 ====================\n-\n-  /**\n-   * 수강정보 추가\n-   */\n-  async addCourseEnrollment(enrollmentData: Omit<CourseEnrollment, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n-    try {\n-      const enrollment: CourseEnrollment = {\n-        id: this.generateUUID(),\n-        ...enrollmentData,\n-        createdAt: new Date(),\n-        updatedAt: new Date(),\n-      };\n-\n-      await this.executeTransaction('courseEnrollments', 'readwrite', (store) => \n-        store.add(enrollment)\n-      );\n-\n-      console.log('수강정보 추가 성공:', enrollment.id);\n-      return enrollment.id;\n-    } catch (error) {\n-      console.error('수강정보 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 모든 수강정보 조회\n-   */\n-  async getAllCourseEnrollments(): Promise<CourseEnrollment[]> {\n-    try {\n-      return await this.executeTransaction('courseEnrollments', 'readonly', (store) => \n-        store.getAll()\n-      );\n-    } catch (error) {\n-      console.error('수강정보 목록 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * ID로 수강정보 조회\n-   */\n-  async getCourseEnrollmentById(id: string): Promise<CourseEnrollment | null> {\n-    try {\n-      return await this.executeTransaction('courseEnrollments', 'readonly', (store) => \n-        store.get(id)\n-      ) || null;\n-    } catch (error) {\n-      console.error('수강정보 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 회원별 수강정보 조회\n-   */\n-  async getCourseEnrollmentsByMember(memberId: string): Promise<CourseEnrollment[]> {\n-    try {\n-      return await this.executeTransaction('courseEnrollments', 'readonly', (store) => {\n-        const index = store.index('memberId');\n-        return index.getAll(memberId);\n-      });\n-    } catch (error) {\n-      console.error('회원별 수강정보 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 지점별 수강정보 조회\n-   */\n-  async getCourseEnrollmentsByBranch(branchId: string): Promise<CourseEnrollment[]> {\n-    try {\n-      return await this.executeTransaction('courseEnrollments', 'readonly', (store) => {\n-        const index = store.index('branchId');\n-        return index.getAll(branchId);\n-      });\n-    } catch (error) {\n-      console.error('지점별 수강정보 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 코치별 수강정보 조회\n-   */\n-  async getCourseEnrollmentsByCoach(coachId: string): Promise<CourseEnrollment[]> {\n-    try {\n-      return await this.executeTransaction('courseEnrollments', 'readonly', (store) => {\n-        const index = store.index('coach');\n-        return index.getAll(coachId);\n-      });\n-    } catch (error) {\n-      console.error('코치별 수강정보 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 수강상태별 수강정보 조회\n-   */\n-  async getCourseEnrollmentsByStatus(status: 'completed' | 'unpaid'): Promise<CourseEnrollment[]> {\n-    try {\n-      return await this.executeTransaction('courseEnrollments', 'readonly', (store) => {\n-        const index = store.index('enrollmentStatus');\n-        return index.getAll(status);\n-      });\n-    } catch (error) {\n-      console.error('상태별 수강정보 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 프로그램별 수강정보 조회\n-   */\n-  async getCourseEnrollmentsByProgram(programId: string): Promise<CourseEnrollment[]> {\n-    try {\n-      return await this.executeTransaction('courseEnrollments', 'readonly', (store) => {\n-        const index = store.index('programId');\n-        return index.getAll(programId);\n-      });\n-    } catch (error) {\n-      console.error('프로그램별 수강정보 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 미수 수강정보 조회 (회원별)\n-   */\n-  async getUnpaidCourseEnrollmentsByMember(memberId: string): Promise<CourseEnrollment[]> {\n-    try {\n-      return await this.executeTransaction('courseEnrollments', 'readonly', (store) => {\n-        const index = store.index('memberStatus');\n-        return index.getAll([memberId, 'unpaid']);\n-      });\n-    } catch (error) {\n-      console.error('회원별 미수 수강정보 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 수강정보 수정\n-   */\n-  async updateCourseEnrollment(id: string, updates: Partial<Omit<CourseEnrollment, 'id' | 'createdAt'>>): Promise<boolean> {\n-    try {\n-      const existingEnrollment = await this.getCourseEnrollmentById(id);\n-      if (!existingEnrollment) {\n-        throw new Error('수정할 수강정보를 찾을 수 없습니다.');\n-      }\n-\n-      const updatedEnrollment: CourseEnrollment = {\n-        ...existingEnrollment,\n-        ...updates,\n-        updatedAt: new Date(),\n-      };\n-\n-      await this.executeTransaction('courseEnrollments', 'readwrite', (store) => \n-        store.put(updatedEnrollment)\n-      );\n-\n-      console.log('수강정보 수정 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('수강정보 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 수강정보 삭제\n-   */\n-  async deleteCourseEnrollment(id: string): Promise<boolean> {\n-    try {\n-      await this.executeTransaction('courseEnrollments', 'readwrite', (store) => \n-        store.delete(id)\n-      );\n-\n-      console.log('수강정보 삭제 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('수강정보 삭제 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 수강정보 검색 (회원명, 상품명, 프로그램명으로 검색)\n-   */\n-  async searchCourseEnrollments(searchTerm: string): Promise<CourseEnrollment[]> {\n-    try {\n-      const allEnrollments = await this.getAllCourseEnrollments();\n-      const lowerSearchTerm = searchTerm.toLowerCase();\n-      \n-      return allEnrollments.filter(enrollment => \n-        enrollment.memberName.toLowerCase().includes(lowerSearchTerm) ||\n-        enrollment.productName.toLowerCase().includes(lowerSearchTerm) ||\n-        enrollment.programName.toLowerCase().includes(lowerSearchTerm) ||\n-        enrollment.branchName.toLowerCase().includes(lowerSearchTerm) ||\n-        enrollment.coachName.toLowerCase().includes(lowerSearchTerm)\n-      );\n-    } catch (error) {\n-      console.error('수강정보 검색 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 회원의 미수 총액 계산\n-   */\n-  async getMemberUnpaidTotal(memberId: string): Promise<number> {\n-    try {\n-      const unpaidEnrollments = await this.getUnpaidCourseEnrollmentsByMember(memberId);\n-      return unpaidEnrollments.reduce((total, enrollment) => total + enrollment.unpaidAmount, 0);\n-    } catch (error) {\n-      console.error('회원 미수 총액 계산 실패:', error);\n-      return 0;\n-    }\n-  }\n-\n-  /**\n-   * 수강정보 일괄 추가 (회원가입 시 사용)\n-   */\n-  async addMultipleCourseEnrollments(enrollmentsData: Omit<CourseEnrollment, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<string[]> {\n-    try {\n-      const enrollmentIds: string[] = [];\n-\n-      for (const enrollmentData of enrollmentsData) {\n-        const enrollmentId = await this.addCourseEnrollment(enrollmentData);\n-        enrollmentIds.push(enrollmentId);\n-      }\n-\n-      console.log('수강정보 일괄 추가 성공:', enrollmentIds.length, '건');\n-      return enrollmentIds;\n-    } catch (error) {\n-      console.error('수강정보 일괄 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 전체 미수 메타정보 조회 (미수 회원 수와 총 미수 금액)\n-   */\n-  async getUnpaidMetaInfo(): Promise<{ unpaidMemberCount: number; totalUnpaidAmount: number }> {\n-    try {\n-      const unpaidEnrollments = await this.executeTransaction('courseEnrollments', 'readonly', (store) => {\n-        const index = store.index('enrollmentStatus');\n-        return index.getAll('unpaid');\n-      });\n-      \n-      // 미수 회원 ID 중복 제거\n-      const uniqueUnpaidMembers = new Set(unpaidEnrollments.map((e: CourseEnrollment) => e.memberId));\n-      const unpaidMemberCount = uniqueUnpaidMembers.size;\n-      \n-      // 총 미수 금액 계산\n-      const totalUnpaidAmount = unpaidEnrollments.reduce((total: number, enrollment: CourseEnrollment) => total + enrollment.unpaidAmount, 0);\n-      \n-      return {\n-        unpaidMemberCount,\n-        totalUnpaidAmount\n-      };\n-    } catch (error) {\n-      console.error('전체 미수 메타정보 조회 실패:', error);\n-      return {\n-        unpaidMemberCount: 0,\n-        totalUnpaidAmount: 0\n-      };\n-    }\n-  }\n-\n-  // ==================== 새로운 개선된 주문 관리 ====================\n-\n-  /**\n-   * 주문 생성\n-   */\n-  async createOrder(orderData: Omit<Order, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {\n-    try {\n-      const order: Order = {\n-        id: this.generateUUID(),\n-        ...orderData,\n-        createdAt: new Date(),\n-        updatedAt: new Date(),\n-      };\n-\n-      await this.executeTransaction('orders', 'readwrite', (store) => \n-        store.add(order)\n-      );\n-\n-      console.log('주문 생성 성공:', order.id);\n-      return order.id;\n-    } catch (error) {\n-      console.error('주문 생성 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 주문 조회\n-   */\n-  async getOrderById(id: string): Promise<Order | null> {\n-    try {\n-      return await this.executeTransaction('orders', 'readonly', (store) => \n-        store.get(id)\n-      ) || null;\n-    } catch (error) {\n-      console.error('주문 조회 실패:', error);\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * 회원별 주문 조회\n-   */\n-  async getOrdersByMember(memberId: string): Promise<Order[]> {\n-    try {\n-      return await this.executeTransaction('orders', 'readonly', (store) => {\n-        const index = store.index('memberId');\n-        return index.getAll(memberId);\n-      });\n-    } catch (error) {\n-      console.error('회원별 주문 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 주문 상태 업데이트\n-   */\n-  async updateOrderStatus(orderId: string): Promise<void> {\n-    try {\n-      const order = await this.getOrderById(orderId);\n-      if (!order) throw new Error('주문을 찾을 수 없습니다.');\n-\n-      let newStatus: Order['orderStatus'];\n-      if (order.unpaidAmount <= 0) {\n-        newStatus = 'completed';\n-      } else if (order.paidAmount > 0) {\n-        newStatus = 'partially_paid';\n-      } else {\n-        newStatus = 'pending';\n-      }\n-\n-      await this.updateOrder(orderId, { orderStatus: newStatus });\n-    } catch (error) {\n-      console.error('주문 상태 업데이트 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 주문 수정\n-   */\n-  async updateOrder(id: string, updates: Partial<Omit<Order, 'id' | 'createdAt'>>): Promise<boolean> {\n-    try {\n-      const existingOrder = await this.getOrderById(id);\n-      if (!existingOrder) {\n-        throw new Error('수정할 주문을 찾을 수 없습니다.');\n-      }\n-\n-      const updatedOrder: Order = {\n-        ...existingOrder,\n-        ...updates,\n-        updatedAt: new Date(),\n-      };\n-\n-      await this.executeTransaction('orders', 'readwrite', (store) => \n-        store.put(updatedOrder)\n-      );\n-\n-      console.log('주문 수정 성공:', id);\n-      return true;\n-    } catch (error) {\n-      console.error('주문 수정 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  // ==================== 개선된 포인트 시스템 ====================\n-\n-  /**\n-   * 포인트 거래 추가\n-   */\n-  async addPointTransaction(transactionData: Omit<PointTransaction, 'id' | 'createdAt' | 'updatedAt' | 'balance'>): Promise<string> {\n-    try {\n-      // 현재 잔액 계산\n-      const currentBalance = await this.getMemberPointBalance(transactionData.memberId);\n-      const newBalance = currentBalance + transactionData.amount;\n-\n-      const transaction: PointTransaction = {\n-        id: this.generateUUID(),\n-        ...transactionData,\n-        balance: newBalance,\n-        isExpired: transactionData.isExpired || false,\n-        createdAt: new Date(),\n-        updatedAt: new Date(),\n-      };\n-\n-      await this.executeTransaction('pointTransactions', 'readwrite', (store) => \n-        store.add(transaction)\n-      );\n-\n-      // 포인트 잔액 테이블 업데이트\n-      await this.updatePointBalance(transactionData.memberId);\n-\n-      console.log('포인트 거래 추가 성공:', transaction.id, `${transaction.amount}원`);\n-      return transaction.id;\n-    } catch (error) {\n-      console.error('포인트 거래 추가 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * FIFO 방식 포인트 사용\n-   */\n-  async usePointsFIFO(memberId: string, amount: number, orderId: string, source: string = '상품구매'): Promise<void> {\n-    try {\n-      // 1. 사용 가능한 포인트를 적립일 순으로 조회\n-      const availablePoints = await this.getAvailablePointsOrderByEarnedDate(memberId);\n-      \n-      let remainingAmount = amount;\n-      const usageRecords = [];\n-      \n-      // 2. FIFO 방식으로 포인트 차감 계획 수립\n-      for (const pointBatch of availablePoints) {\n-        if (remainingAmount <= 0) break;\n-        \n-        const useAmount = Math.min(remainingAmount, pointBatch.availableAmount);\n-        usageRecords.push({\n-          originalTransactionId: pointBatch.id,\n-          amount: useAmount,\n-          earnedDate: pointBatch.earnedDate\n-        });\n-        \n-        remainingAmount -= useAmount;\n-      }\n-      \n-      if (remainingAmount > 0) {\n-        throw new Error(`포인트 잔액이 부족합니다. 부족 금액: ${remainingAmount.toLocaleString()}원`);\n-      }\n-      \n-      // 3. 사용 내역 기록\n-      const member = await this.getMemberById(memberId);\n-      for (const usage of usageRecords) {\n-        await this.addPointTransaction({\n-          memberId,\n-          memberName: member?.name || '',\n-          amount: -usage.amount,\n-          transactionType: 'use',\n-          relatedOrderId: orderId,\n-          earnedDate: usage.earnedDate,\n-          originalTransactionId: usage.originalTransactionId,\n-          isExpired: false,\n-          source,\n-          description: `FIFO 방식 포인트 사용 (원본: ${usage.originalTransactionId.slice(-8)})`\n-        });\n-      }\n-      \n-      console.log(`FIFO 포인트 사용 완료: ${amount.toLocaleString()}원, ${usageRecords.length}개 배치에서 차감`);\n-    } catch (error) {\n-      console.error('FIFO 포인트 사용 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 적립일 순으로 사용 가능한 포인트 조회\n-   */\n-  async getAvailablePointsOrderByEarnedDate(memberId: string): Promise<Array<{\n-    id: string;\n-    availableAmount: number;\n-    earnedDate: Date;\n-  }>> {\n-    try {\n-      const transactions = await this.executeTransaction('pointTransactions', 'readonly', (store) => {\n-        return store.getAll();\n-      }).then(allTransactions => \n-        allTransactions.filter(t => t.memberId === memberId)\n-      );\n-\n-      // 적립된 포인트들을 그룹화하고 사용/만료된 포인트를 차감\n-      const earnedTransactions = transactions.filter(t => \n-        t.transactionType === 'earn' && \n-        !t.isExpired &&\n-        (!t.expiryDate || t.expiryDate > new Date())\n-      );\n-\n-      const availablePoints = [];\n-      \n-      for (const earnedTx of earnedTransactions) {\n-        // 해당 적립 포인트에서 사용/만료된 금액 계산\n-        const usedAmount = transactions\n-          .filter(t => \n-            t.originalTransactionId === earnedTx.id && \n-            (t.transactionType === 'use' || t.transactionType === 'expire')\n-          )\n-          .reduce((sum, t) => sum + Math.abs(t.amount), 0);\n-\n-        const availableAmount = earnedTx.amount - usedAmount;\n-        \n-        if (availableAmount > 0) {\n-          availablePoints.push({\n-            id: earnedTx.id,\n-            availableAmount,\n-            earnedDate: earnedTx.earnedDate || earnedTx.createdAt\n-          });\n-        }\n-      }\n-\n-      // 적립일 순으로 정렬 (오래된 것부터)\n-      return availablePoints.sort((a, b) => a.earnedDate.getTime() - b.earnedDate.getTime());\n-    } catch (error) {\n-      console.error('사용 가능한 포인트 조회 실패:', error);\n-      return [];\n-    }\n-  }\n-\n-  /**\n-   * 포인트 잔액 테이블 업데이트\n-   */\n-  async updatePointBalance(memberId: string): Promise<void> {\n-    try {\n-      const transactions = await this.executeTransaction('pointTransactions', 'readonly', (store) => {\n-        const index = store.index('memberId');\n-        return index.getAll(memberId);\n-      });\n-\n-      const now = new Date();\n-      const validTransactions = transactions.filter(t => \n-        !t.isExpired && (!t.expiryDate || t.expiryDate > now)\n-      );\n-\n-      const totalBalance = validTransactions.reduce((sum, t) => sum + t.amount, 0);\n-      const earnedPoints = transactions.filter(t => t.transactionType === 'earn').reduce((sum, t) => sum + t.amount, 0);\n-      const usedPoints = Math.abs(transactions.filter(t => t.transactionType === 'use').reduce((sum, t) => sum + t.amount, 0));\n-      const expiredPoints = Math.abs(transactions.filter(t => t.transactionType === 'expire').reduce((sum, t) => sum + t.amount, 0));\n-\n-      // 만료 예정 포인트 계산\n-      const in30Days = new Date();\n-      in30Days.setDate(in30Days.getDate() + 30);\n-      const in7Days = new Date();\n-      in7Days.setDate(in7Days.getDate() + 7);\n-\n-      const expiringIn30Days = validTransactions.filter(t => \n-        t.expiryDate && t.expiryDate <= in30Days && t.transactionType === 'earn'\n-      ).reduce((sum, t) => sum + t.amount, 0);\n-\n-      const expiringIn7Days = validTransactions.filter(t => \n-        t.expiryDate && t.expiryDate <= in7Days && t.transactionType === 'earn'\n-      ).reduce((sum, t) => sum + t.amount, 0);\n-\n-      const balanceData: PointBalance = {\n-        id: `balance_${memberId}`,\n-        memberId,\n-        totalBalance,\n-        earnedPoints,\n-        usedPoints,\n-        expiredPoints,\n-        expiringIn30Days,\n-        expiringIn7Days,\n-        lastUpdated: new Date(),\n-        createdAt: new Date(),\n-        updatedAt: new Date()\n-      };\n-\n-      await this.executeTransaction('pointBalances', 'readwrite', (store) => \n-        store.put(balanceData)\n-      );\n-\n-      console.log(`포인트 잔액 업데이트 완료: ${memberId} - ${totalBalance.toLocaleString()}원`);\n-    } catch (error) {\n-      console.error('포인트 잔액 업데이트 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 포인트 잔액 조회 (캐시된 값 사용)\n-   */\n-  async getMemberPointBalanceCached(memberId: string): Promise<number> {\n-    try {\n-      const balance = await this.executeTransaction('pointBalances', 'readonly', (store) => \n-        store.get(`balance_${memberId}`)\n-      );\n-\n-      if (balance) {\n-        // 캐시된 값이 너무 오래되었다면 새로 계산\n-        const hoursSinceUpdate = (new Date().getTime() - balance.lastUpdated.getTime()) / (1000 * 60 * 60);\n-        if (hoursSinceUpdate < 1) { // 1시간 이내면 캐시 사용\n-          return balance.totalBalance;\n-        }\n-      }\n-\n-      // 캐시가 없거나 오래되었으면 실시간 계산 후 캐시 업데이트\n-      await this.updatePointBalance(memberId);\n-      const updatedBalance = await this.executeTransaction('pointBalances', 'readonly', (store) => \n-        store.get(`balance_${memberId}`)\n-      );\n-      \n-      return updatedBalance?.totalBalance || 0;\n-    } catch (error) {\n-      console.error('포인트 잔액 조회 실패:', error);\n-      return 0;\n-    }\n-  }\n-\n-  /**\n-   * 개선된 포인트 만료 처리\n-   */\n-  async expirePointsImproved(): Promise<number> {\n-    try {\n-      const now = new Date();\n-      \n-      // 만료된 적립 포인트 조회 (아직 만료 처리되지 않은 것만)\n-      const expiredTransactions = await this.executeTransaction('pointTransactions', 'readonly', (store) => {\n-        return store.getAll();\n-      }).then(transactions => \n-        transactions.filter(t => \n-          t.transactionType === 'earn' && \n-          !t.isExpired &&\n-          t.expiryDate && \n-          t.expiryDate <= now\n-        )\n-      );\n-\n-      let expiredCount = 0;\n-      const memberGroups = new Map<string, PointTransaction[]>();\n-\n-      // 회원별로 그룹화\n-      for (const transaction of expiredTransactions) {\n-        const memberId = transaction.memberId;\n-        if (!memberGroups.has(memberId)) {\n-          memberGroups.set(memberId, []);\n-        }\n-        memberGroups.get(memberId)!.push(transaction);\n-      }\n-\n-      // 각 회원별로 만료 처리\n-      for (const memberData of Array.from(memberGroups.entries())) {\n-        const [memberId, transactions] = memberData;\n-        for (const transaction of transactions) {\n-          // 해당 적립 포인트에서 실제 사용 가능한 금액 계산\n-          const availablePoints = await this.getAvailablePointsOrderByEarnedDate(memberId);\n-          const availablePoint = availablePoints.find(p => p.id === transaction.id);\n-          \n-          if (availablePoint && availablePoint.availableAmount > 0) {\n-            // 만료 처리 기록\n-            await this.addPointTransaction({\n-              memberId,\n-              memberName: transaction.memberName,\n-              amount: -availablePoint.availableAmount,\n-              transactionType: 'expire',\n-              originalTransactionId: transaction.id,\n-              earnedDate: transaction.earnedDate,\n-              isExpired: false,\n-              source: '포인트 만료',\n-              description: `만료일: ${transaction.expiryDate?.toLocaleDateString()}`\n-            });\n-\n-            // 원본 거래를 만료 상태로 표시\n-            await this.markTransactionAsExpired(transaction.id);\n-            expiredCount++;\n-          }\n-        }\n-      }\n-\n-      console.log(`만료된 포인트 처리 완료: ${expiredCount}건`);\n-      return expiredCount;\n-    } catch (error) {\n-      console.error('포인트 만료 처리 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 거래를 만료 상태로 표시\n-   */\n-  async markTransactionAsExpired(transactionId: string): Promise<void> {\n-    try {\n-      const transaction = await this.executeTransaction('pointTransactions', 'readonly', (store) => \n-        store.get(transactionId)\n-      );\n-\n-      if (transaction) {\n-        transaction.isExpired = true;\n-        transaction.updatedAt = new Date();\n-\n-        await this.executeTransaction('pointTransactions', 'readwrite', (store) => \n-          store.put(transaction)\n-        );\n-      }\n-    } catch (error) {\n-      console.error('거래 만료 상태 표시 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  // ==================== 통합 주문 처리 로직 ====================\n-\n-  /**\n-   * 회원가입/수강등록 통합 주문 처리\n-   */\n-  async processOrderWithPayments(orderData: {\n-    memberInfo: {\n-      id: string;\n-      name: string;\n-      branchId: string;\n-      branchName: string;\n-      coach: string;\n-      coachName: string;\n-    };\n-    products: Array<{\n-      id: string;\n-      name: string;\n-      price: number;\n-      programId: string;\n-      programName: string;\n-      programType: string;\n-    }>;\n-    payments: {\n-      cash: number;\n-      card: number;\n-      transfer: number;\n-      points: number;\n-    };\n-    orderType: 'registration' | 'course_enrollment';\n-  }): Promise<string> {\n-    try {\n-      const totalAmount = orderData.products.reduce((sum, p) => sum + p.price, 0);\n-      const totalPaid = orderData.payments.cash + orderData.payments.card + \n-                       orderData.payments.transfer + orderData.payments.points;\n-      const unpaidAmount = Math.max(0, totalAmount - totalPaid);\n-      const excessAmount = Math.max(0, totalPaid - totalAmount);\n-\n-      console.log('=== processOrderWithPayments 계산 ===');\n-      console.log(`총 주문금액: ${totalAmount.toLocaleString()}원`);\n-      console.log(`총 결제금액: ${totalPaid.toLocaleString()}원`);\n-      console.log(`미수금액: ${unpaidAmount.toLocaleString()}원`);\n-      console.log(`초과금액: ${excessAmount.toLocaleString()}원`);\n-\n-      // 1. 주문 생성\n-      const orderId = await this.createOrder({\n-        memberId: orderData.memberInfo.id,\n-        memberName: orderData.memberInfo.name,\n-        branchId: orderData.memberInfo.branchId,\n-        branchName: orderData.memberInfo.branchName,\n-        coach: orderData.memberInfo.coach,\n-        coachName: orderData.memberInfo.coachName,\n-        orderItems: orderData.products.map(p => ({\n-          productId: p.id,\n-          productName: p.name,\n-          programId: p.programId,\n-          programName: p.programName,\n-          programType: p.programType,\n-          price: p.price,\n-          quantity: 1\n-        })),\n-        totalAmount,\n-        paidAmount: totalPaid,\n-        unpaidAmount,\n-        pointsUsed: orderData.payments.points,\n-        pointsEarned: excessAmount,\n-        orderStatus: unpaidAmount > 0 ? 'partially_paid' : 'completed',\n-        orderType: orderData.orderType\n-      });\n-\n-      // 2. 개별 결제 기록 생성\n-      const paymentMethods = [\n-        { method: 'cash', amount: orderData.payments.cash },\n-        { method: 'card', amount: orderData.payments.card },\n-        { method: 'transfer', amount: orderData.payments.transfer }\n-      ];\n-\n-      for (const payment of paymentMethods) {\n-        if (payment.amount > 0) {\n-          await this.addPayment({\n-            orderId,\n-            memberId: orderData.memberInfo.id,\n-            memberName: orderData.memberInfo.name,\n-            branchId: orderData.memberInfo.branchId,\n-            branchName: orderData.memberInfo.branchName,\n-            coach: orderData.memberInfo.coach,\n-            coachName: orderData.memberInfo.coachName,\n-            products: orderData.products.map(p => ({\n-              id: p.id,\n-              name: p.name,\n-              price: p.price,\n-              quantity: 1,\n-              programId: p.programId,\n-              programName: p.programName,\n-              programType: p.programType\n-            })),\n-            totalAmount: payment.amount,\n-            paidAmount: payment.amount,\n-            unpaidAmount: 0,\n-            paymentStatus: 'completed',\n-            paymentMethod: payment.method,\n-            paymentDate: new Date(),\n-            paymentType: 'course',\n-            amount: payment.amount,\n-            memo: `${orderData.orderType} - ${payment.method} 결제`\n-          });\n-        }\n-      }\n-\n-      // 3. 포인트 사용 처리\n-      if (orderData.payments.points > 0) {\n-        await this.usePointsFIFO(\n-          orderData.memberInfo.id,\n-          orderData.payments.points,\n-          orderId,\n-          `${orderData.orderType} 포인트 결제`\n-        );\n-      }\n-\n-      // 4. 초과금 포인트 적립\n-      if (excessAmount > 0) {\n-        console.log(`=== 초과금 포인트 적립 시작: ${excessAmount.toLocaleString()}원 ===`);\n-        const expiryDate = new Date();\n-        expiryDate.setFullYear(expiryDate.getFullYear() + 1);\n-\n-        try {\n-          await this.addPointTransaction({\n-            memberId: orderData.memberInfo.id,\n-            memberName: orderData.memberInfo.name,\n-            amount: excessAmount,\n-            transactionType: 'earn',\n-            relatedOrderId: orderId,\n-            earnedDate: new Date(),\n-            expiryDate,\n-            isExpired: false,\n-            source: `${orderData.orderType} 초과금액`,\n-            description: `${orderData.orderType} 초과금액 포인트 적립`\n-          });\n-          console.log(`포인트 적립 완료: ${excessAmount.toLocaleString()}원`);\n-          alert(`포인트 적립 완료: ${excessAmount.toLocaleString()}원`);\n-        } catch (pointError) {\n-          console.error('포인트 적립 실패:', pointError);\n-          alert(`포인트 적립 실패: ${pointError}`);\n-          throw pointError;\n-        }\n-      } else {\n-        console.log('초과금액이 없어 포인트 적립 없음');\n-      }\n-\n-      // 5. 수강 등록 생성 (상품별)\n-      console.log('=== 수강 등록 생성 시작 ===');\n-      let remainingPaid = totalPaid;\n-      for (const product of orderData.products) {\n-        console.log(`상품 처리: ${product.name} (${product.price.toLocaleString()}원)`);\n-        \n-        // 이 상품에 할당될 결제액 계산\n-        const productPaidAmount = Math.min(remainingPaid, product.price);\n-        const productUnpaidAmount = Math.max(0, product.price - productPaidAmount);\n-        remainingPaid -= productPaidAmount;\n-\n-        console.log(`- 상품별 결제액: ${productPaidAmount.toLocaleString()}원`);\n-        console.log(`- 상품별 미수액: ${productUnpaidAmount.toLocaleString()}원`);\n-\n-        // 상품 상세 정보 조회 (세션 수와 기간 정보를 위해)\n-        const productDetails = await this.getProductById(product.id);\n-        console.log('- 상품 상세 정보:', productDetails);\n-        \n-        // 종료일 계산 (기간제인 경우)\n-        let endDate: Date | undefined;\n-        if (product.programType === '기간제' && productDetails?.duration) {\n-          endDate = new Date();\n-          endDate.setMonth(endDate.getMonth() + productDetails.duration);\n-          console.log(`- 기간제 종료일 설정: ${endDate.toISOString()}`);\n-        }\n-\n-        const courseData = {\n-          orderId,\n-          memberId: orderData.memberInfo.id,\n-          memberName: orderData.memberInfo.name,\n-          productId: product.id,\n-          productName: product.name,\n-          productPrice: product.price,\n-          programId: product.programId,\n-          programName: product.programName,\n-          programType: product.programType,\n-          branchId: orderData.memberInfo.branchId,\n-          branchName: orderData.memberInfo.branchName,\n-          coach: orderData.memberInfo.coach,\n-          coachName: orderData.memberInfo.coachName,\n-          enrollmentStatus: (productUnpaidAmount > 0 ? 'unpaid' : 'active') as 'unpaid' | 'active',\n-          paidAmount: productPaidAmount,\n-          unpaidAmount: productUnpaidAmount,\n-          startDate: new Date(),\n-          endDate: endDate,\n-          sessionCount: product.programType === '횟수제' ? productDetails?.sessions : undefined,\n-          completedSessions: 0,\n-          notes: `${orderData.orderType}을 통한 등록`\n-        };\n-\n-        console.log('- 수강 등록 데이터:', courseData);\n-\n-        try {\n-          const courseId = await this.addCourseEnrollment(courseData);\n-          console.log(`✓ 수강 등록 성공: ${courseId}`);\n-          alert(`수강 등록 성공: ${product.name} - ID: ${courseId.slice(-8)}`);\n-        } catch (courseError) {\n-          console.error(`✗ 수강 등록 실패:`, courseError);\n-          alert(`수강 등록 실패: ${product.name} - 오류: ${courseError}`);\n-          throw courseError;\n-        }\n-      }\n-      console.log('=== 수강 등록 생성 완료 ===');\n-\n-      console.log(`통합 주문 처리 완료: ${orderId}`);\n-      return orderId;\n-    } catch (error) {\n-      console.error('통합 주문 처리 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  // ==================== 데이터 마이그레이션 ====================\n-\n-  /**\n-   * 기존 Point 데이터를 새로운 PointTransaction으로 마이그레이션\n-   */\n-  async migratePointsToTransactions(): Promise<void> {\n-    try {\n-      console.log('포인트 데이터 마이그레이션 시작...');\n-      \n-      // 1. 기존 포인트 데이터 조회\n-      const oldPoints = await this.getAllPoints();\n-      \n-      // 2. 이미 마이그레이션된 데이터가 있는지 확인\n-      const existingTransactions = await this.executeTransaction('pointTransactions', 'readonly', (store) => \n-        store.getAll()\n-      );\n-      \n-      if (existingTransactions.length > 0) {\n-        console.log('이미 마이그레이션된 포인트 거래내역이 있습니다. 스킵합니다.');\n-        return;\n-      }\n-      \n-      // 3. 각 포인트를 PointTransaction으로 변환\n-      for (const point of oldPoints) {\n-        const transactionType = point.amount > 0 ? 'earn' : \n-                               point.type === 'used' ? 'use' :\n-                               point.type === 'expired' ? 'expire' : 'adjust';\n-        \n-        await this.addPointTransaction({\n-          memberId: point.memberId,\n-          memberName: point.memberName,\n-          amount: point.amount,\n-          transactionType: transactionType as any,\n-          earnedDate: point.createdAt,\n-          expiryDate: point.expiryDate || undefined,\n-          isExpired: point.type === 'expired',\n-          source: point.source,\n-          description: point.description,\n-          relatedPaymentId: point.relatedPaymentId\n-        });\n-      }\n-      \n-      // 4. 모든 회원의 포인트 잔액 업데이트\n-      const members = await this.getAllMembers();\n-      for (const member of members) {\n-        await this.updatePointBalance(member.id);\n-      }\n-      \n-      console.log(`포인트 데이터 마이그레이션 완료: ${oldPoints.length}건 처리`);\n-    } catch (error) {\n-      console.error('포인트 데이터 마이그레이션 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 기존 결제 데이터에 orderId 추가 (역호환성)\n-   */\n-  async migratePaymentsWithOrderId(): Promise<void> {\n-    try {\n-      console.log('결제 데이터 주문 ID 마이그레이션 시작...');\n-      \n-      const payments = await this.getAllPayments();\n-      const paymentsWithoutOrderId = payments.filter(p => !p.orderId);\n-      \n-      if (paymentsWithoutOrderId.length === 0) {\n-        console.log('마이그레이션이 필요한 결제 데이터가 없습니다.');\n-        return;\n-      }\n-      \n-      // 각 결제에 대해 가상의 주문 생성\n-      for (const payment of paymentsWithoutOrderId) {\n-        // 1. 기존 결제를 위한 주문 생성\n-        const orderId = await this.createOrder({\n-          memberId: payment.memberId,\n-          memberName: payment.memberName,\n-          branchId: payment.branchId,\n-          branchName: payment.branchName,\n-          coach: payment.coach,\n-          coachName: payment.coachName,\n-          orderItems: payment.products.map(p => ({\n-            productId: p.id,\n-            productName: p.name,\n-            programId: p.programId || '',\n-            programName: p.programName || '',\n-            programType: p.programType || '',\n-            price: p.price,\n-            quantity: p.quantity\n-          })),\n-          totalAmount: payment.totalAmount,\n-          paidAmount: payment.paidAmount,\n-          unpaidAmount: payment.unpaidAmount,\n-          pointsUsed: 0, // 기존 데이터에서는 포인트 사용 정보 없음\n-          pointsEarned: 0,\n-          orderStatus: payment.paymentStatus === 'completed' ? 'completed' : \n-                      payment.paymentStatus === 'unpaid' ? 'partially_paid' : 'pending',\n-          orderType: payment.paymentType === 'course' ? 'course_enrollment' : 'product_purchase',\n-          memo: `마이그레이션된 기존 결제 (원본 결제 ID: ${payment.id.slice(-8)})`\n-        });\n-        \n-        // 2. 결제에 주문 ID 추가\n-        await this.updatePayment(payment.id, { orderId });\n-        \n-        // 3. 관련 수강 등록에도 주문 ID 추가\n-        if (payment.relatedCourseId) {\n-          await this.updateCourseEnrollment(payment.relatedCourseId, { orderId });\n-        }\n-      }\n-      \n-      console.log(`결제 데이터 주문 ID 마이그레이션 완료: ${paymentsWithoutOrderId.length}건 처리`);\n-    } catch (error) {\n-      console.error('결제 데이터 주문 ID 마이그레이션 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * 전체 데이터 마이그레이션 실행\n-   */\n-  async runMigrations(): Promise<void> {\n-    try {\n-      console.log('=== 데이터 마이그레이션 시작 ===');\n-      \n-      // 1. 포인트 데이터 마이그레이션\n-      await this.migratePointsToTransactions();\n-      \n-      // 2. 결제 데이터에 주문 ID 추가\n-      await this.migratePaymentsWithOrderId();\n-      \n-      console.log('=== 데이터 마이그레이션 완료 ===');\n-    } catch (error) {\n-      console.error('데이터 마이그레이션 실패:', error);\n-      throw error;\n-    }\n-  }\n-\n-  // ==================== 개선된 포인트 잔액 조회 (호환성 유지) ====================\n-\n-  /**\n-   * 회원 포인트 잔액 조회 (기존 메서드 오버라이드 - 호환성 유지)\n-   */\n-  async getMemberPointBalanceV2(memberId: string): Promise<number> {\n-    try {\n-      // 1. 새로운 PointTransaction 데이터가 있는지 확인\n-      const transactions = await this.executeTransaction('pointTransactions', 'readonly', (store) => {\n-        const index = store.index('memberId');\n-        return index.getAll(memberId);\n-      });\n-\n-      if (transactions.length > 0) {\n-        // 새로운 시스템 사용: 캐시된 잔액 조회\n-        return await this.getMemberPointBalanceCached(memberId);\n-      } else {\n-        // 기존 시스템 사용: Point 테이블에서 계산\n-        const points = await this.getPointsByMember(memberId);\n-        const now = new Date();\n-        \n-        const validPoints = points.filter(point => {\n-          return !point.expiryDate || point.expiryDate > now;\n-        });\n-        \n-        return validPoints.reduce((total, point) => total + point.amount, 0);\n-      }\n-    } catch (error) {\n-      console.error('포인트 잔액 조회 실패:', error);\n-      return 0;\n-    }\n-  }\n-}\n-\n-// 싱글톤 인스턴스 생성\n-export const dbManager = new IndexedDBManager();\n-\n-// 개발자 도구에서 사용할 수 있도록 전역 객체에 추가\n-if (typeof window !== 'undefined') {\n-  (window as any).dbManager = dbManager;\n-}\n+// 기본 export는 dbManager\n+export default dbManager;\n"
                }
            ],
            "date": 1759899370645,
            "name": "Commit-0",
            "content": "/**\n * IndexedDB를 활용한 로컬 데이터베이스 관리 유틸리티\n * 백엔드 연결 전까지 브라우저에서 데이터를 영구 저장\n */\n\nexport interface DBRecord {\n  id: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface Branch extends DBRecord {\n  name: string;\n  address?: string;\n  phone?: string;\n  isActive: boolean;\n}\n\nclass IndexedDBManager {\n  private dbName: string = 'LavidaDB';\n  private version: number = 1;\n  private db: IDBDatabase | null = null;\n\n  constructor() {\n    this.initDB();\n  }\n\n  /**\n   * IndexedDB 초기화\n   */\n  private async initDB(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version);\n\n      request.onerror = () => {\n        console.error('IndexedDB 열기 실패:', request.error);\n        reject(request.error);\n      };\n\n      request.onsuccess = () => {\n        this.db = request.result;\n        console.log('IndexedDB 연결 성공');\n        resolve();\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n\n        // 지점 테이블 생성\n        if (!db.objectStoreNames.contains('branches')) {\n          const branchStore = db.createObjectStore('branches', { keyPath: 'id' });\n          branchStore.createIndex('name', 'name', { unique: false });\n          branchStore.createIndex('isActive', 'isActive', { unique: false });\n          branchStore.createIndex('createdAt', 'createdAt', { unique: false });\n        }\n\n        // 향후 다른 테이블들도 여기에 추가 가능\n        // 예: 회원, 직원, 방문기록 등\n      };\n    });\n  }\n\n  /**\n   * 고유 ID 생성 (UUID v4 형식)\n   */\n  private generateUUID(): string {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      const r = Math.random() * 16 | 0;\n      const v = c === 'x' ? r : ((r & 0x3) | 0x8);\n      return v.toString(16);\n    });\n  }\n\n  /**\n   * 트랜잭션 실행 헬퍼\n   */\n  private async executeTransaction<T>(\n    storeName: string,\n    mode: IDBTransactionMode,\n    operation: (store: IDBObjectStore) => IDBRequest<T>\n  ): Promise<T> {\n    if (!this.db) {\n      await this.initDB();\n    }\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([storeName], mode);\n      const store = transaction.objectStore(storeName);\n      const request = operation(store);\n\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  // === 지점 관리 메서드들 ===\n\n  /**\n   * 모든 지점 조회\n   */\n  async getAllBranches(): Promise<Branch[]> {\n    try {\n      return await this.executeTransaction('branches', 'readonly', (store) => \n        store.getAll()\n      );\n    } catch (error) {\n      console.error('지점 조회 실패:', error);\n      return [];\n    }\n  }\n\n  /**\n   * ID로 지점 조회\n   */\n  async getBranchById(id: string): Promise<Branch | null> {\n    try {\n      const result = await this.executeTransaction('branches', 'readonly', (store) => \n        store.get(id)\n      );\n      return result || null;\n    } catch (error) {\n      console.error('지점 조회 실패:', error);\n      return null;\n    }\n  }\n\n  /**\n   * 지점 추가\n   */\n  async addBranch(branchData: Omit<Branch, 'id' | 'createdAt' | 'updatedAt'>): Promise<Branch> {\n    const now = new Date();\n    const newBranch: Branch = {\n      ...branchData,\n      id: this.generateUUID(),\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    try {\n      await this.executeTransaction('branches', 'readwrite', (store) => \n        store.add(newBranch)\n      );\n      console.log('지점 추가 성공:', newBranch);\n      return newBranch;\n    } catch (error) {\n      console.error('지점 추가 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 지점 수정\n   */\n  async updateBranch(id: string, updates: Partial<Omit<Branch, 'id' | 'createdAt'>>): Promise<Branch | null> {\n    try {\n      const existing = await this.getBranchById(id);\n      if (!existing) {\n        throw new Error('존재하지 않는 지점입니다.');\n      }\n\n      const updatedBranch: Branch = {\n        ...existing,\n        ...updates,\n        updatedAt: new Date(),\n      };\n\n      await this.executeTransaction('branches', 'readwrite', (store) => \n        store.put(updatedBranch)\n      );\n\n      console.log('지점 수정 성공:', updatedBranch);\n      return updatedBranch;\n    } catch (error) {\n      console.error('지점 수정 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 지점 삭제\n   */\n  async deleteBranch(id: string): Promise<boolean> {\n    try {\n      await this.executeTransaction('branches', 'readwrite', (store) => \n        store.delete(id)\n      );\n      console.log('지점 삭제 성공:', id);\n      return true;\n    } catch (error) {\n      console.error('지점 삭제 실패:', error);\n      return false;\n    }\n  }\n\n  /**\n   * 활성 지점만 조회\n   */\n  async getActiveBranches(): Promise<Branch[]> {\n    try {\n      return await this.executeTransaction('branches', 'readonly', (store) => {\n        const index = store.index('isActive');\n        return index.getAll(IDBKeyRange.only(true));\n      });\n    } catch (error) {\n      console.error('활성 지점 조회 실패:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 지점명으로 검색\n   */\n  async searchBranchesByName(name: string): Promise<Branch[]> {\n    try {\n      const allBranches = await this.getAllBranches();\n      return allBranches.filter(branch => \n        branch.name.toLowerCase().includes(name.toLowerCase())\n      );\n    } catch (error) {\n      console.error('지점 검색 실패:', error);\n      return [];\n    }\n  }\n\n  /**\n   * 데이터베이스 초기화 (개발/테스트용)\n   */\n  async clearAllData(): Promise<void> {\n    try {\n      await this.executeTransaction('branches', 'readwrite', (store) => \n        store.clear()\n      );\n      console.log('모든 데이터 삭제 완료');\n    } catch (error) {\n      console.error('데이터 삭제 실패:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 초기 샘플 데이터 생성\n   */\n  async seedSampleData(): Promise<void> {\n    const sampleBranches = [\n      { name: '강남점', address: '서울시 강남구', phone: '02-1234-5678', isActive: true },\n      { name: '홍대점', address: '서울시 마포구', phone: '02-2345-6789', isActive: true },\n      { name: '판교점', address: '경기도 성남시', phone: '031-3456-7890', isActive: true },\n    ];\n\n    try {\n      for (const branchData of sampleBranches) {\n        await this.addBranch(branchData);\n      }\n      console.log('샘플 데이터 생성 완료');\n    } catch (error) {\n      console.error('샘플 데이터 생성 실패:', error);\n    }\n  }\n}\n\n// 싱글톤 인스턴스 생성\nexport const dbManager = new IndexedDBManager();\n\n// 개발자 도구에서 사용할 수 있도록 전역 객체에 추가\nif (typeof window !== 'undefined') {\n  (window as any).dbManager = dbManager;\n}\n"
        }
    ]
}